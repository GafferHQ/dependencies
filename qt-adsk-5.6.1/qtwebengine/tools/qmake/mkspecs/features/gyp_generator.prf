# This file is loaded after the dummy .pro and all the default_post ran.
# This is the right point to extract the variables we're interested in and generate
# the .gyp file that we'll use later on when running gyp

load(functions)
load(moc)
load(resources)

MOC_GEN_DIR = <(SHARED_INTERMEDIATE_DIR)/moc
RCC_GEN_DIR = <(SHARED_INTERMEDIATE_DIR)/rcc

defineReplace(mocAction) {
    INPUT_FILE = $$1
    OUTPUT_NAME = $$mocOutput($$INPUT_FILE)
    DEFINES_LIST = $$join(DEFINES, " -D", -D)
    INCPATH = $$join(INCLUDEPATH, " -I", -I)
    MOC_COMMAND = $$clean_path($$mocCmdBase())
    MOC_COMMAND = $$replace(MOC_COMMAND, $$re_escape("$(DEFINES)"), $$DEFINES_LIST)
    MOC_COMMAND = $$replace(MOC_COMMAND, $$re_escape("$(INCPATH)"), $$INCPATH)
    MOC_COMMAND = $$split(MOC_COMMAND, " ")
    OUTPUT_FILE = $$MOC_GEN_DIR/$${OUTPUT_NAME}
    contents = "      {" \
               "        'action_name':'$$OUTPUT_NAME'," \
               "        'inputs': ['$$INPUT_FILE',]," \
               "        'outputs': ['$$OUTPUT_FILE',]," \
               "        'action': ["
    for(token, MOC_COMMAND): contents += "          '$$replace(token,\',)',"
    contents += "          '$$INPUT_FILE'," \
                "          '-o'," \
                "          '$$OUTPUT_FILE'," \
                "        ]," \
                "     },"

    return($$contents)
}

defineReplace(rccAction) {
    INPUT_FILE = $$1
    OUTPUT_NAME = $$rccOutput($$INPUT_FILE)
    EXTERN_FUNC = $$rccExternFunc($$INPUT_FILE)
    OUTPUT_FILE = $$RCC_GEN_DIR/$${OUTPUT_NAME}
    CLEAN_QMAKE_RCC = $$clean_path($$QMAKE_RCC)
    contents = "      {" \
               "        'action_name':'$$OUTPUT_NAME'," \
               "        'inputs': ['$$INPUT_FILE',]," \
               "        'outputs': ['$$OUTPUT_FILE',]," \
               "        'action': [" \
               "          '$$replace(CLEAN_QMAKE_RCC,\',)',"
    for(resource_flag, $$QMAKE_RESOURCE_FLAGS): contents += "          '$$resource_flag',"
    contents += "          '-name'," \
                "          '$$EXTERN_FUNC'," \
                "          '$$INPUT_FILE'," \
                "          '-o'," \
                "          '$$OUTPUT_FILE',"
    contents += "        ]," \
                "     },"

    return($$contents)
}

isEmpty(GYPFILE): GYPFILE = $$replace(_PRO_FILE_, .pro$, .gyp)

TARGET_TYPE = $$toGypTargetType()
MOCABLES = $$findMocables($$HEADERS)
MOCABLES += $$findMocables($$SOURCES)
INCLUDED_MOC_FILES = $$findIncludedMocFiles($$SOURCES)

GYP_CONTENTS =  "{" \
                "  'targets': [" \
                "  {" \
                "    'target_name': '$$TARGET'," \
                "    'type': '$$TARGET_TYPE',"
!isEmpty(GYPINCLUDES) {
GYP_CONTENTS += "    'includes': ["
for (incl, GYPINCLUDES): GYP_CONTENTS += "      '$$incl',"
GYP_CONTENTS += "    ],"
}

!isEmpty(QMAKE_FRAMEWORKPATH) {
    GYP_CONTENTS += "    'mac_framework_dirs': ["
    for(path, QMAKE_FRAMEWORKPATH): GYP_CONTENTS += "      '$$path',"
    GYP_CONTENTS += "    ],"
}

!isEmpty(QMAKE_CFLAGS) {
    GYP_CONTENTS += "    'cflags': ["
    for(flag, QMAKE_CFLAGS): GYP_CONTENTS += "      '$$flag',"
    GYP_CONTENTS += "    ],"
}
!isEmpty(QMAKE_CXXFLAGS) {
    GYP_CONTENTS += "    'cflags_cc': ["
    for(flag, QMAKE_CXXFLAGS): GYP_CONTENTS += "      '$$flag',"
    GYP_CONTENTS += "    ],"
}

GYP_CONTENTS += "    'defines': ["
for (define, DEFINES): GYP_CONTENTS += "      '$$define',"
!isEmpty(QMAKE_LIBDIR_EGL): GYP_CONTENTS += "      'QT_LIBDIR_EGL=\"$${QMAKE_DIR_SEP}$$relative_path($$QMAKE_LIBDIR_EGL, $$[QT_SYSROOT])\"',"
!isEmpty(QMAKE_LIBDIR_OPENGL_ES2): GYP_CONTENTS += "      'QT_LIBDIR_GLES2=\"$${QMAKE_DIR_SEP}$$relative_path($$QMAKE_LIBDIR_OPENGL_ES2, $$[QT_SYSROOT])\"',"
GYP_CONTENTS += "    ],"

!isEmpty(GYP_DYLIB_INSTALL_NAME_BASE) {
  GYP_CONTENTS += "    'xcode_settings': {" \
                  "      'DYLIB_INSTALL_NAME_BASE': '$$GYP_DYLIB_INSTALL_NAME_BASE'," \
                  "    },"
}

# Source files to compile
GYP_CONTENTS += "    'sources': ["
for (sourcefile, SOURCES): GYP_CONTENTS += "      '$$sourcefile',"
for (headerfile, HEADERS): GYP_CONTENTS += "      '$$headerfile',"

# Add Sources generated by rcc from qrc files.
for (resourcefile, RESOURCES) {
  RCC_CPP = $$replace(resourcefile, .qrc, .cpp)
  RCC_CPP = $$join(RCC_CPP, "qrc_", qrc_)
  RCC_CPP = $$RCC_GEN_DIR/$${RCC_CPP}
  GYP_CONTENTS += "      '$$RCC_CPP',"
}

# Add moc output files to compile that aren't included at the end of any other source
for (mocable, MOCABLES) {
    !contains(INCLUDED_MOC_FILES, $$mocOutput($$mocable)) {
        GYP_CONTENTS += "      '$$MOC_GEN_DIR/$$mocOutput($$mocable)',"
    }
}

GYP_CONTENTS += "    ],"
GYP_CONTENTS += "    'include_dirs': ["
for (path, INCLUDEPATH): GYP_CONTENTS += "      '$$path',"
# qmake already added MOC_DIR to INCLUDEPATH, but we're telling gyp to use a different one.
GYP_CONTENTS += "      '$$MOC_GEN_DIR',"
GYP_CONTENTS += "    ],"

# Generate the actions for moc and rcc
GYP_CONTENTS += "    'actions': ["
for(resourcefile, RESOURCES): GYP_CONTENTS += $$rccAction($$resourcefile)
for(mocable, MOCABLES): GYP_CONTENTS += $$mocAction($$mocable)
GYP_CONTENTS += "    ]," \
                "  },"

GYP_CONTENTS += "  ]," \
                "}"

!build_pass: write_file($$GYPFILE, GYP_CONTENTS)

# Overwriting the generated gyp file seems like a good reason to re-gyp
unix: system("touch $$QTWEBENGINE_ROOT/src/core/gyp_run.pro")

# The generated Makefile shouldn't build anything by itself, just re-run qmake if necessary
TEMPLATE = aux
SOURCES =
HEADERS =
RESOURCES =
