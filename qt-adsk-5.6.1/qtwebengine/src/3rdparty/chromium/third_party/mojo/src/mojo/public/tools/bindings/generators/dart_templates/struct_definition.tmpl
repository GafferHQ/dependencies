{#--- Begin #}

{%- import "encoding_macros.tmpl" as encoding_macros %}



{%- macro struct_def(struct) %}
class {{struct|name}} extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
{%- for version in struct.versions %}
    const bindings.StructDataHeader({{version.num_bytes}}, {{version.version}}){% if not loop.last %},{% endif %}
{%- endfor %}
  ];

{#--- Enums #}
{%- from "enum_definition.tmpl" import enum_def %}
{%-  for enum in struct.enums %}
  {{enum_def("  static ", enum)}}
{%-  endfor %}


{#--- Constants #}
{%-  for constant in struct.constants %}
  static const {{constant.name}} = {{constant.value|expression_to_text}};
{%-  endfor %}

{#--- initDefaults() #}
{%- for packed_field in struct.packed.packed_fields %}
  {{packed_field.field.kind|dart_type}} {{packed_field.field|name}} = {{packed_field.field|default_value}};
{%- endfor %}

  {{struct|name}}() : super(kVersions.last.size);

  static {{struct|name}} deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    decoder.excessHandles.forEach((h) => h.close());
    return result;
  }

  static {{struct|name}} decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    {{struct|name}} result = new {{struct|name}}();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }

{%- for byte in struct.bytes %}
{%-   for packed_field in byte.packed_fields %}
    if (mainDataHeader.version >= {{packed_field.min_version}}) {
      {{encoding_macros.decode('result.' ~ packed_field.field|name, packed_field.field.kind, 8+packed_field.offset, packed_field.bit)|indent(6)}}
    }
{%-   endfor %}
{%- endfor %}
    return result;
  }

  void encode(bindings.Encoder encoder) {
{%- if not struct.bytes %}
    encoder.getStructEncoderAtOffset(kVersions.last);
{%- else %}
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
{%- endif %}
{%- for byte in struct.bytes %}
{%-   for packed_field in byte.packed_fields %}
    {{encoding_macros.encode(packed_field.field|name, packed_field.field.kind, 8+packed_field.offset, packed_field.bit)|indent(4)}}
{%-   endfor %}
{%- endfor %}
  }

  String toString() {
    return "{{struct|name}}("
{%- for packed_field in struct.packed.packed_fields %}
           "{{packed_field.field|name}}: ${{packed_field.field|name}}" {% if not loop.last %}", "{% endif %}
{%- endfor %}")";
  }
}
{%- endmacro %}
