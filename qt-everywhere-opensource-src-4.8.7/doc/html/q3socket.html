<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- q3socket.cpp -->
  <title>Qt 4.8: Q3Socket Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qt3support.html">Qt3Support</a></li>
<li>Q3Socket</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">Q3Socket Class Reference</h1>
<!-- $$$Q3Socket-brief -->
<p>The Q3Socket class provides a buffered TCP connection. <a href="#details">More...</a></p>
<!-- @@@Q3Socket -->
<pre class="cpp"> <span class="preprocessor">#include &lt;Q3Socket&gt;</span></pre><p><b>This class is part of the Qt 3 support library.</b> It is provided to keep old source code working. We strongly advise against using it in new code. See <a href="porting4.html#qsocket">Porting to Qt 4</a> for more information.</p>
<p><b>Inherits: </b><a href="qiodevice.html">QIODevice</a>.</p>
<ul>
<li><a href="q3socket-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#Error-enum">Error</a></b> { ErrConnectionRefused, ErrHostNotFound, ErrSocketRead }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#State-enum">State</a></b> { Idle, HostLookup, Connecting, Connected, Closing }</td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#Q3Socket">Q3Socket</a></b> ( QObject * <i>parent</i> = 0, const char * <i>name</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#dtor.Q3Socket">~Q3Socket</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#address">address</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Offset </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#at">at</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#at-2">at</a></b> ( Offset <i>index</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#clearPendingData">clearPendingData</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connectToHost">connectToHost</a></b> ( const QString &amp; <i>host</i>, Q_UINT16 <i>port</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#flush">flush</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#getch">getch</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#open-2">open</a></b> ( int <i>m</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerAddress">peerAddress</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerName">peerName</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_UINT16 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerPort">peerPort</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_UINT16 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#port">port</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#putch">putch</a></b> ( int <i>ch</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readBufferSize">readBufferSize</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setReadBufferSize">setReadBufferSize</a></b> ( Q_ULONG <i>bufSize</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setSocket">setSocket</a></b> ( int <i>socket</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setSocketDevice">setSocketDevice</a></b> ( Q3SocketDevice * <i>device</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#socket">socket</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q3SocketDevice * </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#socketDevice">socketDevice</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> State </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#state">state</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#ungetch">ungetch</a></b> ( int <i>ch</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#waitForMore">waitForMore</a></b> ( int <i>msecs</i>, bool * <i>timeout</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#waitForMore-2">waitForMore</a></b> ( int <i>msecs</i> ) const</td></tr>
</table>
<a name="reimplemented-public-functions"></a>
<h2>Reimplemented Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#atEnd">atEnd</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesAvailable">bytesAvailable</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesToWrite">bytesToWrite</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#canReadLine">canReadLine</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#close">close</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#open">open</a></b> ( OpenMode <i>m</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual Offset </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#size">size</a></b> () const</td></tr>
</table>
<ul>
<li class="fn">33 public functions inherited from <a href="qiodevice.html#public-functions">QIODevice</a></li>
<li class="fn">29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesWritten">bytesWritten</a></b> ( int <i>nbytes</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connected">connected</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connectionClosed">connectionClosed</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#error">error</a></b> ( int <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#hostFound">hostFound</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readyRead">readyRead</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">4 signals inherited from <a href="qiodevice.html#signals">QIODevice</a></li>
<li class="fn">1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2>Reimplemented Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readData">readData</a></b> ( char * <i>data</i>, qint64 <i>maxlen</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#writeData">writeData</a></b> ( const char * <i>data</i>, qint64 <i>len</i> )</td></tr>
</table>
<ul>
<li class="fn">5 protected functions inherited from <a href="qiodevice.html#protected-functions">QIODevice</a></li>
<li class="fn">8 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">7 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li class="fn">5 protected functions inherited from <a href="qiodevice.html#protected-functions">QIODevice</a></li>
<li class="fn">8 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$Q3Socket-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The Q3Socket class provides a buffered TCP connection.</p>
<p>It provides a totally non-blocking <a href="qiodevice.html">QIODevice</a>, and modifies and extends the API of <a href="qiodevice.html">QIODevice</a> with socket-specific code.</p>
<p>The functions you're likely to call most are <a href="q3socket.html#connectToHost">connectToHost</a>(), <a href="q3socket.html#bytesAvailable">bytesAvailable</a>(), <a href="q3socket.html#canReadLine">canReadLine</a>() and the ones it inherits from <a href="qiodevice.html">QIODevice</a>.</p>
<p><a href="q3socket.html#connectToHost">connectToHost</a>() is the most-used function. As its name implies, it opens a connection to a named host.</p>
<p>Most network protocols are either packet-oriented or line-oriented. <a href="q3socket.html#canReadLine">canReadLine</a>() indicates whether a connection contains an entire unread line or not, and <a href="q3socket.html#bytesAvailable">bytesAvailable</a>() returns the number of bytes available for reading.</p>
<p>The signals <a href="q3socket.html#error">error</a>(), <a href="q3socket.html#connected">connected</a>(), <a href="q3socket.html#readyRead">readyRead</a>() and <a href="q3socket.html#connectionClosed">connectionClosed</a>() inform you of the progress of the connection. There are also some less commonly used signals. <a href="q3socket.html#hostFound">hostFound</a>() is emitted when <a href="q3socket.html#connectToHost">connectToHost</a>() has finished its DNS lookup and is starting its TCP connection. <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>() is emitted when <a href="q3socket.html#close">close</a>() succeeds. <a href="q3socket.html#bytesWritten">bytesWritten</a>() is emitted when Q3Socket moves data from its &quot;to be written&quot; queue into the TCP implementation.</p>
<p>There are several access functions for the socket: <a href="q3socket.html#state">state</a>() returns whether the object is idle, is doing a DNS lookup, is connecting, has an operational connection, etc. <a href="q3socket.html#address">address</a>() and <a href="q3socket.html#port">port</a>() return the IP address and port used for the connection. The <a href="q3socket.html#peerAddress">peerAddress</a>() and <a href="q3socket.html#peerPort">peerPort</a>() functions return the IP address and port used by the peer, and <a href="q3socket.html#peerName">peerName</a>() returns the name of the peer (normally the name that was passed to <a href="q3socket.html#connectToHost">connectToHost</a>()). <a href="q3socket.html#socketDevice">socketDevice</a>() returns a pointer to the <a href="q3socketdevice.html">Q3SocketDevice</a> used for this socket.</p>
<p>Q3Socket inherits <a href="qiodevice.html">QIODevice</a>, and reimplements some functions. In general, you can treat it as a <a href="qiodevice.html">QIODevice</a> for writing, and mostly also for reading. The match isn't perfect, since the <a href="qiodevice.html">QIODevice</a> API is designed for devices that are controlled by the same machine, and an asynchronous peer-to-peer network connection isn't quite like that. For example, there is nothing that matches <a href="qiodevice.html#size">QIODevice::size</a>() exactly. The documentation for <a href="q3socket.html#open">open</a>(), <a href="q3socket.html#close">close</a>(), <a href="q3socket.html#flush">flush</a>(), <a href="q3socket.html#size">size</a>(), <a href="q3socket.html#at">at</a>(), <a href="q3socket.html#atEnd">atEnd</a>(), <a href="qiodevice-qt3.html#readBlock">readBlock</a>(), <a href="qiodevice-qt3.html#writeBlock">writeBlock</a>(), <a href="q3socket.html#getch">getch</a>(), <a href="q3socket.html#putch">putch</a>(), <a href="q3socket.html#ungetch">ungetch</a>() and <a href="qiodevice.html#readLine">readLine</a>() describes the differences in detail.</p>
<p><b>Warning:</b> Q3Socket is not suitable for use in threads. If you need to uses sockets in threads use the lower-level <a href="q3socketdevice.html">Q3SocketDevice</a> class.</p>
</div>
<p><b>See also </b><a href="q3socketdevice.html">Q3SocketDevice</a>, <a href="qhostaddress.html">QHostAddress</a>, and <a href="qsocketnotifier.html">QSocketNotifier</a>.</p>
<!-- @@@Q3Socket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Error$$$ErrConnectionRefused$$$ErrHostNotFound$$$ErrSocketRead -->
<h3 class="fn"><a name="Error-enum"></a>enum Q3Socket::<span class="name">Error</span></h3>
<p>This enum specifies the possible errors:</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>Q3Socket::ErrConnectionRefused</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">if the connection was refused</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::ErrHostNotFound</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">if the host was not found</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::ErrSocketRead</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">if a read from the socket failed</td></tr>
</table>
<!-- @@@Error -->
<!-- $$$State$$$Idle$$$HostLookup$$$Connecting$$$Connected$$$Closing$$$Connection -->
<h3 class="fn"><a name="State-enum"></a>enum Q3Socket::<span class="name">State</span></h3>
<p>This enum defines the connection states:</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>Q3Socket::Idle</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">if there is no connection</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::HostLookup</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">during a DNS lookup</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::Connecting</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">during TCP connection establishment</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::Connected</tt></td><td class="topAlign"><tt>3</tt></td><td class="topAlign">when there is an operational connection</td></tr>
<tr><td class="topAlign"><tt>Q3Socket::Closing</tt></td><td class="topAlign"><tt>4</tt></td><td class="topAlign">if the socket is closing down, but is not yet closed.</td></tr>
</table>
<!-- @@@State -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$Q3Socket[overload1]$$$Q3SocketQObject*constchar* -->
<h3 class="fn"><a name="Q3Socket"></a>Q3Socket::<span class="name">Q3Socket</span> ( <span class="type"><a href="qobject.html">QObject</a></span> * <i>parent</i> = 0, const <span class="type">char</span> * <i>name</i> = 0 )</h3>
<p>Creates a <a href="q3socket.html" class="compat">Q3Socket</a> object in <a href="q3socket.html#State-enum">Q3Socket::Idle</a> state.</p>
<p>The <i>parent</i> and <i>name</i> arguments are passed on to the <a href="qobject.html">QObject</a> constructor.</p>
<!-- @@@Q3Socket -->
<!-- $$$~Q3Socket[overload1]$$$~Q3Socket -->
<h3 class="fn"><a name="dtor.Q3Socket"></a>Q3Socket::<span class="name">~Q3Socket</span> ()<tt> [virtual]</tt></h3>
<p>Destroys the socket. Closes the connection if necessary.</p>
<p><b>See also </b><a href="q3socket.html#close">close</a>().</p>
<!-- @@@~Q3Socket -->
<!-- $$$address[overload1]$$$address -->
<h3 class="fn"><a name="address"></a><span class="type"><a href="qhostaddress.html">QHostAddress</a></span> Q3Socket::<span class="name">address</span> () const</h3>
<p>Returns the host address of this socket. (This is normally the main IP address of the host, but can be e.g&#x2e; 127.0&#x2e;0&#x2e;1 for connections to localhost.)</p>
<!-- @@@address -->
<!-- $$$at[overload1]$$$at -->
<h3 class="fn"><a name="at"></a><span class="type"><a href="qiodevice-qt3.html#Offset-typedef">Offset</a></span> Q3Socket::<span class="name">at</span> () const</h3>
<p>Returns the current read index. Since <a href="q3socket.html" class="compat">Q3Socket</a> is a sequential device, the current read index is always zero.</p>
<!-- @@@at -->
<!-- $$$at$$$atOffset -->
<h3 class="fn"><a name="at-2"></a><span class="type">bool</span> Q3Socket::<span class="name">at</span> ( <span class="type"><a href="qiodevice-qt3.html#Offset-typedef">Offset</a></span> <i>index</i> )</h3>
<p>This is an overloaded function.</p>
<p>Moves the read index forward to <i>index</i> and returns true if the operation was successful; otherwise returns false. Moving the index forward means skipping incoming data.</p>
<!-- @@@at -->
<!-- $$$atEnd[overload1]$$$atEnd -->
<h3 class="fn"><a name="atEnd"></a><span class="type">bool</span> Q3Socket::<span class="name">atEnd</span> () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#atEnd">QIODevice::atEnd</a>().</p>
<p>Returns true if there is no more data to read; otherwise returns false.</p>
<!-- @@@atEnd -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn"><a name="bytesAvailable"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> Q3Socket::<span class="name">bytesAvailable</span> () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#bytesAvailable">QIODevice::bytesAvailable</a>().</p>
<p>Returns the number of incoming bytes that can be read, i.e&#x2e; the size of the input buffer. Equivalent to <a href="q3socket.html#size">size</a>().</p>
<p><b>See also </b><a href="q3socket.html#bytesToWrite">bytesToWrite</a>().</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn"><a name="bytesToWrite"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> Q3Socket::<span class="name">bytesToWrite</span> () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#bytesToWrite">QIODevice::bytesToWrite</a>().</p>
<p>Returns the number of bytes that are waiting to be written, i.e&#x2e; the size of the output buffer.</p>
<p><b>See also </b><a href="q3socket.html#bytesAvailable">bytesAvailable</a>() and <a href="q3socket.html#clearPendingData">clearPendingData</a>().</p>
<!-- @@@bytesToWrite -->
<!-- $$$bytesWritten[overload1]$$$bytesWrittenint -->
<h3 class="fn"><a name="bytesWritten"></a><span class="type">void</span> Q3Socket::<span class="name">bytesWritten</span> ( <span class="type">int</span> <i>nbytes</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when data has been written to the network. The <i>nbytes</i> parameter specifies how many bytes were written.</p>
<p>The <a href="q3socket.html#bytesToWrite">bytesToWrite</a>() function is often used in the same context; it indicates how many buffered bytes there are left to write.</p>
<p><b>See also </b><a href="qiodevice-qt3.html#writeBlock" class="compat">writeBlock</a>() and <a href="q3socket.html#bytesToWrite">bytesToWrite</a>().</p>
<!-- @@@bytesWritten -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn"><a name="canReadLine"></a><span class="type">bool</span> Q3Socket::<span class="name">canReadLine</span> () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#canReadLine">QIODevice::canReadLine</a>().</p>
<p>Returns true if it's possible to read an entire line of text from this socket at this time; otherwise returns false.</p>
<p>Note that if the peer closes the connection unexpectedly, this function returns false. This means that loops such as this won't work:</p>
<pre class="cpp"> <span class="keyword">while</span>( <span class="operator">!</span>socket<span class="operator">-</span><span class="operator">&gt;</span>canReadLine() ) <span class="comment">// WRONG</span>
     ;</pre>
<p><b>See also </b><a href="qiodevice.html#readLine">readLine</a>().</p>
<!-- @@@canReadLine -->
<!-- $$$clearPendingData[overload1]$$$clearPendingData -->
<h3 class="fn"><a name="clearPendingData"></a><span class="type">void</span> Q3Socket::<span class="name">clearPendingData</span> ()</h3>
<p>Deletes the data that is waiting to be written. This is useful if you want to close the socket without waiting for all the data to be written.</p>
<p><b>See also </b><a href="q3socket.html#bytesToWrite">bytesToWrite</a>(), <a href="q3socket.html#close">close</a>(), and <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>().</p>
<!-- @@@clearPendingData -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn"><a name="close"></a><span class="type">void</span> Q3Socket::<span class="name">close</span> ()<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#close">QIODevice::close</a>().</p>
<p>Closes the socket.</p>
<p>The read buffer is cleared.</p>
<p>If the output buffer is empty, the state is set to <tt>Q3Socket::Idle</tt> and the connection is terminated immediately. If the output buffer still contains data to be written, <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <a href="q3socket.html#State-enum">Q3Socket::Closing</a> state and the rest of the data will be written. When all of the outgoing data have been written, the state is set to <a href="q3socket.html#State-enum">Q3Socket::Idle</a> and the connection is terminated. At this point, the <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>() signal is emitted.</p>
<p>If you don't want that the data of the output buffer is written, call <a href="q3socket.html#clearPendingData">clearPendingData</a>() before you call close().</p>
<p><b>See also </b><a href="q3socket.html#state">state</a>(), <a href="q3socket.html#bytesToWrite">bytesToWrite</a>(), and <a href="q3socket.html#clearPendingData">clearPendingData</a>().</p>
<!-- @@@close -->
<!-- $$$connectToHost[overload1]$$$connectToHostconstQString&Q_UINT16 -->
<h3 class="fn"><a name="connectToHost"></a><span class="type">void</span> Q3Socket::<span class="name">connectToHost</span> ( const <span class="type"><a href="qstring.html">QString</a></span> &amp; <i>host</i>, <span class="type"><a href="qtglobal-qt3.html#Q_UINT16-typedef">Q_UINT16</a></span> <i>port</i> )<tt> [virtual]</tt></h3>
<p>Attempts to make a connection to <i>host</i> on the specified <i>port</i> and return immediately.</p>
<p>Any connection or pending connection is closed immediately, and <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <tt>HostLookup</tt> state. When the lookup succeeds, it emits <a href="q3socket.html#hostFound">hostFound</a>(), starts a TCP connection and goes into the <tt>Connecting</tt> state. Finally, when the connection succeeds, it emits <a href="q3socket.html#connected">connected</a>() and goes into the <tt>Connected</tt> state. If there is an error at any point, it emits <a href="q3socket.html#error">error</a>().</p>
<p><i>host</i> may be an IP address in string form, or it may be a DNS name. <a href="q3socket.html" class="compat">Q3Socket</a> will do a normal DNS lookup if required. Note that <i>port</i> is in native byte order, unlike some other libraries.</p>
<p><b>See also </b><a href="q3socket.html#state">state</a>().</p>
<!-- @@@connectToHost -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn"><a name="connected"></a><span class="type">void</span> Q3Socket::<span class="name">connected</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted after <a href="q3socket.html#connectToHost">connectToHost</a>() has been called and a connection has been successfully established.</p>
<p><b>See also </b><a href="q3socket.html#connectToHost">connectToHost</a>() and <a href="q3socket.html#connectionClosed">connectionClosed</a>().</p>
<!-- @@@connected -->
<!-- $$$connectionClosed[overload1]$$$connectionClosed -->
<h3 class="fn"><a name="connectionClosed"></a><span class="type">void</span> Q3Socket::<span class="name">connectionClosed</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted when the other end has closed the connection. The read buffers may contain buffered input data which you can read after the connection was closed.</p>
<p><b>See also </b><a href="q3socket.html#connectToHost">connectToHost</a>() and <a href="q3socket.html#close">close</a>().</p>
<!-- @@@connectionClosed -->
<!-- $$$delayedCloseFinished[overload1]$$$delayedCloseFinished -->
<h3 class="fn"><a name="delayedCloseFinished"></a><span class="type">void</span> Q3Socket::<span class="name">delayedCloseFinished</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted when a delayed close is finished.</p>
<p>If you call <a href="q3socket.html#close">close</a>() and there is buffered output data to be written, <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <a href="q3socket.html#State-enum">Q3Socket::Closing</a> state and returns immediately. It will then keep writing to the socket until all the data has been written. Then, the delayedCloseFinished() signal is emitted.</p>
<p><b>See also </b><a href="q3socket.html#close">close</a>().</p>
<!-- @@@delayedCloseFinished -->
<!-- $$$error[overload1]$$$errorint -->
<h3 class="fn"><a name="error"></a><span class="type">void</span> Q3Socket::<span class="name">error</span> ( <span class="type">int</span> <i>error</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted after an error occurred. The <i>error</i> parameter is the <a href="q3socket.html#Error-enum">Error</a> value.</p>
<!-- @@@error -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn"><a name="flush"></a><span class="type">bool</span> Q3Socket::<span class="name">flush</span> ()</h3>
<p>Implementation of the abstract virtual QIODevice::flush() function. This function always returns true.</p>
<!-- @@@flush -->
<!-- $$$getch[overload1]$$$getch -->
<h3 class="fn"><a name="getch"></a><span class="type">int</span> Q3Socket::<span class="name">getch</span> ()</h3>
<p>Reads a single byte/character from the internal read buffer. Returns the byte/character read, or -1 if there is nothing to be read.</p>
<p><b>See also </b><a href="q3socket.html#bytesAvailable">bytesAvailable</a>() and <a href="q3socket.html#putch">putch</a>().</p>
<!-- @@@getch -->
<!-- $$$hostFound[overload1]$$$hostFound -->
<h3 class="fn"><a name="hostFound"></a><span class="type">void</span> Q3Socket::<span class="name">hostFound</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted after <a href="q3socket.html#connectToHost">connectToHost</a>() has been called and the host lookup has succeeded.</p>
<p><b>See also </b><a href="q3socket.html#connected">connected</a>().</p>
<!-- @@@hostFound -->
<!-- $$$open[overload1]$$$openOpenMode -->
<h3 class="fn"><a name="open"></a><span class="type">bool</span> Q3Socket::<span class="name">open</span> ( <span class="type"><a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a></span> <i>m</i> )<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#open">QIODevice::open</a>().</p>
<p>Opens the socket using the specified <a href="qiodevice.html">QIODevice</a> file mode <i>m</i>. This function is called automatically when needed and you should not call it yourself.</p>
<p><b>See also </b><a href="q3socket.html#close">close</a>().</p>
<!-- @@@open -->
<!-- $$$open$$$openint -->
<h3 class="fn"><a name="open-2"></a><span class="type">bool</span> Q3Socket::<span class="name">open</span> ( <span class="type">int</span> <i>m</i> )</h3>
<p>This is an overloaded function.</p>
<!-- @@@open -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn"><a name="peerAddress"></a><span class="type"><a href="qhostaddress.html">QHostAddress</a></span> Q3Socket::<span class="name">peerAddress</span> () const</h3>
<p>Returns the address of the connected peer if the socket is in Connected state; otherwise an empty <a href="qhostaddress.html">QHostAddress</a> is returned.</p>
<!-- @@@peerAddress -->
<!-- $$$peerName[overload1]$$$peerName -->
<h3 class="fn"><a name="peerName"></a><span class="type"><a href="qstring.html">QString</a></span> Q3Socket::<span class="name">peerName</span> () const</h3>
<p>Returns the host name as specified to the <a href="q3socket.html#connectToHost">connectToHost</a>() function. An empty string is returned if none has been set.</p>
<!-- @@@peerName -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn"><a name="peerPort"></a><span class="type"><a href="qtglobal-qt3.html#Q_UINT16-typedef">Q_UINT16</a></span> Q3Socket::<span class="name">peerPort</span> () const</h3>
<p>Returns the peer's host port number, normally as specified to the <a href="q3socket.html#connectToHost">connectToHost</a>() function. If none has been set, this function returns 0.</p>
<p>Note that Qt always uses native byte order, i.e&#x2e; 67 is 67 in Qt; there is no need to call htons().</p>
<!-- @@@peerPort -->
<!-- $$$port[overload1]$$$port -->
<h3 class="fn"><a name="port"></a><span class="type"><a href="qtglobal-qt3.html#Q_UINT16-typedef">Q_UINT16</a></span> Q3Socket::<span class="name">port</span> () const</h3>
<p>Returns the host port number of this socket, in native byte order.</p>
<!-- @@@port -->
<!-- $$$putch[overload1]$$$putchint -->
<h3 class="fn"><a name="putch"></a><span class="type">int</span> Q3Socket::<span class="name">putch</span> ( <span class="type">int</span> <i>ch</i> )</h3>
<p>Writes the character <i>ch</i> to the output buffer.</p>
<p>Returns <i>ch</i>, or -1 if an error occurred.</p>
<p><b>See also </b><a href="q3socket.html#getch">getch</a>().</p>
<!-- @@@putch -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn"><a name="readBufferSize"></a><span class="type"><a href="qtglobal-qt3.html#Q_ULONG-typedef">Q_ULONG</a></span> Q3Socket::<span class="name">readBufferSize</span> () const</h3>
<p>Returns the size of the read buffer.</p>
<p><b>See also </b><a href="q3socket.html#setReadBufferSize">setReadBufferSize</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn"><a name="readData"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> Q3Socket::<span class="name">readData</span> ( <span class="type">char</span> * <i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxlen</i> )<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#readData">QIODevice::readData</a>().</p>
<p>Reads <i>maxlen</i> bytes from the socket into <i>data</i> and returns the number of bytes read. Returns -1 if an error occurred.</p>
<!-- @@@readData -->
<!-- $$$readyRead[overload1]$$$readyRead -->
<h3 class="fn"><a name="readyRead"></a><span class="type">void</span> Q3Socket::<span class="name">readyRead</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted every time there is new incoming data.</p>
<p>Bear in mind that new incoming data is only reported once; if you do not read all the data, this class buffers the data and you can read it later, but no signal is emitted unless new data arrives. A good practice is to read all data in the slot connected to this signal unless you are sure that you need to receive more data to be able to process it.</p>
<p><b>See also </b><a href="qiodevice-qt3.html#readBlock" class="compat">readBlock</a>(), <a href="qiodevice.html#readLine">readLine</a>(), and <a href="q3socket.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@readyRead -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeQ_ULONG -->
<h3 class="fn"><a name="setReadBufferSize"></a><span class="type">void</span> Q3Socket::<span class="name">setReadBufferSize</span> ( <span class="type"><a href="qtglobal-qt3.html#Q_ULONG-typedef">Q_ULONG</a></span> <i>bufSize</i> )</h3>
<p>Sets the size of the <a href="q3socket.html" class="compat">Q3Socket</a>'s internal read buffer to <i>bufSize</i>.</p>
<p>Usually <a href="q3socket.html" class="compat">Q3Socket</a> reads all data that is available from the operating system's socket. If the buffer size is limited to a certain size, this means that the <a href="q3socket.html" class="compat">Q3Socket</a> class doesn't buffer more than this size of data.</p>
<p>If the size of the read buffer is 0, the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>If you read the data in the <a href="q3socket.html#readyRead">readyRead</a>() signal, you shouldn't use this option since it might slow down your program unnecessary. This option is useful if you only need to read the data at certain points in time, like in a realtime streaming application.</p>
<p><b>See also </b><a href="q3socket.html#readBufferSize">readBufferSize</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setSocket[overload1]$$$setSocketint -->
<h3 class="fn"><a name="setSocket"></a><span class="type">void</span> Q3Socket::<span class="name">setSocket</span> ( <span class="type">int</span> <i>socket</i> )<tt> [virtual]</tt></h3>
<p>Sets the socket to use <i>socket</i> and the <a href="q3socket.html#state">state</a>() to <tt>Connected</tt>. The socket must already be connected.</p>
<p>This allows us to use the <a href="q3socket.html" class="compat">Q3Socket</a> class as a wrapper for other socket types (e.g&#x2e; Unix Domain Sockets).</p>
<p><b>See also </b><a href="q3socket.html#socket">socket</a>().</p>
<!-- @@@setSocket -->
<!-- $$$setSocketDevice[overload1]$$$setSocketDeviceQ3SocketDevice* -->
<h3 class="fn"><a name="setSocketDevice"></a><span class="type">void</span> Q3Socket::<span class="name">setSocketDevice</span> ( <span class="type"><a href="q3socketdevice.html">Q3SocketDevice</a></span> * <i>device</i> )<tt> [virtual]</tt></h3>
<p>Sets the internal socket device to <i>device</i>. Passing a <i>device</i> of 0 will cause the internal socket device to be used. Any existing connection will be disconnected before using the new <i>device</i>.</p>
<p>The new device should not be connected before being associated with a <a href="q3socket.html" class="compat">Q3Socket</a>; after setting the socket call <a href="q3socket.html#connectToHost">connectToHost</a>() to make the connection.</p>
<p>This function is useful if you need to subclass <a href="q3socketdevice.html" class="compat">Q3SocketDevice</a> and want to use the <a href="q3socket.html" class="compat">Q3Socket</a> API, for example, to implement Unix domain sockets.</p>
<p><b>See also </b><a href="q3socket.html#socketDevice">socketDevice</a>().</p>
<!-- @@@setSocketDevice -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a><span class="type"><a href="qiodevice-qt3.html#Offset-typedef">Offset</a></span> Q3Socket::<span class="name">size</span> () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#size">QIODevice::size</a>().</p>
<p>Returns the number of incoming bytes that can be read right now (like <a href="q3socket.html#bytesAvailable">bytesAvailable</a>()).</p>
<!-- @@@size -->
<!-- $$$socket[overload1]$$$socket -->
<h3 class="fn"><a name="socket"></a><span class="type">int</span> Q3Socket::<span class="name">socket</span> () const</h3>
<p>Returns the socket number, or -1 if there is no socket at the moment.</p>
<p><b>See also </b><a href="q3socket.html#setSocket">setSocket</a>().</p>
<!-- @@@socket -->
<!-- $$$socketDevice[overload1]$$$socketDevice -->
<h3 class="fn"><a name="socketDevice"></a><span class="type"><a href="q3socketdevice.html">Q3SocketDevice</a></span> * Q3Socket::<span class="name">socketDevice</span> ()</h3>
<p>Returns a pointer to the internal socket device.</p>
<p>There is normally no need to manipulate the socket device directly since this class does the necessary setup for most applications.</p>
<p><b>See also </b><a href="q3socket.html#setSocketDevice">setSocketDevice</a>().</p>
<!-- @@@socketDevice -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn"><a name="state"></a><span class="type"><a href="q3socket.html#State-enum">State</a></span> Q3Socket::<span class="name">state</span> () const</h3>
<p>Returns the current state of the socket connection.</p>
<p><b>See also </b><a href="q3socket.html#State-enum">Q3Socket::State</a>.</p>
<!-- @@@state -->
<!-- $$$ungetch[overload1]$$$ungetchint -->
<h3 class="fn"><a name="ungetch"></a><span class="type">int</span> Q3Socket::<span class="name">ungetch</span> ( <span class="type">int</span> <i>ch</i> )</h3>
<p>This implementation of the virtual function <a href="qiodevice-qt3.html#ungetch" class="compat">QIODevice::ungetch</a>() prepends the character <i>ch</i> to the read buffer so that the next read returns this character as the first character of the output.</p>
<!-- @@@ungetch -->
<!-- $$$waitForMore[overload1]$$$waitForMoreintbool* -->
<h3 class="fn"><a name="waitForMore"></a><span class="type"><a href="qtglobal-qt3.html#Q_ULONG-typedef">Q_ULONG</a></span> Q3Socket::<span class="name">waitForMore</span> ( <span class="type">int</span> <i>msecs</i>, <span class="type">bool</span> * <i>timeout</i> ) const</h3>
<p>Wait up to <i>msecs</i> milliseconds for more data to be available.</p>
<p>If <i>msecs</i> is -1 the call will block indefinitely.</p>
<p>Returns the number of bytes available.</p>
<p>If <i>timeout</i> is non-null and no error occurred (i.e&#x2e; it does not return -1): this function sets *<i>timeout</i> to true, if the reason for returning was that the timeout was reached; otherwise it sets *<i>timeout</i> to false. This is useful to find out if the peer closed the connection.</p>
<p><b>Warning:</b> This is a blocking call and should be avoided in event driven applications.</p>
<p><b>See also </b><a href="q3socket.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@waitForMore -->
<!-- $$$waitForMore$$$waitForMoreint -->
<h3 class="fn"><a name="waitForMore-2"></a><span class="type"><a href="qtglobal-qt3.html#Q_ULONG-typedef">Q_ULONG</a></span> Q3Socket::<span class="name">waitForMore</span> ( <span class="type">int</span> <i>msecs</i> ) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@waitForMore -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn"><a name="writeData"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> Q3Socket::<span class="name">writeData</span> ( const <span class="type">char</span> * <i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>len</i> )<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#writeData">QIODevice::writeData</a>().</p>
<p>Writes <i>len</i> bytes to the socket from <i>data</i> and returns the number of bytes written. Returns -1 if an error occurred.</p>
<!-- @@@writeData -->
</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
