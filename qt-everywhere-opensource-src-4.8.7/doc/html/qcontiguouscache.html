<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qcontiguouscache.cpp -->
  <title>Qt 4.8: QContiguousCache Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtcore.html">QtCore</a></li>
<li>QContiguousCache</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QContiguousCache Class Reference</h1>
<!-- $$$QContiguousCache-brief -->
<p>The QContiguousCache class is a template class that provides a contiguous cache. <a href="#details">More...</a></p>
<!-- @@@QContiguousCache -->
<pre class="cpp"> <span class="preprocessor">#include &lt;QContiguousCache&gt;</span></pre><p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html#reentrant">reentrant</a>.</p>
<p>This class was introduced in Qt 4.6.</p>
<ul>
<li><a href="qcontiguouscache-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#QContiguousCache">QContiguousCache</a></b> ( int <i>capacity</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#QContiguousCache-2">QContiguousCache</a></b> ( const QContiguousCache&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#dtor.QContiguousCache">~QContiguousCache</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#append">append</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#areIndexesValid">areIndexesValid</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#at">at</a></b> ( int <i>i</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#available">available</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#capacity">capacity</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#containsIndex">containsIndex</a></b> ( int <i>i</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#count">count</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#first">first</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#first-2">first</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#firstIndex">firstIndex</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#insert">insert</a></b> ( int <i>i</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#isEmpty">isEmpty</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#isFull">isFull</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#last">last</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#last-2">last</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#lastIndex">lastIndex</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#normalizeIndexes">normalizeIndexes</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#prepend">prepend</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#removeFirst">removeFirst</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#removeLast">removeLast</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#setCapacity">setCapacity</a></b> ( int <i>size</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#swap">swap</a></b> ( QContiguousCache&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#takeFirst">takeFirst</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#takeLast">takeLast</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-not-eq">operator!=</a></b> ( const QContiguousCache&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QContiguousCache&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-eq">operator=</a></b> ( const QContiguousCache&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-eq-eq">operator==</a></b> ( const QContiguousCache&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-5b-5d">operator[]</a></b> ( int <i>i</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-5b-5d-2">operator[]</a></b> ( int <i>i</i> ) const</td></tr>
</table>
<a name="details"></a>
<!-- $$$QContiguousCache-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QContiguousCache class is a template class that provides a contiguous cache.</p>
<p>The QContiguousCache class provides an efficient way of caching items for display in a user interface view. Unlike <a href="qcache.html">QCache</a>, it adds a restriction that elements within the cache are contiguous. This has the advantage of matching how user interface views most commonly request data, as a set of rows localized around the current scrolled position. This restriction allows the cache to consume less memory and processor cycles than <a href="qcache.html">QCache</a>. The QContiguousCache class also can provide an upper bound on memory usage via <a href="qcontiguouscache.html#setCapacity">setCapacity</a>().</p>
<p>The simplest way of using a contiguous cache is to use the <a href="qcontiguouscache.html#append">append</a>() and <a href="qcontiguouscache.html#prepend">prepend</a>().</p>
<pre class="cpp"> MyRecord record(<span class="type">int</span> row) <span class="keyword">const</span>
 {
     Q_ASSERT(row <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> row <span class="operator">&lt;</span> count());

     <span class="keyword">while</span>(row <span class="operator">&gt;</span> cache<span class="operator">.</span>lastIndex())
         cache<span class="operator">.</span>append(slowFetchRecord(cache<span class="operator">.</span>lastIndex()<span class="operator">+</span><span class="number">1</span>));
     <span class="keyword">while</span>(row <span class="operator">&lt;</span> cache<span class="operator">.</span>firstIndex())
         cache<span class="operator">.</span>prepend(slowFetchRecord(cache<span class="operator">.</span>firstIndex()<span class="operator">-</span><span class="number">1</span>));

     <span class="keyword">return</span> cache<span class="operator">.</span>at(row);
 }</pre>
<p>If the cache is full then the item at the opposite end of the cache from where the new item is appended or prepended will be removed.</p>
<p>This usage can be further optimized by using the <a href="qcontiguouscache.html#insert">insert</a>() function in the case where the requested row is a long way from the currently cached items. If there is a gap between where the new item is inserted and the currently cached items then the existing cached items are first removed to retain the contiguous nature of the cache. Hence it is important to take some care then when using <a href="qcontiguouscache.html#insert">insert</a>() in order to avoid unwanted clearing of the cache.</p>
<p>The range of valid indexes for the QContiguousCache class are from 0 to INT_MAX. Calling <a href="qcontiguouscache.html#prepend">prepend</a>() such that the first index would become less than 0 or <a href="qcontiguouscache.html#append">append</a>() such that the last index would become greater than INT_MAX can result in the indexes of the cache being invalid. When the cache indexes are invalid it is important to call <a href="qcontiguouscache.html#normalizeIndexes">normalizeIndexes</a>() before calling any of <a href="qcontiguouscache.html#containsIndex">containsIndex</a>(), <a href="qcontiguouscache.html#firstIndex">firstIndex</a>(), <a href="qcontiguouscache.html#lastIndex">lastIndex</a>(), <a href="qcontiguouscache.html#at">at</a>() or <a href="qcontiguouscache.html#operator-5b-5d">operator[]</a>(). Calling these functions when the cache has invalid indexes will result in undefined behavior. The indexes can be checked by using <a href="qcontiguouscache.html#areIndexesValid">areIndexesValid</a>()</p>
<p>In most cases the indexes will not exceed 0 to INT_MAX, and <a href="qcontiguouscache.html#normalizeIndexes">normalizeIndexes</a>() will not need to be used.</p>
<p>See the <a href="tools-contiguouscache.html">Contiguous Cache</a> example.</p>
</div>
<!-- @@@QContiguousCache -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QContiguousCache[overload1]$$$QContiguousCacheint -->
<h3 class="fn"><a name="QContiguousCache"></a>QContiguousCache::<span class="name">QContiguousCache</span> ( <span class="type">int</span> <i>capacity</i> = 0 )</h3>
<p>Constructs a cache with the given <i>capacity</i>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#setCapacity">setCapacity</a>().</p>
<!-- @@@QContiguousCache -->
<!-- $$$QContiguousCache$$$QContiguousCacheconstQContiguousCache<T>& -->
<h3 class="fn"><a name="QContiguousCache-2"></a>QContiguousCache::<span class="name">QContiguousCache</span> ( const <span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time">constant time</a>, because <a href="qcontiguouscache.html">QContiguousCache</a> is <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>. This makes returning a <a href="qcontiguouscache.html">QContiguousCache</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#linear-time">linear time</a>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-eq">operator=</a>().</p>
<!-- @@@QContiguousCache -->
<!-- $$$~QContiguousCache[overload1]$$$~QContiguousCache -->
<h3 class="fn"><a name="dtor.QContiguousCache"></a>QContiguousCache::<span class="name">~QContiguousCache</span> ()</h3>
<p>Destroys the cache.</p>
<!-- @@@~QContiguousCache -->
<!-- $$$append[overload1]$$$appendconstT& -->
<h3 class="fn"><a name="append"></a><span class="type">void</span> QContiguousCache::<span class="name">append</span> ( const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Inserts <i>value</i> at the end of the cache. If the cache is already full the item at the start of the cache will be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#prepend">prepend</a>(), <a href="qcontiguouscache.html#insert">insert</a>(), and <a href="qcontiguouscache.html#isFull">isFull</a>().</p>
<!-- @@@append -->
<!-- $$$areIndexesValid[overload1]$$$areIndexesValid -->
<h3 class="fn"><a name="areIndexesValid"></a><span class="type">bool</span> QContiguousCache::<span class="name">areIndexesValid</span> () const</h3>
<p>Returns whether the indexes for items stored in the cache are valid. Indexes can become invalid if items are appended after the index position INT_MAX or prepended before the index position 0. This is only expected to occur in very long lived circular buffer style usage of the contiguous cache. Indexes can be made valid again by calling normalizeIndexs().</p>
<p><b>See also </b><a href="qcontiguouscache.html#normalizeIndexes">normalizeIndexes</a>(), <a href="qcontiguouscache.html#append">append</a>(), and <a href="qcontiguouscache.html#prepend">prepend</a>().</p>
<!-- @@@areIndexesValid -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn"><a name="at"></a>const <span class="type">T</span> &amp; QContiguousCache::<span class="name">at</span> ( <span class="type">int</span> <i>i</i> ) const</h3>
<p>Returns the item at index position <i>i</i> in the cache. <i>i</i> must be a valid index position in the cache (i.e, <a href="qcontiguouscache.html#firstIndex">firstIndex</a>() &lt;= <i>i</i> &lt;= <a href="qcontiguouscache.html#lastIndex">lastIndex</a>()).</p>
<p>The indexes in the cache refer to the number of positions the item is from the first item appended into the cache. That is to say a cache with a capacity of 100, that has had 150 items appended will have a valid index range of 50 to 149. This allows inserting and retrieving items into the cache based on a theoretical infinite list</p>
<p><b>See also </b><a href="qcontiguouscache.html#firstIndex">firstIndex</a>(), <a href="qcontiguouscache.html#lastIndex">lastIndex</a>(), <a href="qcontiguouscache.html#insert">insert</a>(), and <a href="qcontiguouscache.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$available[overload1]$$$available -->
<h3 class="fn"><a name="available"></a><span class="type">int</span> QContiguousCache::<span class="name">available</span> () const</h3>
<p>Returns the number of items that can be added to the cache before it becomes full.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size">size</a>(), <a href="qcontiguouscache.html#capacity">capacity</a>(), and <a href="qcontiguouscache.html#isFull">isFull</a>().</p>
<!-- @@@available -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn"><a name="capacity"></a><span class="type">int</span> QContiguousCache::<span class="name">capacity</span> () const</h3>
<p>Returns the number of items the cache can store before it is full. When a cache contains a number of items equal to its capacity, adding new items will cause items farthest from the added item to be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#setCapacity">setCapacity</a>() and <a href="qcontiguouscache.html#size">size</a>().</p>
<!-- @@@capacity -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn"><a name="clear"></a><span class="type">void</span> QContiguousCache::<span class="name">clear</span> ()</h3>
<p>Removes all items from the cache. The capacity is unchanged.</p>
<!-- @@@clear -->
<!-- $$$containsIndex[overload1]$$$containsIndexint -->
<h3 class="fn"><a name="containsIndex"></a><span class="type">bool</span> QContiguousCache::<span class="name">containsIndex</span> ( <span class="type">int</span> <i>i</i> ) const</h3>
<p>Returns true if the cache's index range includes the given index <i>i</i>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#firstIndex">firstIndex</a>() and <a href="qcontiguouscache.html#lastIndex">lastIndex</a>().</p>
<!-- @@@containsIndex -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn"><a name="count"></a><span class="type">int</span> QContiguousCache::<span class="name">count</span> () const</h3>
<p>Same as <a href="qcontiguouscache.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn"><a name="first"></a><span class="type">T</span> &amp; QContiguousCache::<span class="name">first</span> ()</h3>
<p>Returns a reference to the first item in the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#last">last</a>() and <a href="qcontiguouscache.html#isEmpty">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn"><a name="first-2"></a>const <span class="type">T</span> &amp; QContiguousCache::<span class="name">first</span> () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$firstIndex[overload1]$$$firstIndex -->
<h3 class="fn"><a name="firstIndex"></a><span class="type">int</span> QContiguousCache::<span class="name">firstIndex</span> () const</h3>
<p>Returns the first valid index in the cache. The index will be invalid if the cache is empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity">capacity</a>(), <a href="qcontiguouscache.html#size">size</a>(), and <a href="qcontiguouscache.html#lastIndex">lastIndex</a>().</p>
<!-- @@@firstIndex -->
<!-- $$$insert[overload1]$$$insertintconstT& -->
<h3 class="fn"><a name="insert"></a><span class="type">void</span> QContiguousCache::<span class="name">insert</span> ( <span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Inserts the <i>value</i> at the index position <i>i</i>. If the cache already contains an item at <i>i</i> then that value is replaced. If <i>i</i> is either one more than <a href="qcontiguouscache.html#lastIndex">lastIndex</a>() or one less than <a href="qcontiguouscache.html#firstIndex">firstIndex</a>() it is the equivalent to an <a href="qcontiguouscache.html#append">append</a>() or a <a href="qcontiguouscache.html#prepend">prepend</a>().</p>
<p>If the given index <i>i</i> is not within the current range of the cache nor adjacent to the bounds of the cache's index range, the cache is first cleared before inserting the item. At this point the cache will have a size of 1. It is worthwhile taking effort to insert items in an order that starts adjacent to the current index range for the cache.</p>
<p>The range of valid indexes for the <a href="qcontiguouscache.html">QContiguousCache</a> class are from 0 to INT_MAX. Inserting outside of this range has undefined behavior.</p>
<p><b>See also </b><a href="qcontiguouscache.html#prepend">prepend</a>(), <a href="qcontiguouscache.html#append">append</a>(), <a href="qcontiguouscache.html#isFull">isFull</a>(), <a href="qcontiguouscache.html#firstIndex">firstIndex</a>(), and <a href="qcontiguouscache.html#lastIndex">lastIndex</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn"><a name="isEmpty"></a><span class="type">bool</span> QContiguousCache::<span class="name">isEmpty</span> () const</h3>
<p>Returns true if no items are stored within the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size">size</a>() and <a href="qcontiguouscache.html#capacity">capacity</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isFull[overload1]$$$isFull -->
<h3 class="fn"><a name="isFull"></a><span class="type">bool</span> QContiguousCache::<span class="name">isFull</span> () const</h3>
<p>Returns true if the number of items stored within the cache is equal to the capacity of the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size">size</a>() and <a href="qcontiguouscache.html#capacity">capacity</a>().</p>
<!-- @@@isFull -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn"><a name="last"></a><span class="type">T</span> &amp; QContiguousCache::<span class="name">last</span> ()</h3>
<p>Returns a reference to the last item in the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#first">first</a>() and <a href="qcontiguouscache.html#isEmpty">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn"><a name="last-2"></a>const <span class="type">T</span> &amp; QContiguousCache::<span class="name">last</span> () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastIndex[overload1]$$$lastIndex -->
<h3 class="fn"><a name="lastIndex"></a><span class="type">int</span> QContiguousCache::<span class="name">lastIndex</span> () const</h3>
<p>Returns the last valid index in the cache. The index will be invalid if the cache is empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity">capacity</a>(), <a href="qcontiguouscache.html#size">size</a>(), and <a href="qcontiguouscache.html#firstIndex">firstIndex</a>().</p>
<!-- @@@lastIndex -->
<!-- $$$normalizeIndexes[overload1]$$$normalizeIndexes -->
<h3 class="fn"><a name="normalizeIndexes"></a><span class="type">void</span> QContiguousCache::<span class="name">normalizeIndexes</span> ()</h3>
<p>Moves the first index and last index of the cache such that they point to valid indexes. The function does not modify the contents of the cache or the ordering of elements within the cache.</p>
<p>It is provided so that index overflows can be corrected when using the cache as a circular buffer.</p>
<pre class="cpp"> <span class="type"><a href="qcontiguouscache.html">QContiguousCache</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> cache(<span class="number">10</span>);
 cache<span class="operator">.</span><a href="qcontiguouscache.html#insert">insert</a>(INT_MAX<span class="operator">,</span> <span class="number">1</span>); <span class="comment">// cache contains one value and has valid indexes, INT_MAX to INT_MAX</span>
 cache<span class="operator">.</span><a href="qcontiguouscache.html#append">append</a>(<span class="number">2</span>); <span class="comment">// cache contains two values but does not have valid indexes.</span>
 cache<span class="operator">.</span>normalizeIndexes(); <span class="comment">// cache has two values, 1 and 2.  New first index will be in the range of 0 to capacity().</span></pre>
<p><b>See also </b><a href="qcontiguouscache.html#areIndexesValid">areIndexesValid</a>(), <a href="qcontiguouscache.html#append">append</a>(), and <a href="qcontiguouscache.html#prepend">prepend</a>().</p>
<!-- @@@normalizeIndexes -->
<!-- $$$prepend[overload1]$$$prependconstT& -->
<h3 class="fn"><a name="prepend"></a><span class="type">void</span> QContiguousCache::<span class="name">prepend</span> ( const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Inserts <i>value</i> at the start of the cache. If the cache is already full the item at the end of the cache will be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#append">append</a>(), <a href="qcontiguouscache.html#insert">insert</a>(), and <a href="qcontiguouscache.html#isFull">isFull</a>().</p>
<!-- @@@prepend -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn"><a name="removeFirst"></a><span class="type">void</span> QContiguousCache::<span class="name">removeFirst</span> ()</h3>
<p>Removes the first item from the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#removeLast">removeLast</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn"><a name="removeLast"></a><span class="type">void</span> QContiguousCache::<span class="name">removeLast</span> ()</h3>
<p>Removes the last item from the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#removeFirst">removeFirst</a>().</p>
<!-- @@@removeLast -->
<!-- $$$setCapacity[overload1]$$$setCapacityint -->
<h3 class="fn"><a name="setCapacity"></a><span class="type">void</span> QContiguousCache::<span class="name">setCapacity</span> ( <span class="type">int</span> <i>size</i> )</h3>
<p>Sets the capacity of the cache to the given <i>size</i>. A cache can hold a number of items equal to its capacity. When inserting, appending or prepending items to the cache, if the cache is already full then the item farthest from the added item will be removed.</p>
<p>If the given <i>size</i> is smaller than the current count of items in the cache then only the last <i>size</i> items from the cache will remain.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity">capacity</a>() and <a href="qcontiguouscache.html#isFull">isFull</a>().</p>
<!-- @@@setCapacity -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a><span class="type">int</span> QContiguousCache::<span class="name">size</span> () const</h3>
<p>Returns the number of items contained within the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity">capacity</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQContiguousCache<T>& -->
<h3 class="fn"><a name="swap"></a><span class="type">void</span> QContiguousCache::<span class="name">swap</span> ( <span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; <i>other</i> )</h3>
<p>Swaps cache <i>other</i> with this cache. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@swap -->
<!-- $$$takeFirst[overload1]$$$takeFirst -->
<h3 class="fn"><a name="takeFirst"></a><span class="type">T</span> QContiguousCache::<span class="name">takeFirst</span> ()</h3>
<p>Removes the first item in the cache and returns it. This function assumes that the cache isn't empty.</p>
<p>If you don't use the return value, <a href="qcontiguouscache.html#removeFirst">removeFirst</a>() is more efficient.</p>
<p><b>See also </b><a href="qcontiguouscache.html#takeLast">takeLast</a>() and <a href="qcontiguouscache.html#removeFirst">removeFirst</a>().</p>
<!-- @@@takeFirst -->
<!-- $$$takeLast[overload1]$$$takeLast -->
<h3 class="fn"><a name="takeLast"></a><span class="type">T</span> QContiguousCache::<span class="name">takeLast</span> ()</h3>
<p>Removes the last item in the cache and returns it. This function assumes that the cache isn't empty.</p>
<p>If you don't use the return value, <a href="qcontiguouscache.html#removeLast">removeLast</a>() is more efficient.</p>
<p><b>See also </b><a href="qcontiguouscache.html#takeFirst">takeFirst</a>() and <a href="qcontiguouscache.html#removeLast">removeLast</a>().</p>
<!-- @@@takeLast -->
<!-- $$$operator!=[overload1]$$$operator!=constQContiguousCache<T>& -->
<h3 class="fn"><a name="operator-not-eq"></a><span class="type">bool</span> QContiguousCache::<span class="name">operator!=</span> ( const <span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is not equal to this cache; otherwise returns false.</p>
<p>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the <tt>operator==()</tt>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-eq-eq">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator=[overload1]$$$operator=constQContiguousCache<T>& -->
<h3 class="fn"><a name="operator-eq"></a><span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; QContiguousCache::<span class="name">operator=</span> ( const <span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; <i>other</i> )</h3>
<p>Assigns <i>other</i> to this cache and returns a reference to this cache.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQContiguousCache<T>& -->
<h3 class="fn"><a name="operator-eq-eq"></a><span class="type">bool</span> QContiguousCache::<span class="name">operator==</span> ( const <span class="type">QContiguousCache</span>&lt;<span class="type">T</span>&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is equal to this cache; otherwise returns false.</p>
<p>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the <tt>operator==()</tt>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-not-eq">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn"><a name="operator-5b-5d"></a><span class="type">T</span> &amp; QContiguousCache::<span class="name">operator[]</span> ( <span class="type">int</span> <i>i</i> )</h3>
<p>Returns the item at index position <i>i</i> as a modifiable reference. If the cache does not contain an item at the given index position <i>i</i> then it will first insert an empty item at that position.</p>
<p>In most cases it is better to use either <a href="qcontiguouscache.html#at">at</a>() or <a href="qcontiguouscache.html#insert">insert</a>().</p>
<p><b>Note:</b> This non-const overload of operator[] requires <a href="qcontiguouscache.html">QContiguousCache</a> to make a deep copy. Use <a href="qcontiguouscache.html#at">at</a>() for read-only access to a non-const <a href="qcontiguouscache.html">QContiguousCache</a>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#insert">insert</a>() and <a href="qcontiguouscache.html#at">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn"><a name="operator-5b-5d-2"></a>const <span class="type">T</span> &amp; QContiguousCache::<span class="name">operator[]</span> ( <span class="type">int</span> <i>i</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i>i</i>).</p>
<!-- @@@operator[] -->
</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
