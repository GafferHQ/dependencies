<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qimage.cpp -->
  <title>Qt 4.8: Qt 3 Support Members for QImage</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtgui.html">QtGui</a></li>
<li>QImage</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<h1 class="title">Qt 3 Support Members for QImage</h1>
<p><b>The following class members are part of the <a href="qt3support.html">Qt 3 support layer</a>.</b> They are provided to help you port old code to Qt 4. We advise against using them in new code.</p>
<p><ul><li><a href="qimage.html">QImage class reference</a></li></ul></p>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#Endian-enum">Endian</a></b> { IgnoreEndian, BigEndian, LittleEndian }</td></tr>
</table>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-12">QImage</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-13">QImage</a></b> ( const QSize &amp; <i>size</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-14">QImage</a></b> ( uchar * <i>data</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, const QRgb * <i>colortable</i>, int <i>numColors</i>, Endian <i>bitOrder</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-15">QImage</a></b> ( uchar * <i>data</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>bytesPerLine</i>, const QRgb * <i>colortable</i>, int <i>numColors</i>, Endian <i>bitOrder</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-16">QImage</a></b> ( const QByteArray &amp; <i>data</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#bitOrder">bitOrder</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertBitOrder">convertBitOrder</a></b> ( Endian <i>bitOrder</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertDepth">convertDepth</a></b> ( int <i>depth</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertDepthWithPalette">convertDepthWithPalette</a></b> ( int <i>depth</i>, QRgb * <i>palette</i>, int <i>palette_count</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#copy-2">copy</a></b> ( int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>, Qt::ImageConversionFlags <i>flags</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#copy-3">copy</a></b> ( const QRect &amp; <i>rect</i>, Qt::ImageConversionFlags <i>flags</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#create">create</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#create-2">create</a></b> ( const QSize &amp; <i>size</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#hasAlphaBuffer">hasAlphaBuffer</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#invertPixels-2">invertPixels</a></b> ( bool <i>invertAlpha</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> uchar ** </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#jumpTable">jumpTable</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> const uchar * const * </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#jumpTable-2">jumpTable</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#mirror">mirror</a></b> ( bool <i>horizontal</i> = false, bool <i>vertical</i> = true ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#numBytes">numBytes</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#numColors">numColors</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#reset">reset</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#scaleHeight">scaleHeight</a></b> ( int <i>h</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#scaleWidth">scaleWidth</a></b> ( int <i>w</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#setAlphaBuffer">setAlphaBuffer</a></b> ( bool <i>enable</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#setNumColors">setNumColors</a></b> ( int <i>numColors</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#setText-2">setText</a></b> ( const char * <i>key</i>, const char * <i>language</i>, const QString &amp; <i>text</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#smoothScale">smoothScale</a></b> ( int <i>width</i>, int <i>height</i>, Qt::AspectRatioMode <i>mode</i> = Qt::IgnoreAspectRatio ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#smoothScale-2">smoothScale</a></b> ( const QSize &amp; <i>size</i>, Qt::AspectRatioMode <i>mode</i> = Qt::IgnoreAspectRatio ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#swapRGB">swapRGB</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#text-2">text</a></b> ( const char * <i>key</i>, const char * <i>language</i> = 0 ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#text-3">text</a></b> ( const QImageTextKeyLang &amp; <i>keywordAndLanguage</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#textLanguages">textLanguages</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QList&lt;QImageTextKeyLang&gt; </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#textList">textList</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#xForm">xForm</a></b> ( const QMatrix &amp; <i>matrix</i> ) const</td></tr>
</table>
<ul>
<li class="fn">8 public functions inherited from <a href="qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#systemBitOrder">systemBitOrder</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#systemByteOrder">systemByteOrder</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">13 static public members inherited from <a href="qpaintdevice.html#static-public-members">QPaintDevice</a></li>
</ul>
<h2>Related Non-Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#bitBlt-4">bitBlt</a></b> ( QImage * <i>dst</i>, int <i>dx</i>, int <i>dy</i>, const QImage * <i>src</i>, int <i>sx</i> = 0, int <i>sy</i> = 0, int <i>sw</i> = -1, int <i>sh</i> = -1, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor )</td></tr>
</table>
<h2>Member Type Documentation</h2>
<!-- $$$Endian$$$BigEndian$$$LittleEndian$$$IgnoreEndian -->
<h3 class="fn"><a name="Endian-enum"></a>enum QImage::<span class="name">Endian</span></h3>
<p>This enum type is used to describe the endianness of the CPU and graphics hardware. It is provided here for compatibility with earlier versions of Qt.</p>
<p>Use the <a href="qimage.html#Format-enum">Format</a> enum instead. The <a href="qimage.html#Format-enum">Format</a> enum specify the endianess for monchrome formats, but for other formats the endianess is not relevant.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QImage::IgnoreEndian</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">Endianness does not matter. Useful for some operations that are independent of endianness.</td></tr>
<tr><td class="topAlign"><tt>QImage::BigEndian</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">Most significant bit first or network byte order, as on SPARC, PowerPC, and Motorola CPUs.</td></tr>
<tr><td class="topAlign"><tt>QImage::LittleEndian</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">Least significant bit first or little endian byte order, as on Intel x86.</td></tr>
</table>
<!-- @@@Endian -->
<h2>Member Function Documentation</h2>
<!-- $$$QImage$$$QImageintintintintEndian -->
<h3 class="fn"><a name="QImage-12"></a>QImage::<span class="name">QImage</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, <i>depth</i>, <i>numColors</i> colors and <i>bitOrder</i>.</p>
<p>Use the constructor that accepts a width, a height and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorCount">setColorCount</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image(width, height, depth, numColors);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image(width<span class="operator">,</span> height<span class="operator">,</span> format);

 <span class="comment">// For 8 bit images the default number of colors is 256. If</span>
 <span class="comment">// another number of colors is required it can be specified</span>
 <span class="comment">// using the setColorCount() function.</span>
 image<span class="operator">.</span><a href="qimage.html#setColorCount">setColorCount</a>(numColors);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageconstQSize&intintEndian -->
<h3 class="fn"><a name="QImage-13"></a>QImage::<span class="name">QImage</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Constructs an image with the given <i>size</i>, <i>depth</i>, <i>numColors</i> and <i>bitOrder</i>.</p>
<p>Use the constructor that accepts a size and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorCount">setColorCount</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QSize mySize(width, height);
 QImage image(mySize, depth, numColors);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qsize.html">QSize</a></span> mySize(width<span class="operator">,</span> height);
 <span class="type"><a href="qimage.html">QImage</a></span> image(mySize<span class="operator">,</span> format);

 <span class="comment">// For 8 bit images the default number of colors is 256. If</span>
 <span class="comment">// another number of colors is required it can be specified</span>
 <span class="comment">// using the setColorCount() function.</span>
 image<span class="operator">.</span><a href="qimage.html#setColorCount">setColorCount</a>(numColors);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageuchar*intintintconstQRgb*intEndian -->
<h3 class="fn"><a name="QImage-14"></a>QImage::<span class="name">QImage</span> ( <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * <i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, const <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>colortable</i>, <span class="type">int</span> <i>numColors</i>, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, depth, <i>colortable</i>, <i>numColors</i> and <i>bitOrder</i>, that uses an existing memory buffer, <i>data</i>.</p>
<p>Use the constructor that accepts a uchar pointer, a width, a height and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorTable">setColorTable</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> uchar *myData;
 QRgb *myColorTable;

 QImage image(myData, width, height, depth,
                        myColorTable, numColors, IgnoreEndian);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <span class="operator">*</span>myData;
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span><span class="operator">&gt;</span> myColorTable;

 <span class="type"><a href="qimage.html">QImage</a></span> image(myData<span class="operator">,</span> width<span class="operator">,</span> height<span class="operator">,</span> format);
 image<span class="operator">.</span><a href="qimage.html#setColorTable">setColorTable</a>(myColorTable);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageuchar*intintintintconstQRgb*intEndian -->
<h3 class="fn"><a name="QImage-15"></a>QImage::<span class="name">QImage</span> ( <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * <i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>bytesPerLine</i>, const <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>colortable</i>, <span class="type">int</span> <i>numColors</i>, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, <i>depth</i>, <i>bytesPerLine</i>, <i>colortable</i>, <i>numColors</i> and <i>bitOrder</i>, that uses an existing memory buffer, <i>data</i>. The image does not delete the buffer at destruction.</p>
<p><b>Warning:</b> This constructor is only available in Qt for Embedded Linux.</p>
<p>The data has to be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned, so it's no longer possible to specify a custom <i>bytesPerLine</i> value.</p>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageconstQByteArray& -->
<h3 class="fn"><a name="QImage-16"></a>QImage::<span class="name">QImage</span> ( const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp; <i>data</i> )</h3>
<p>Use the static <a href="qimage.html#fromData">fromData</a>() function instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QByteArray data;
 ..&#x2e;
 QImage image(data);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qbytearray.html">QByteArray</a></span> data;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="qimage.html">QImage</a></span> image <span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span><a href="qimage.html#fromData">fromData</a>(data);</pre>
<!-- @@@QImage -->
<!-- $$$bitOrder[overload1]$$$bitOrder -->
<h3 class="fn"><a name="bitOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">bitOrder</span> () const</h3>
<p>Returns the bit order for the image. If it is a 1-bpp image, this function returns either <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> or <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a>. Otherwise, this function returns <a href="qimage-qt3.html#Endian-enum">QImage::IgnoreEndian</a>.</p>
<p>Use the <a href="qimage.html#format">format</a>() function instead for the monochrome formats. For non-monochrome formats the bit order is irrelevant.</p>
<!-- @@@bitOrder -->
<!-- $$$convertBitOrder[overload1]$$$convertBitOrderEndian -->
<h3 class="fn"><a name="convertBitOrder"></a><span class="type">QImage</span> QImage::<span class="name">convertBitOrder</span> ( <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> ) const</h3>
<p>Converts the bit order of the image to the given <i>bitOrder</i> and returns the converted image. The original image is not changed. Returns this image if the given <i>bitOrder</i> is equal to the image current bit order, or a null image if this image cannot be converted.</p>
<p>Use <a href="qimage.html#convertToFormat">convertToFormat</a>() instead.</p>
<!-- @@@convertBitOrder -->
<!-- $$$convertDepth[overload1]$$$convertDepthintQt::ImageConversionFlags -->
<h3 class="fn"><a name="convertDepth"></a><span class="type">QImage</span> QImage::<span class="name">convertDepth</span> ( <span class="type">int</span> <i>depth</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor ) const</h3>
<p>Converts the depth (bpp) of the image to the given <i>depth</i> and returns the converted image. The original image is not changed. Returns this image if <i>depth</i> is equal to the image depth, or a null image if this image cannot be converted. The <i>depth</i> argument must be 1, 8 or 32. If the image needs to be modified to fit in a lower-resolution result (e.g&#x2e; converting from 32-bit to 8-bit), use the <i>flags</i> to specify how you'd prefer this to happen.</p>
<p>Use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function instead.</p>
<!-- @@@convertDepth -->
<!-- $$$convertDepthWithPalette[overload1]$$$convertDepthWithPaletteintQRgb*intQt::ImageConversionFlags -->
<h3 class="fn"><a name="convertDepthWithPalette"></a><span class="type">QImage</span> QImage::<span class="name">convertDepthWithPalette</span> ( <span class="type">int</span> <i>depth</i>, <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>palette</i>, <span class="type">int</span> <i>palette_count</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor ) const</h3>
<p>Returns an image with the given <i>depth</i>, using the <i>palette_count</i> colors pointed to by <i>palette</i>. If <i>depth</i> is 1 or 8, the returned image will have its color table ordered in the same way as <i>palette</i>.</p>
<p>If the image needs to be modified to fit in a lower-resolution result (e.g&#x2e; converting from 32-bit to 8-bit), use the <i>flags</i> to specify how you'd prefer this to happen.</p>
<p>Note: currently no closest-color search is made. If colors are found that are not in the palette, the palette may not be used at all. This result should not be considered valid because it may change in future implementations.</p>
<p>Currently inefficient for non-32-bit images.</p>
<p>Use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function in combination with the <a href="qimage.html#setColorTable">setColorTable</a>() function instead.</p>
<!-- @@@convertDepthWithPalette -->
<!-- $$$copy$$$copyintintintintQt::ImageConversionFlags -->
<h3 class="fn"><a name="copy-2"></a><span class="type">QImage</span> QImage::<span class="name">copy</span> ( <span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> ) const</h3>
<p>Use <a href="qimage.html#copy">copy</a>() instead.</p>
<!-- @@@copy -->
<!-- $$$copy$$$copyconstQRect&Qt::ImageConversionFlags -->
<h3 class="fn"><a name="copy-3"></a><span class="type">QImage</span> QImage::<span class="name">copy</span> ( const <span class="type"><a href="qrect.html">QRect</a></span> &amp; <i>rect</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> ) const</h3>
<p>Use <a href="qimage.html#copy">copy</a>() instead.</p>
<!-- @@@copy -->
<!-- $$$create[overload1]$$$createintintintintEndian -->
<h3 class="fn"><a name="create"></a><span class="type">bool</span> QImage::<span class="name">create</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Sets the image <i>width</i>, <i>height</i>, <i>depth</i>, its number of colors (in <i>numColors</i>), and bit order. Returns true if successful, or false if the parameters are incorrect or if memory cannot be allocated.</p>
<p>The <i>width</i> and <i>height</i> is limited to 32767. <i>depth</i> must be 1, 8, or 32. If <i>depth</i> is 1, <i>bitOrder</i> must be set to either <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a>. For other depths <i>bitOrder</i> must be <a href="qimage-qt3.html#Endian-enum">QImage::IgnoreEndian</a>.</p>
<p>This function allocates a color table and a buffer for the image data. The image data is not initialized. The image buffer is allocated as a single block that consists of a table of <a href="qimage.html#scanLine">scanLine</a>() pointers (<a href="qimage-qt3.html#jumpTable">jumpTable</a>()) and the image data (<a href="qimage.html#bits">bits</a>()).</p>
<p>Use a <a href="qimage.html">QImage</a> constructor instead.</p>
<!-- @@@create -->
<!-- $$$create$$$createconstQSize&intintEndian -->
<h3 class="fn"><a name="create-2"></a><span class="type">bool</span> QImage::<span class="name">create</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>This is an overloaded function.</p>
<p>The width and height are specified in the <i>size</i> argument.</p>
<p>Use a <a href="qimage.html">QImage</a> constructor instead.</p>
<!-- @@@create -->
<!-- $$$hasAlphaBuffer[overload1]$$$hasAlphaBuffer -->
<h3 class="fn"><a name="hasAlphaBuffer"></a><span class="type">bool</span> QImage::<span class="name">hasAlphaBuffer</span> () const</h3>
<p>Returns true if alpha buffer mode is enabled; otherwise returns false.</p>
<p>Use the <a href="qimage.html#hasAlphaChannel">hasAlphaChannel</a>() function instead.</p>
<!-- @@@hasAlphaBuffer -->
<!-- $$$invertPixels$$$invertPixelsbool -->
<h3 class="fn"><a name="invertPixels-2"></a><span class="type">void</span> QImage::<span class="name">invertPixels</span> ( <span class="type">bool</span> <i>invertAlpha</i> )</h3>
<p>Use the <a href="qimage.html#invertPixels">invertPixels</a>() function that takes a <a href="qimage.html#InvertMode-enum">QImage::InvertMode</a> parameter instead.</p>
<!-- @@@invertPixels -->
<!-- $$$jumpTable[overload1]$$$jumpTable -->
<h3 class="fn"><a name="jumpTable"></a><span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> ** QImage::<span class="name">jumpTable</span> ()</h3>
<p>Returns a pointer to the scanline pointer table. This is the beginning of the data block for the image. Returns 0 in case of an error.</p>
<p>Use the <a href="qimage.html#bits">bits</a>() or <a href="qimage.html#scanLine">scanLine</a>() function instead.</p>
<!-- @@@jumpTable -->
<!-- $$$jumpTable$$$jumpTable -->
<h3 class="fn"><a name="jumpTable-2"></a>const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * const * QImage::<span class="name">jumpTable</span> () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@jumpTable -->
<!-- $$$mirror[overload1]$$$mirrorboolbool -->
<h3 class="fn"><a name="mirror"></a><span class="type">QImage</span> QImage::<span class="name">mirror</span> ( <span class="type">bool</span> <i>horizontal</i> = false, <span class="type">bool</span> <i>vertical</i> = true ) const</h3>
<p>Use <a href="qimage.html#mirrored">mirrored</a>() instead.</p>
<!-- @@@mirror -->
<!-- $$$numBytes[overload1]$$$numBytes -->
<h3 class="fn"><a name="numBytes"></a><span class="type">int</span> QImage::<span class="name">numBytes</span> () const</h3>
<p>Returns the number of bytes occupied by the image data.</p>
<p><b>See also </b><a href="qimage.html#byteCount">byteCount</a>().</p>
<!-- @@@numBytes -->
<!-- $$$numColors[overload1]$$$numColors -->
<h3 class="fn"><a name="numColors"></a><span class="type">int</span> QImage::<span class="name">numColors</span> () const</h3>
<p>Returns the size of the color table for the image.</p>
<p><b>See also </b><a href="qimage-qt3.html#setNumColors">setNumColors</a>() and <a href="qimage.html#setColorCount">setColorCount</a>().</p>
<!-- @@@numColors -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn"><a name="reset"></a><span class="type">void</span> QImage::<span class="name">reset</span> ()</h3>
<p>Resets all image parameters and deallocates the image data.</p>
<p>Assign a null image instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.reset();</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image <span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span>();</pre>
<!-- @@@reset -->
<!-- $$$scaleHeight[overload1]$$$scaleHeightint -->
<h3 class="fn"><a name="scaleHeight"></a><span class="type">QImage</span> QImage::<span class="name">scaleHeight</span> ( <span class="type">int</span> <i>h</i> ) const</h3>
<p>Use <a href="qimage.html#scaledToHeight">scaledToHeight</a>() instead.</p>
<!-- @@@scaleHeight -->
<!-- $$$scaleWidth[overload1]$$$scaleWidthint -->
<h3 class="fn"><a name="scaleWidth"></a><span class="type">QImage</span> QImage::<span class="name">scaleWidth</span> ( <span class="type">int</span> <i>w</i> ) const</h3>
<p>Use <a href="qimage.html#scaledToWidth">scaledToWidth</a>() instead.</p>
<!-- @@@scaleWidth -->
<!-- $$$setAlphaBuffer[overload1]$$$setAlphaBufferbool -->
<h3 class="fn"><a name="setAlphaBuffer"></a><span class="type">void</span> QImage::<span class="name">setAlphaBuffer</span> ( <span class="type">bool</span> <i>enable</i> )</h3>
<p>Enables alpha buffer mode if <i>enable</i> is true, otherwise disables it. The alpha buffer is used to set a mask when a <a href="qimage.html">QImage</a> is translated to a <a href="qpixmap.html">QPixmap</a>.</p>
<p>If a monochrome or indexed 8-bit image has alpha channels in their color tables they will automatically detect that they have an alpha channel, so this function is not required. To force alpha channels on 32-bit images, use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function.</p>
<p><b>See also </b><a href="qimage-qt3.html#hasAlphaBuffer">hasAlphaBuffer</a>().</p>
<!-- @@@setAlphaBuffer -->
<!-- $$$setNumColors[overload1]$$$setNumColorsint -->
<h3 class="fn"><a name="setNumColors"></a><span class="type">void</span> QImage::<span class="name">setNumColors</span> ( <span class="type">int</span> <i>numColors</i> )</h3>
<p>Resizes the color table to contain <i>numColors</i> entries.</p>
<p><b>See also </b><a href="qimage-qt3.html#numColors">numColors</a>() and <a href="qimage.html#setColorCount">setColorCount</a>().</p>
<!-- @@@setNumColors -->
<!-- $$$setText$$$setTextconstchar*constchar*constQString& -->
<h3 class="fn"><a name="setText-2"></a><span class="type">void</span> QImage::<span class="name">setText</span> ( const <span class="type">char</span> * <i>key</i>, const <span class="type">char</span> * <i>language</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp; <i>text</i> )</h3>
<p>Sets the image text to the given <i>text</i> and associate it with the given <i>key</i>. The text is recorded in the specified <i>language</i>, or in a default language if <i>language</i> is 0.</p>
<p>Use <a href="qimage.html#setText">setText</a>() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using <a href="qstring.html">QString</a> and UTF-8 representation.</p>
<!-- @@@setText -->
<!-- $$$smoothScale[overload1]$$$smoothScaleintintQt::AspectRatioMode -->
<h3 class="fn"><a name="smoothScale"></a><span class="type">QImage</span> QImage::<span class="name">smoothScale</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qt.html#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>mode</i> = Qt::IgnoreAspectRatio ) const</h3>
<p>Use <a href="qimage.html#scaled">scaled</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.smoothScale(width, height, mode);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image<span class="operator">.</span><a href="qimage.html#scaled">scaled</a>(width<span class="operator">,</span> height<span class="operator">,</span> mode<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>SmoothTransformation);</pre>
<!-- @@@smoothScale -->
<!-- $$$smoothScale$$$smoothScaleconstQSize&Qt::AspectRatioMode -->
<h3 class="fn"><a name="smoothScale-2"></a><span class="type">QImage</span> QImage::<span class="name">smoothScale</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type"><a href="qt.html#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>mode</i> = Qt::IgnoreAspectRatio ) const</h3>
<p>This is an overloaded function.</p>
<p>Use <a href="qimage.html#scaled">scaled</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.smoothScale(size, mode);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image<span class="operator">.</span><a href="qimage.html#scaled">scaled</a>(size<span class="operator">,</span> mode<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>SmoothTransformation);</pre>
<!-- @@@smoothScale -->
<!-- $$$swapRGB[overload1]$$$swapRGB -->
<h3 class="fn"><a name="swapRGB"></a><span class="type">QImage</span> QImage::<span class="name">swapRGB</span> () const</h3>
<p>Use <a href="qimage.html#rgbSwapped">rgbSwapped</a>() instead.</p>
<!-- @@@swapRGB -->
<!-- $$$systemBitOrder[overload1]$$$systemBitOrder -->
<h3 class="fn"><a name="systemBitOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">systemBitOrder</span> ()<tt> [static]</tt></h3>
<p>Determines the bit order of the display hardware. Returns <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> (LSB first) or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> (MSB first).</p>
<p>This function is no longer relevant for <a href="qimage.html">QImage</a>. Use <a href="qsysinfo.html">QSysInfo</a> instead.</p>
<!-- @@@systemBitOrder -->
<!-- $$$systemByteOrder[overload1]$$$systemByteOrder -->
<h3 class="fn"><a name="systemByteOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">systemByteOrder</span> ()<tt> [static]</tt></h3>
<p>Determines the host computer byte order. Returns <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> (LSB first) or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> (MSB first).</p>
<p>This function is no longer relevant for <a href="qimage.html">QImage</a>. Use <a href="qsysinfo.html">QSysInfo</a> instead.</p>
<!-- @@@systemByteOrder -->
<!-- $$$text$$$textconstchar*constchar* -->
<h3 class="fn"><a name="text-2"></a><span class="type"><a href="qstring.html">QString</a></span> QImage::<span class="name">text</span> ( const <span class="type">char</span> * <i>key</i>, const <span class="type">char</span> * <i>language</i> = 0 ) const</h3>
<p>Returns the text recorded for the given <i>key</i> in the given <i>language</i>, or in a default language if <i>language</i> is 0.</p>
<p>Use <a href="qimage.html#text">text</a>() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using <a href="qstring.html">QString</a> and UTF-8 representation.</p>
<!-- @@@text -->
<!-- $$$text$$$textconstQImageTextKeyLang& -->
<h3 class="fn"><a name="text-3"></a><span class="type"><a href="qstring.html">QString</a></span> QImage::<span class="name">text</span> ( const <span class="type">QImageTextKeyLang</span> &amp; <i>keywordAndLanguage</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the text recorded for the given <i>keywordAndLanguage</i>.</p>
<p>Use <a href="qimage.html#text">text</a>() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using <a href="qstring.html">QString</a> and UTF-8 representation.</p>
<!-- @@@text -->
<!-- $$$textLanguages[overload1]$$$textLanguages -->
<h3 class="fn"><a name="textLanguages"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> QImage::<span class="name">textLanguages</span> () const</h3>
<p>Returns the language identifiers for which some texts are recorded. Note that if you want to iterate over the list, you should iterate over a copy.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using <a href="qstring.html">QString</a> and UTF-8 representation.</p>
<!-- @@@textLanguages -->
<!-- $$$textList[overload1]$$$textList -->
<h3 class="fn"><a name="textList"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">QImageTextKeyLang</span>&gt; QImage::<span class="name">textList</span> () const</h3>
<p>Returns a list of QImageTextKeyLang objects that enumerate all the texts key/language pairs set for this image.</p>
<p>Use <a href="qimage.html#textKeys">textKeys</a>() instead.</p>
<p>The language the text is recorded in is no longer relevant since the text is always set using <a href="qstring.html">QString</a> and UTF-8 representation.</p>
<!-- @@@textList -->
<!-- $$$xForm[overload1]$$$xFormconstQMatrix& -->
<h3 class="fn"><a name="xForm"></a><span class="type">QImage</span> QImage::<span class="name">xForm</span> ( const <span class="type"><a href="qmatrix.html">QMatrix</a></span> &amp; <i>matrix</i> ) const</h3>
<p>Use <a href="qimage.html#transformed">transformed</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 ..&#x2e;
 image.xForm(matrix);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 image<span class="operator">.</span><a href="qimage.html#transformed">transformed</a>(matrix);</pre>
<!-- @@@xForm -->
<h2>Related Non-Members</h2>
<!-- $$$bitBlt$$$bitBltQImage*intintconstQImage*intintintintQt::ImageConversionFlags -->
<h3 class="fn"><a name="bitBlt-4"></a><span class="type">void</span> <span class="name">bitBlt</span> ( <span class="type">QImage</span> * <i>dst</i>, <span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>, const <span class="type">QImage</span> * <i>src</i>, <span class="type">int</span> <i>sx</i> = 0, <span class="type">int</span> <i>sy</i> = 0, <span class="type">int</span> <i>sw</i> = -1, <span class="type">int</span> <i>sh</i> = -1, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor )</h3>
<p>Copies a block of pixels from <i>src</i> to <i>dst</i>. The pixels copied from source (src) are converted according to <i>flags</i> if it is incompatible with the destination (<i>dst</i>).</p>
<p><i>sx</i>, <i>sy</i> is the top-left pixel in <i>src</i>, <i>dx</i>, <i>dy</i> is the top-left position in <i>dst</i> and <i>sw</i>, <i>sh</i> is the size of the copied block. The copying is clipped if areas outside <i>src</i> or <i>dst</i> are specified. If <i>sw</i> is -1, it is adjusted to src-&gt;width(). Similarly, if <i>sh</i> is -1, it is adjusted to src-&gt;height().</p>
<p>Currently inefficient for non 32-bit images.</p>
<p>Use copy() or <a href="qpainter.html#drawImage">QPainter::drawImage</a>() instead.</p>
<!-- @@@bitBlt -->
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
