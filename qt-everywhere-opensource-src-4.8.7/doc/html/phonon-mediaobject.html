<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- phonon-api.qdoc -->
  <title>Qt 4.8: MediaObject Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="phonon.html">Phonon</a></li>
<li>MediaObject</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">MediaObject Class Reference</h1>
<span class="small-subtitle">(Phonon::MediaObject)<br/></span>
<!-- $$$MediaObject-brief -->
<p>The MediaObject class provides an interface for media playback. <a href="#details">More...</a></p>
<!-- @@@MediaObject -->
<pre class="cpp"> <span class="preprocessor">#include &lt;Phonon/MediaObject&gt;</span></pre><p><b>Inherits: </b><a href="qobject.html">QObject</a> and <a href="phonon-medianode.html">MediaNode</a>.</p>
<p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="phonon-mediaobject-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="properties"></a>
<h2>Properties</h2>
<ul>
<li class="fn"><b><a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a></b> : qint32</li>
<li class="fn"><b><a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a></b> : qint32</li>
<li class="fn"><b><a href="phonon-mediaobject.html#transitionTime-prop">transitionTime</a></b> : qint32</li>
</ul>
<ul>
<li class="fn">1 property inherited from <a href="qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#dtor.MediaObject">~MediaObject</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#clearQueue">clearQueue</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> MediaSource </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentSource">currentSource</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentTime">currentTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue">enqueue</a></b> ( const MediaSource &amp; <i>source</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue-2">enqueue</a></b> ( const QList&lt;MediaSource&gt; &amp; <i>sources</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue-3">enqueue</a></b> ( const QList&lt;QUrl&gt; &amp; <i>urls</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#errorString">errorString</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ErrorType </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#errorType">errorType</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#hasVideo">hasVideo</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#isSeekable">isSeekable</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData">metaData</a></b> ( const QString &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData-2">metaData</a></b> ( Phonon::MetaData <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;QString, QString&gt; </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData-3">metaData</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;MediaSource&gt; </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#queue">queue</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#remainingTime">remainingTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a></b> ( const MediaSource &amp; <i>source</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMark-prop">setPrefinishMark</a></b> ( qint32 <i>msecToEnd</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setQueue">setQueue</a></b> ( const QList&lt;MediaSource&gt; &amp; <i>sources</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setQueue-2">setQueue</a></b> ( const QList&lt;QUrl&gt; &amp; <i>urls</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#transitionTime-prop">setTransitionTime</a></b> ( qint32 <i>msec</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> State </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#state">state</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#totalTime">totalTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#transitionTime-prop">transitionTime</a></b> () const</td></tr>
</table>
<ul>
<li class="fn">29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
<li class="fn">3 public functions inherited from <a href="phonon-medianode.html#public-functions">Phonon::MediaNode</a></li>
</ul>
<a name="public-slots"></a>
<h2>Public Slots</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#pause">pause</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#play">play</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#seek">seek</a></b> ( qint64 <i>time</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tickInterval-prop">setTickInterval</a></b> ( qint32 <i>newTickInterval</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#stop">stop</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#bufferStatus">bufferStatus</a></b> ( int <i>percentFilled</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a></b> ( const Phonon::MediaSource &amp; <i>newSource</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#finished">finished</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a></b> ( bool <i>hasVideo</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a></b> ( qint32 <i>msecToEnd</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#seekableChanged">seekableChanged</a></b> ( bool <i>isSeekable</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#stateChanged">stateChanged</a></b> ( Phonon::State <i>newstate</i>, Phonon::State <i>oldstate</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tick">tick</a></b> ( qint64 <i>time</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a></b> ( qint64 <i>newTotalTime</i> )</td></tr>
</table>
<ul>
<li class="fn">1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">7 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li class="fn">8 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$MediaObject-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The MediaObject class provides an interface for media playback.</p>
<p>The media object manages a <a href="phonon-mediasource.html">MediaSource</a>, which supplies the media object with multimedia content, e.g&#x2e;, from a file. A playback in Phonon is always started by calling the <a href="phonon-mediaobject.html#play">play()</a> function.</p>
<p>The state of play (play, pause, stop, seek) is controlled by the media object, and you can also query the current <a href="phonon-mediaobject.html#state">state()</a>. It keeps track of the playback position in the media stream, and emits the <a href="phonon-mediaobject.html#tick">tick()</a> signal when the current position in the stream changes.</p>
<p>Notice that most functions of this class are asynchronous, so you cannot rely on that a state is entered after a function call before you receive the <a href="phonon-mediaobject.html#stateChanged">stateChanged()</a> signal. The description of the <a href="phonon.html#State-enum">State</a> enum gives a description of the different states.</p>
<p>Before <a href="phonon-mediaobject.html#play">play</a>() is called, the media object should be connected to <a href="phonon-overview.html#sinks">output nodes</a>, which outputs the media to the underlying hardware. The output nodes required are dependent on the contents of the multimedia file that is played back. Phonon has currently two output nodes: the <a href="phonon-audiooutput.html">AudioOutput</a> for audio content and <a href="phonon-videowidget.html">VideoWidget</a> for video content. If a <a href="phonon-mediasource.html">MediaSource</a> contains both audio and video, both nodes need to be connected to the media object.</p>
<pre class="cpp">     Phonon<span class="operator">::</span>MediaObject <span class="operator">*</span>mediaObject <span class="operator">=</span> <span class="keyword">new</span> Phonon<span class="operator">::</span>MediaObject(<span class="keyword">this</span>);

     Phonon<span class="operator">::</span>VideoWidget <span class="operator">*</span>videoWidget <span class="operator">=</span> <span class="keyword">new</span> Phonon<span class="operator">::</span>VideoWidget(<span class="keyword">this</span>);
     Phonon<span class="operator">::</span>createPath(mediaObject<span class="operator">,</span> videoWidget);

     Phonon<span class="operator">::</span>AudioOutput <span class="operator">*</span>audioOutput <span class="operator">=</span>
         <span class="keyword">new</span> Phonon<span class="operator">::</span>AudioOutput(Phonon<span class="operator">::</span>VideoCategory<span class="operator">,</span> <span class="keyword">this</span>);
     Phonon<span class="operator">::</span>createPath(mediaObject<span class="operator">,</span> audioOutput);
     mediaObject<span class="operator">-</span><span class="operator">&gt;</span>play();</pre>
<p>The media object can queue sources for playback. When it has finished to play one source, it will start playing the next in the queue; the new source is then removed from the queue. The queue can be altered at any time.</p>
<pre class="cpp"> media<span class="operator">-</span><span class="operator">&gt;</span>setCurrentSource(<span class="string">&quot;:/sounds/startsound.ogg&quot;</span>);
 media<span class="operator">-</span><span class="operator">&gt;</span>enqueue(<span class="string">&quot;/home/username/music/song.mp3&quot;</span>);
 media<span class="operator">-</span><span class="operator">&gt;</span>enqueue(<span class="string">&quot;:/sounds/endsound.ogg&quot;</span>);</pre>
<p>You can also make use of the <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish()</a> signal, which is guaranteed to be emitted in time for altering the queue.</p>
<pre class="cpp">   media<span class="operator">-</span><span class="operator">&gt;</span>setCurrentSource(<span class="string">&quot;:/sounds/startsound.ogg&quot;</span>);
   connect(media<span class="operator">,</span> SIGNAL(aboutToFinish())<span class="operator">,</span> SLOT(enqueueNextSource()));
 }

 <span class="type">void</span> enqueueNextSource()
 {
   media<span class="operator">-</span><span class="operator">&gt;</span>enqueue(<span class="string">&quot;/home/username/music/song.mp3&quot;</span>);
 }</pre>
<p>When playback is finishing, i.e&#x2e;, when a media source has been played to the end and the queue is empty, several signals are emitted. First, the media object will emit <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>() - shortly before the playback has finished - and then <a href="phonon-mediaobject.html#finished">finished</a>(). The <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal will also be emitted with <a href="phonon.html#State-enum">PausedState</a>, which is the state the media object takes when the playback is finished. If you wish to enter another state, you can connect a slot to <a href="phonon-mediaobject.html#finished">finished</a>() and set a new state there.</p>
<p>The media object resolves the meta information, such as title, artist, and album. The meta data is not resolved immediately after a new source is provided, but will be resolved before the object leaves the <a href="phonon.html#State-enum">LoadingState</a>. The data is queried by string keys - which should follow the Ogg Vorbis specification <a href="http://xiph.org/vorbis/doc/v-comment.html">http://xiph.org/vorbis/doc/v-comment.html</a> - or by using the <a href="phonon.html#MetaData-enum">MetaData</a> enum. The data available will depend on the type and content of the individual media files. <a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>() will be emitted when the media object has resolved new meta data.</p>
<p>Errors encountered during playback and loading of media sources are reported by emitting a state changed signal with <a href="phonon.html#State-enum">ErrorState</a>. The severity of the error can be queried by the <a href="phonon.html#ErrorType-enum">ErrorType</a>. With a <a href="phonon.html#ErrorType-enum">NormalError</a>, it might be possible to continue the playback, for instance, if only audio playback fails for a media source which also has video. A <a href="phonon.html#ErrorType-enum">FatalError</a> indicates that Phonon cannot continue playback of the current source, but it is possible to try with a different one. A user readable error message is given by <a href="phonon-mediaobject.html#errorString">errorString</a>().</p>
</div>
<p><b>See also </b><a href="symbian-platform-security-requirements.html">Symbian Platform Security Requirements</a>, <a href="phonon-mediasource.html">Phonon::MediaSource</a>, <a href="phonon-audiooutput.html">Phonon::AudioOutput</a>, <a href="phonon-videowidget.html">VideoWidget</a>, <a href="phonon-qmusicplayer.html">Music Player Example</a>, <a href="phonon-overview.html#phonon-overview">Phonon Overview</a>, <a href="phonon-videoplayer.html">Phonon::VideoPlayer</a>, <a href="phonon.html#createPlayer">Phonon::createPlayer</a>(), and <a href="phonon-module.html">Phonon Module</a>.</p>
<!-- @@@MediaObject -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$prefinishMark-prop$$$prefinishMark$$$setPrefinishMarkqint32 -->
<h3 class="fn"><a name="prefinishMark-prop"></a><span class="name">prefinishMark</span> : <span class="type"><a href="qtglobal.html#qint32-typedef">qint32</a></span></h3>
<p>This property holds the time when the prefinishMarkReached signal is emitted before playback ends.</p>
<p>This property specifies the time in milliseconds the <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>() signal is emitted before the playback finishes. A value of <tt>0</tt> disables the signal. The signal is only emitted for the last source in the <a href="phonon-mediaobject.html#queue">media queue</a>.</p>
<p>Defaults to <tt>0</tt> (disabled).</p>
<p><b>Warning:</b> For some media data the total time cannot be determined accurately, therefore the accuracy of the prefinishMarkReached signal can be bad sometimes. Still, it is better to use this method than to look at <a href="phonon-mediaobject.html#totalTime">totalTime</a>() and <a href="phonon-mediaobject.html#currentTime">currentTime</a>() to emulate the behavior because the backend might have more information available than your application does through <a href="phonon-mediaobject.html#totalTime">totalTime</a>() and <a href="phonon-mediaobject.html#currentTime">currentTime</a>().</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><span class="name"><b>prefinishMark</b></span> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setPrefinishMark</b></span> ( qint32 <i>msecToEnd</i> )</td></tr>
</table>
<p><b>See also </b><a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@prefinishMark -->
<!-- $$$tickInterval-prop$$$tickInterval$$$setTickIntervalqint32 -->
<h3 class="fn"><a name="tickInterval-prop"></a><span class="name">tickInterval</span> : <span class="type"><a href="qtglobal.html#qint32-typedef">qint32</a></span></h3>
<p>This property holds the time interval in milliseconds between two ticks.</p>
<p>The <a href="phonon-mediaobject.html#tick">tick</a>() signal is emitted continuously during playback. The tick interval is the time that elapses between the emission of two tick signals. If you set the interval to <tt>0</tt> the tick signal gets disabled.</p>
<p>The <a href="phonon-mediaobject.html#tick">tick</a>() signal can, for instance, be used to update widgets that show the current position in the playback of a media source.</p>
<p>Defaults to <tt>0</tt> (disabled).</p>
<p><b>Warning:</b> The back-end is free to choose a different tick interval close to what you asked for. This means that the following code <tt>may</tt> fail:</p>
<pre class="cpp"> <span class="type">int</span> x <span class="operator">=</span> <span class="number">200</span>;
 media<span class="operator">-</span><span class="operator">&gt;</span>setTickInterval(x);
 Q_ASSERT(x <span class="operator">=</span><span class="operator">=</span> producer<span class="operator">-</span><span class="operator">&gt;</span>tickInterval());</pre>
<p>On the other hand the following is guaranteed:</p>
<pre class="cpp"> <span class="type">int</span> x <span class="operator">=</span> <span class="number">200</span>;
 media<span class="operator">-</span><span class="operator">&gt;</span>setTickInterval(x);
 Q_ASSERT(x <span class="operator">&gt;</span><span class="operator">=</span> producer<span class="operator">-</span><span class="operator">&gt;</span>tickInterval() <span class="operator">&amp;</span><span class="operator">&amp;</span>
          x <span class="operator">&lt;</span><span class="operator">=</span> <span class="number">2producer</span><span class="operator">-</span><span class="operator">&gt;</span>tickInterval());</pre>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><span class="name"><b>tickInterval</b></span> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTickInterval</b></span> ( qint32 <i>newTickInterval</i> )</td></tr>
</table>
<p><b>See also </b><a href="phonon-mediaobject.html#tick">tick</a>().</p>
<!-- @@@tickInterval -->
<!-- $$$transitionTime-prop$$$transitionTime$$$setTransitionTimeqint32 -->
<h3 class="fn"><a name="transitionTime-prop"></a><span class="name">transitionTime</span> : <span class="type"><a href="qtglobal.html#qint32-typedef">qint32</a></span></h3>
<p>This property defines the time between playback of two media sources in the media queue.</p>
<p>A positive transition time defines a gap of silence between queued media sources.</p>
<p>A transition time of 0 ms requests gapless playback (i.e&#x2e;, the next source in the media queue starts immediately after the playback of the current source finishes).</p>
<p>A negative transition time defines a crossfade between the queued media sources.</p>
<p>Defaults to 0 (gapless playback).</p>
<p><b>Warning:</b> This feature might not work reliably with every backend.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><span class="name"><b>transitionTime</b></span> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTransitionTime</b></span> ( qint32 <i>msec</i> )</td></tr>
</table>
<!-- @@@transitionTime -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~MediaObject[overload1]$$$~MediaObject -->
<h3 class="fn"><a name="dtor.MediaObject"></a>MediaObject::<span class="name">~MediaObject</span> ()</h3>
<p>Destroys the <a href="phonon-mediaobject.html">MediaObject</a>.</p>
<!-- @@@~MediaObject -->
<!-- $$$aboutToFinish[overload1]$$$aboutToFinish -->
<h3 class="fn"><a name="aboutToFinish"></a><span class="type">void</span> MediaObject::<span class="name">aboutToFinish</span> ()<tt> [signal]</tt></h3>
<p>Emitted before the playback of the whole queue ends. When this signal is emitted you still have time to <a href="phonon-mediaobject.html#enqueue">enqueue</a>() a new <a href="phonon-mediasource.html">MediaSource</a>, so that playback continues.</p>
<p>If you need a signal to be emitted at a specific time before playback is finished, you should use the <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>() signal instead.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#enqueue">enqueue</a>(), <a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a>, and <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@aboutToFinish -->
<!-- $$$bufferStatus[overload1]$$$bufferStatusint -->
<h3 class="fn"><a name="bufferStatus"></a><span class="type">void</span> MediaObject::<span class="name">bufferStatus</span> ( <span class="type">int</span> <i>percentFilled</i> )<tt> [signal]</tt></h3>
<p>Provides information about the status of the buffer.</p>
<p>When a <a href="phonon-mediaobject.html">MediaObject</a> is in the <a href="phonon.html#State-enum">BufferingState</a>, it will send this signal regularly. <i>percentFilled</i> is a number between 0 and 100 telling you how much the buffer is filled.</p>
<p>You can use this signal to show a progress bar to the user when in <a href="phonon.html#State-enum">BufferingState</a>:</p>
<pre class="cpp"> progressBar<span class="operator">-</span><span class="operator">&gt;</span>setRange(<span class="number">0</span><span class="operator">,</span> <span class="number">100</span>); <span class="comment">// this is the default</span>
 connect(media<span class="operator">,</span> SIGNAL(bufferStatus(<span class="type">int</span>))<span class="operator">,</span> progressBar<span class="operator">,</span> SLOT(setValue(<span class="type">int</span>)));</pre>
<p>Note that the <a href="phonon.html#State-enum">BufferingState</a> is commonly used when waiting for data over a network connection, but this might not be true for all backends.</p>
<!-- @@@bufferStatus -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn"><a name="clear"></a><span class="type">void</span> MediaObject::<span class="name">clear</span> ()<tt> [slot]</tt></h3>
<p>Stops and removes all playing and enqueued media sources.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>().</p>
<!-- @@@clear -->
<!-- $$$clearQueue[overload1]$$$clearQueue -->
<h3 class="fn"><a name="clearQueue"></a><span class="type">void</span> MediaObject::<span class="name">clearQueue</span> ()</h3>
<p>Clears the queue of media sources.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#queue">queue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@clearQueue -->
<!-- $$$currentSource[overload1]$$$currentSource -->
<h3 class="fn"><a name="currentSource"></a><span class="type"><a href="phonon-mediasource.html">MediaSource</a></span> MediaObject::<span class="name">currentSource</span> () const</h3>
<p>Returns the current media source, i.e&#x2e;, the media source that is being played back. The current source is either set with <a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>() or taken from the media <a href="phonon-mediaobject.html#queue">queue</a>() when a media source has finished playing.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>().</p>
<!-- @@@currentSource -->
<!-- $$$currentSourceChanged[overload1]$$$currentSourceChangedconstPhonon::MediaSource& -->
<h3 class="fn"><a name="currentSourceChanged"></a><span class="type">void</span> MediaObject::<span class="name">currentSourceChanged</span> ( const <span class="type"><a href="phonon-mediasource.html">Phonon::MediaSource</a></span> &amp; <i>newSource</i> )<tt> [signal]</tt></h3>
<p>Emitted when the <a href="phonon-mediaobject.html">MediaObject</a> fetches a new <a href="phonon-mediasource.html">MediaSource</a> from the <a href="phonon-mediaobject.html#queue">queue</a>() and before it enters the <a href="phonon.html#State-enum">LoadingState</a> for the new source. The media object will take a new source from the <a href="phonon-mediaobject.html#queue">queue</a>() when it has finished the playback of the <a href="phonon-mediaobject.html#currentSource">current source</a>.</p>
<p><i>newSource</i> is the source that starts to play at the time the signal is emitted.</p>
<!-- @@@currentSourceChanged -->
<!-- $$$currentTime[overload1]$$$currentTime -->
<h3 class="fn"><a name="currentTime"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> MediaObject::<span class="name">currentTime</span> () const</h3>
<p>Returns the current time (in milliseconds), i.e&#x2e;, position in the media stream, of the file currently being played.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#tick">tick</a>(), <a href="phonon-mediaobject.html#totalTime">totalTime</a>(), and <a href="phonon-mediaobject.html#remainingTime">remainingTime</a>().</p>
<!-- @@@currentTime -->
<!-- $$$enqueue[overload1]$$$enqueueconstMediaSource& -->
<h3 class="fn"><a name="enqueue"></a><span class="type">void</span> MediaObject::<span class="name">enqueue</span> ( const <span class="type"><a href="phonon-mediasource.html">MediaSource</a></span> &amp; <i>source</i> )</h3>
<p>Appends <i>source</i> to the queue.</p>
<p>You can use this function to provide the next source after the <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>() signal has been emitted.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), <a href="phonon-mediaobject.html#setQueue">setQueue</a>(), and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$enqueue$$$enqueueconstQList<MediaSource>& -->
<h3 class="fn"><a name="enqueue-2"></a><span class="type">void</span> MediaObject::<span class="name">enqueue</span> ( const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="phonon-mediasource.html">MediaSource</a></span>&gt; &amp; <i>sources</i> )</h3>
<p>Appends multiple <i>sources</i> to the queue.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$enqueue$$$enqueueconstQList<QUrl>& -->
<h3 class="fn"><a name="enqueue-3"></a><span class="type">void</span> MediaObject::<span class="name">enqueue</span> ( const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qurl.html">QUrl</a></span>&gt; &amp; <i>urls</i> )</h3>
<p>Appends the URLs in <i>urls</i> to the media source queue.</p>
<p>The function will create <a href="phonon-mediasource.html">MediaSource</a>s from the <a href="qurl.html">QUrl</a>s, and append these to the queue.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn"><a name="errorString"></a><span class="type"><a href="qstring.html">QString</a></span> MediaObject::<span class="name">errorString</span> () const</h3>
<p>Returns a human-readable description of the last error that occurred. The strings given may vary between backends.</p>
<p>The error description can be used to give a message to the user - and the developer - when the <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal is emitted with <a href="phonon.html#State-enum">ErrorState</a>.</p>
<a name="qt-backends"></a>
<h4>Qt Backends</h4>
<p>On Windows, Qt fetches its error messages from the DirectShow backend. This usually includes an error number, which can be looked up in the DirectShow documentation: <a href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx81_c/directx_cpp/htm/errorandsuccesscodes.asp">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx81_c/directx_cpp/htm/errorandsuccesscodes.asp</a>.</p>
<p>On Linux and Mac, the error strings are not fetched directly from the backend, but are created in the backend.</p>
<p><b>See also </b><a href="phonon.html#State-enum">Phonon::ErrorState</a> and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@errorString -->
<!-- $$$errorType[overload1]$$$errorType -->
<h3 class="fn"><a name="errorType"></a><span class="type"><a href="phonon.html#ErrorType-enum">ErrorType</a></span> MediaObject::<span class="name">errorType</span> () const</h3>
<p>Tells your program what to do about the last error that occurred. Use this function after receiving a <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal with <a href="phonon.html#State-enum">ErrorState</a>.</p>
<p><b>See also </b><a href="phonon.html#ErrorType-enum">Phonon::ErrorType</a>, <a href="phonon.html#State-enum">Phonon::ErrorState</a>, and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@errorType -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn"><a name="finished"></a><span class="type">void</span> MediaObject::<span class="name">finished</span> ()<tt> [signal]</tt></h3>
<p>Emitted when the object has finished playback. It is not emitted if you call <a href="phonon-mediaobject.html#stop">stop</a>(), <a href="phonon-mediaobject.html#pause">pause</a>() or load(). It is emitted only when the current media source has finished playing and the media <a href="phonon-mediaobject.html#queue">queue</a>() is empty, or when a <a href="phonon.html#ErrorType-enum">fatal error</a> occurs.</p>
<p><b>Warning:</b> This signal is not emitted when the current source has finished and there's another source in the queue. It is only emitted when the queue is empty.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a>(), <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), and <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@finished -->
<!-- $$$hasVideo[overload1]$$$hasVideo -->
<h3 class="fn"><a name="hasVideo"></a><span class="type">bool</span> MediaObject::<span class="name">hasVideo</span> () const</h3>
<p>Check whether the current media source includes a video stream.</p>
<p><b>Warning:</b> This information is not resolved immediately after a media object gets a new source. Listen to the <a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>() signal instead.</p>
<pre class="cpp">   connect(media<span class="operator">,</span> SIGNAL(hasVideoChanged(<span class="type">bool</span>))<span class="operator">,</span> hasVideoChanged(<span class="type">bool</span>));
   media<span class="operator">-</span><span class="operator">&gt;</span>setCurrentSource(<span class="string">&quot;somevideo.avi&quot;</span>);
   media<span class="operator">-</span><span class="operator">&gt;</span>hasVideo(); <span class="comment">// returns false;</span>
 }

 <span class="type">void</span> hasVideoChanged(<span class="type">bool</span> b)
 {
   <span class="comment">// b == true</span>
   media<span class="operator">-</span><span class="operator">&gt;</span>hasVideo(); <span class="comment">// returns true;</span>
 }</pre>
<p>Returns <tt>true</tt> if the media contains video data; otherwise, returns <tt>false</tt>.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>().</p>
<!-- @@@hasVideo -->
<!-- $$$hasVideoChanged[overload1]$$$hasVideoChangedbool -->
<h3 class="fn"><a name="hasVideoChanged"></a><span class="type">void</span> MediaObject::<span class="name">hasVideoChanged</span> ( <span class="type">bool</span> <i>hasVideo</i> )<tt> [signal]</tt></h3>
<p>Emitted whenever the return value of <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>() changes, i.e&#x2e;, the media source being played back contains video.</p>
<p>Normally you'll check <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>() first and then let this signal tell you whether video is available now or not. That way you don't have to poll <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>().</p>
<p><i>hasVideo</i> is true when the stream contains video and adding a <a href="phonon-videowidget.html">VideoWidget</a> will show a video, and false if there is no video data in the stream and adding a <a href="phonon-videowidget.html">VideoWidget</a> will show an empty (black) <a href="phonon-videowidget.html">VideoWidget</a>.</p>
<!-- @@@hasVideoChanged -->
<!-- $$$isSeekable[overload1]$$$isSeekable -->
<h3 class="fn"><a name="isSeekable"></a><span class="type">bool</span> MediaObject::<span class="name">isSeekable</span> () const</h3>
<p>Check whether it is possible to seek, i.e&#x2e;, change the playback position in the media stream.</p>
<p><b>Warning:</b> This information is not solved immediately after the media object gets a new media source. The <a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>() signal is emitted after this information is available.</p>
<pre class="cpp">   connect(media<span class="operator">,</span> SIGNAL(hasVideoChanged(<span class="type">bool</span>))<span class="operator">,</span> hasVideoChanged(<span class="type">bool</span>));
   media<span class="operator">-</span><span class="operator">&gt;</span>setCurrentSource(<span class="string">&quot;somevideo.avi&quot;</span>);
   media<span class="operator">-</span><span class="operator">&gt;</span>hasVideo(); <span class="comment">// returns false;</span>
 }

 <span class="type">void</span> hasVideoChanged(<span class="type">bool</span> b)
 {
   <span class="comment">// b == true</span>
   media<span class="operator">-</span><span class="operator">&gt;</span>hasVideo(); <span class="comment">// returns true;</span>
 }</pre>
<p>Returns <tt>true</tt> if the current media may be seeked; otherwise, returns <tt>false</tt>.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#seekableChanged">seekableChanged</a>().</p>
<!-- @@@isSeekable -->
<!-- $$$metaData[overload1]$$$metaDataconstQString& -->
<h3 class="fn"><a name="metaData"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> MediaObject::<span class="name">metaData</span> ( const <span class="type"><a href="qstring.html">QString</a></span> &amp; <i>key</i> ) const</h3>
<p>Returns the strings associated with the given <i>key</i>.</p>
<p>Backends should use the keys specified in the Ogg Vorbis documentation: <a href="http://xiph.org/vorbis/doc/v-comment.html">http://xiph.org/vorbis/doc/v-comment.html</a></p>
<p>Therefore the following should work with every backend:</p>
<p>Note that meta data is not resolved before the <tt>metaDataChanged()</tt> signal is emitted.</p>
<p>A typical usage looks like this:</p>
<pre class="cpp"> setMetaArtist(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;ARTIST&quot;</span>));
 setMetaAlbum(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;ALBUM&quot;</span>));
 setMetaTitle(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;TITLE&quot;</span>));
 setMetaDate(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;DATE&quot;</span>));
 setMetaGenre(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;GENRE&quot;</span>));
 setMetaTrack(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;TRACKNUMBER&quot;</span>));
 setMetaComment(media<span class="operator">-</span><span class="operator">&gt;</span>metaData(<span class="string">&quot;DESCRIPTION&quot;</span>));</pre>
<!-- @@@metaData -->
<!-- $$$metaData$$$metaDataPhonon::MetaData -->
<h3 class="fn"><a name="metaData-2"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> MediaObject::<span class="name">metaData</span> ( <span class="type"><a href="phonon.html#MetaData-enum">Phonon::MetaData</a></span> <i>key</i> ) const</h3>
<p>Returns the strings associated with the given <i>key</i>.</p>
<p>Same as above except that the keys are defined in the <a href="phonon.html#MetaData-enum">Phonon::MetaData</a> enum.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>().</p>
<!-- @@@metaData -->
<!-- $$$metaData$$$metaData -->
<h3 class="fn"><a name="metaData-3"></a><span class="type"><a href="qmultimap.html">QMultiMap</a></span>&lt;<span class="type"><a href="qstring.html">QString</a></span>, <span class="type"><a href="qstring.html">QString</a></span>&gt; MediaObject::<span class="name">metaData</span> () const</h3>
<p>Returns all meta data in a multi map.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>().</p>
<!-- @@@metaData -->
<!-- $$$metaDataChanged[overload1]$$$metaDataChanged -->
<h3 class="fn"><a name="metaDataChanged"></a><span class="type">void</span> MediaObject::<span class="name">metaDataChanged</span> ()<tt> [signal]</tt></h3>
<p>This signal is emitted when the media object has resolved new meta data. This will happen before the media object leaves the <a href="phonon.html#State-enum">LoadingState</a> after a new source has been set.</p>
<p>This signal is not emitted when the media object removes the current data, i.e&#x2e;, when a new source is set or an error has occurred. If you need to know this, you can listen for the <a href="phonon.html#State-enum">ErrorState</a>, and connect to the <a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged()</a> signal.</p>
<p>You can get the new meta data with the metaData methods.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#metaData">metaData</a>(), <a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a>(), <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>(), and <a href="phonon.html#State-enum">Phonon::State</a>.</p>
<!-- @@@metaDataChanged -->
<!-- $$$pause[overload1]$$$pause -->
<h3 class="fn"><a name="pause"></a><span class="type">void</span> MediaObject::<span class="name">pause</span> ()<tt> [slot]</tt></h3>
<p>Requests playback to pause, and the media object to enter the <a href="phonon.html#State-enum">PausedState</a>. If it was paused already, nothing changes.</p>
<p>This function is asynchronous and the media might not be paused immediately.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#play">play</a>(), <a href="phonon-mediaobject.html#stop">stop</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@pause -->
<!-- $$$play[overload1]$$$play -->
<h3 class="fn"><a name="play"></a><span class="type">void</span> MediaObject::<span class="name">play</span> ()<tt> [slot]</tt></h3>
<p>Requests playback of the media data to start.</p>
<p>Playback starts when the <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal is emitted with <a href="phonon.html#State-enum">PlayingState</a>.</p>
<p>If the media object is already in a <a href="phonon.html#State-enum">PlayingState</a>, nothing happens.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#stop">stop</a>(), <a href="phonon-mediaobject.html#pause">pause</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@play -->
<!-- $$$prefinishMarkReached[overload1]$$$prefinishMarkReachedqint32 -->
<h3 class="fn"><a name="prefinishMarkReached"></a><span class="type">void</span> MediaObject::<span class="name">prefinishMarkReached</span> ( <span class="type"><a href="qtglobal.html#qint32-typedef">qint32</a></span> <i>msecToEnd</i> )<tt> [signal]</tt></h3>
<p>Emitted when there are only <i>msecToEnd</i> milliseconds left of playback.</p>
<p><b>Warning:</b> This signal is not emitted when there is another source in the queue. It is only emitted when the queue is empty.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#prefinishMark-prop">setPrefinishMark</a>(), <a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a>(), <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), and <a href="phonon-mediaobject.html#finished">finished</a>().</p>
<!-- @@@prefinishMarkReached -->
<!-- $$$queue[overload1]$$$queue -->
<h3 class="fn"><a name="queue"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="phonon-mediasource.html">MediaSource</a></span>&gt; MediaObject::<span class="name">queue</span> () const</h3>
<p>Returns the queued media sources.</p>
<p>This does list does not include the current source, returned by <a href="phonon-mediaobject.html#currentSource">currentSource</a>().</p>
<p><b>See also </b><a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@queue -->
<!-- $$$remainingTime[overload1]$$$remainingTime -->
<h3 class="fn"><a name="remainingTime"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> MediaObject::<span class="name">remainingTime</span> () const</h3>
<p>Get the remaining time (in milliseconds) of the file currently being played.</p>
<p>Returns the remaining time in milliseconds.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#totalTime">totalTime</a>(), <a href="phonon-mediaobject.html#currentTime">currentTime</a>(), and <a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a>().</p>
<!-- @@@remainingTime -->
<!-- $$$seek[overload1]$$$seekqint64 -->
<h3 class="fn"><a name="seek"></a><span class="type">void</span> MediaObject::<span class="name">seek</span> ( <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>time</i> )<tt> [slot]</tt></h3>
<p>Requests a seek to the <i>time</i> indicated, specified in milliseconds.</p>
<p>You can only seek if <a href="phonon-mediaobject.html#state">state</a>() is <a href="phonon.html#State-enum">PlayingState</a>, <a href="phonon.html#State-enum">BufferingState</a> or <a href="phonon.html#State-enum">PausedState</a>.</p>
<p>The call is asynchronous, so currentTime can still be the old value right after this method was called. If all you need is a slider that shows the current position and allows the user to seek, use the class <a href="phonon-seekslider.html">SeekSlider</a>.</p>
<p>If the current source of the media object is not seekable, calls to this functions do nothing.</p>
<p><b>See also </b><a href="phonon-seekslider.html">SeekSlider</a> and <a href="phonon-mediaobject.html#tick">tick</a>().</p>
<!-- @@@seek -->
<!-- $$$seekableChanged[overload1]$$$seekableChangedbool -->
<h3 class="fn"><a name="seekableChanged"></a><span class="type">void</span> MediaObject::<span class="name">seekableChanged</span> ( <span class="type">bool</span> <i>isSeekable</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when the media object's ability to seek in the media stream changes. <i>isSeekable</i> is true if it is possible to <a href="phonon-mediaobject.html#seek">seek</a>(); otherwise, it is false.</p>
<p>Change in the ability to seek in the stream usually happens when the current source changes or when an error occurs.</p>
<p>Normally you'll check <a href="phonon-mediaobject.html#isSeekable">isSeekable</a>() after setting a new media source, and then let this signal tell you when seeking is possible. That way you don't have to poll <a href="phonon-mediaobject.html#isSeekable">isSeekable</a>().</p>
<!-- @@@seekableChanged -->
<!-- $$$setCurrentSource[overload1]$$$setCurrentSourceconstMediaSource& -->
<h3 class="fn"><a name="setCurrentSource"></a><span class="type">void</span> MediaObject::<span class="name">setCurrentSource</span> ( const <span class="type"><a href="phonon-mediasource.html">MediaSource</a></span> &amp; <i>source</i> )</h3>
<p>Set the media source the <a href="phonon-mediaobject.html">MediaObject</a> should use.</p>
<p>After the media object receives a new source, it will enter the <a href="phonon.html#State-enum">LoadingState</a>. When it is ready to play, it enters the <a href="phonon.html#State-enum">StoppedState</a> unless another state has been requested, e.g&#x2e;, by calling <a href="phonon-mediaobject.html#play">play</a>().</p>
<p><i>source</i> is the <a href="phonon-mediasource.html">MediaSource</a> object to the media data. You can just as well use a <a href="qurl.html">QUrl</a> or <a href="qstring.html">QString</a> (for a local file) here.</p>
<p>We show an example:</p>
<pre class="cpp"> <span class="type"><a href="qurl.html">QUrl</a></span> url(<span class="string">&quot;http://www.example.com/music.ogg&quot;</span>);
 media<span class="operator">-</span><span class="operator">&gt;</span>setCurrentSource(url);</pre>
<p><b>See also </b><a href="phonon-mediaobject.html#currentSource">currentSource</a>() and <a href="phonon-mediasource.html">MediaSource</a>.</p>
<!-- @@@setCurrentSource -->
<!-- $$$setQueue[overload1]$$$setQueueconstQList<MediaSource>& -->
<h3 class="fn"><a name="setQueue"></a><span class="type">void</span> MediaObject::<span class="name">setQueue</span> ( const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="phonon-mediasource.html">MediaSource</a></span>&gt; &amp; <i>sources</i> )</h3>
<p>Set the <i>sources</i> to play when the current source has finished.</p>
<p>This function will overwrite the current queue.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#clearQueue">clearQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@setQueue -->
<!-- $$$setQueue$$$setQueueconstQList<QUrl>& -->
<h3 class="fn"><a name="setQueue-2"></a><span class="type">void</span> MediaObject::<span class="name">setQueue</span> ( const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qurl.html">QUrl</a></span>&gt; &amp; <i>urls</i> )</h3>
<p>Set the <i>urls</i> to play when the current media has finished.</p>
<p>This function overwrites the current queue.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#clearQueue">clearQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@setQueue -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn"><a name="state"></a><span class="type"><a href="phonon.html#State-enum">State</a></span> MediaObject::<span class="name">state</span> () const</h3>
<p>Returns the current <a href="phonon.html#State-enum">Phonon::State</a> of the object.</p>
<p><b>See also </b><a href="phonon.html#State-enum">Phonon::State</a> and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedPhonon::StatePhonon::State -->
<h3 class="fn"><a name="stateChanged"></a><span class="type">void</span> MediaObject::<span class="name">stateChanged</span> ( <span class="type"><a href="phonon.html#State-enum">Phonon::State</a></span> <i>newstate</i>, <span class="type"><a href="phonon.html#State-enum">Phonon::State</a></span> <i>oldstate</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when the state of the <a href="phonon-mediaobject.html">MediaObject</a> has changed. The <i>oldstate</i> and <i>newstate</i> parameters indicate the previous state and current state of the media object.</p>
<p>If you are only interested in the new state of the media object, you can connect this signal to a slot that accepts only one State argument.</p>
<!-- @@@stateChanged -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn"><a name="stop"></a><span class="type">void</span> MediaObject::<span class="name">stop</span> ()<tt> [slot]</tt></h3>
<p>Requests playback to stop, and the media object to enter the <a href="phonon.html#State-enum">StoppedState</a>. If it was stopped before nothing changes.</p>
<p>This function is asynchronous and the media might not be stopped immediately.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#play">play</a>(), <a href="phonon-mediaobject.html#pause">pause</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@stop -->
<!-- $$$tick[overload1]$$$tickqint64 -->
<h3 class="fn"><a name="tick"></a><span class="type">void</span> MediaObject::<span class="name">tick</span> ( <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>time</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted in intervals defined by the <a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a> property. The current position of the media object in the stream is given by the <i>time</i> parameter. The <i>time</i> is specified in milliseconds.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a>.</p>
<!-- @@@tick -->
<!-- $$$totalTime[overload1]$$$totalTime -->
<h3 class="fn"><a name="totalTime"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> MediaObject::<span class="name">totalTime</span> () const</h3>
<p>Get the total time (in milliseconds) of the file currently being played.</p>
<p>Returns the total time in milliseconds.</p>
<p><b>Warning:</b> The total time is not defined before the media object enters the <a href="phonon.html#State-enum">LoadingState</a>.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a>().</p>
<!-- @@@totalTime -->
<!-- $$$totalTimeChanged[overload1]$$$totalTimeChangedqint64 -->
<h3 class="fn"><a name="totalTimeChanged"></a><span class="type">void</span> MediaObject::<span class="name">totalTimeChanged</span> ( <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>newTotalTime</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted as soon as the total time of the media file is known or has changed. For most non-local media data the total time of the media can only be known after some time. At that time the totalTime function can not return useful information. You have to wait for this signal to know the real total time.</p>
<p><i>newTotalTime</i> is the length of the media file in milliseconds.</p>
<p><b>See also </b><a href="phonon-mediaobject.html#totalTime">totalTime</a>().</p>
<!-- @@@totalTimeChanged -->
</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
