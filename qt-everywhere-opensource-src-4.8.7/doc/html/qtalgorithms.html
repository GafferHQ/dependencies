<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qalgorithms.qdoc -->
  <title>Qt 4.8: &lt;QtAlgorithms&gt; - Generic Algorithms</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#types-of-iterators">Types of Iterators</a></li>
<li class="level2"><a href="#input-iterators">Input Iterators</a></li>
<li class="level2"><a href="#output-iterators">Output Iterators</a></li>
<li class="level2"><a href="#forward-iterators">Forward Iterators</a></li>
<li class="level2"><a href="#bidirectional-iterators">Bidirectional Iterators</a></li>
<li class="level2"><a href="#random-access-iterators">Random Access Iterators</a></li>
</ul>
</div>
<h1 class="title">&lt;QtAlgorithms&gt; - Generic Algorithms</h1>
<span class="subtitle"></span>
<!-- $$$<QtAlgorithms>-brief -->
<p>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms. <a href="#details">More...</a></p>
<!-- @@@<QtAlgorithms> -->
<ul>
</ul>
<a name="Functionsx"></a>
<h2>Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qBinaryFind-2">qBinaryFind</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i>, LessThan <i>lessThan</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qBinaryFind-3">qBinaryFind</a></b> ( const Container &amp; <i>container</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> OutputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qCopy">qCopy</a></b> ( InputIterator <i>begin1</i>, InputIterator <i>end1</i>, OutputIterator <i>begin2</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> BiIterator2 </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qCopyBackward">qCopyBackward</a></b> ( BiIterator1 <i>begin1</i>, BiIterator1 <i>end1</i>, BiIterator2 <i>end2</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qCount">qCount</a></b> ( InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp; <i>value</i>, Size &amp; <i>n</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qCount-2">qCount</a></b> ( const Container &amp; <i>container</i>, const T &amp; <i>value</i>, Size &amp; <i>n</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qDeleteAll">qDeleteAll</a></b> ( ForwardIterator <i>begin</i>, ForwardIterator <i>end</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qDeleteAll-2">qDeleteAll</a></b> ( const Container &amp; <i>c</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qEqual">qEqual</a></b> ( InputIterator1 <i>begin1</i>, InputIterator1 <i>end1</i>, InputIterator2 <i>begin2</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qFill">qFill</a></b> ( ForwardIterator <i>begin</i>, ForwardIterator <i>end</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qFill-2">qFill</a></b> ( Container &amp; <i>container</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> InputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qFind">qFind</a></b> ( InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qFind-2">qFind</a></b> ( const Container &amp; <i>container</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qGreater">qGreater</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qLess">qLess</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qLowerBound">qLowerBound</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qLowerBound-2">qLowerBound</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i>, LessThan <i>lessThan</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qLowerBound-3">qLowerBound</a></b> ( const Container &amp; <i>container</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qSort">qSort</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qSort-2">qSort</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qSort-3">qSort</a></b> ( Container &amp; <i>container</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qStableSort">qStableSort</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qStableSort-2">qStableSort</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qStableSort-3">qStableSort</a></b> ( Container &amp; <i>container</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qSwap">qSwap</a></b> ( T &amp; <i>var1</i>, T &amp; <i>var2</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qUpperBound">qUpperBound</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qUpperBound-2">qUpperBound</a></b> ( RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp; <i>value</i>, LessThan <i>lessThan</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms.html#qUpperBound-3">qUpperBound</a></b> ( const Container &amp; <i>container</i>, const T &amp; <i>value</i> )</td></tr>
</table>
<!-- $$$<QtAlgorithms>-description -->
<div class="descr"> <a name="details"></a>
<p>Qt provides a number of global template functions in <tt>&lt;QtAlgorithms&gt;</tt> that work on containers and perform well-know algorithms. You can use these algorithms with any <a href="containers.html">container class</a> that provides STL-style iterators, including Qt's <a href="qlist.html">QList</a>, <a href="qlinkedlist.html">QLinkedList</a>, <a href="qvector.html">QVector</a>, <a href="qmap.html">QMap</a>, and <a href="qhash.html">QHash</a> classes.</p>
<p>These functions have taken their inspiration from similar functions available in the STL <tt>&lt;algorithm&gt;</tt> header. Most of them have a direct STL equivalent; for example, <a href="qtalgorithms.html#qCopyBackward">qCopyBackward</a>() is the same as STL's copy_backward() algorithm.</p>
<p>If STL is available on all your target platforms, you can use the STL algorithms instead of their Qt counterparts. One reason why you might want to use the STL algorithms is that STL provides dozens and dozens of algorithms, whereas Qt only provides the most important ones, making no attempt to duplicate functionality that is already provided by the C++ standard.</p>
<p>Most algorithms take <a href="containers.html#stl-style-iterators">STL-style iterators</a> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</p>
<p>Let's take the <a href="qtalgorithms.html#qFill">qFill</a>() algorithm as an example. Unlike <a href="qvector.html">QVector</a>, <a href="qlist.html">QList</a> has no fill() function that can be used to fill a list with a particular value. If you need that functionality, you can use <a href="qtalgorithms.html#qFill">qFill</a>():</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 <a href="qtalgorithms.html#qFill">qFill</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;eleven&quot;</span>);
 <span class="comment">// list: [ &quot;eleven&quot;, &quot;eleven&quot;, &quot;eleven&quot; ]</span></pre>
<p><a href="qtalgorithms.html#qFill">qFill</a>() takes a begin iterator, an end iterator, and a value. In the example above, we pass <tt>list.begin()</tt> and <tt>list.end()</tt> as the begin and end iterators, but this doesn't have to be the case:</p>
<pre class="cpp"> <a href="qtalgorithms.html#qFill">qFill</a>(list<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;six&quot;</span>);
 <span class="comment">// list: [ &quot;eleven&quot;, &quot;six&quot;, &quot;six&quot; ]</span></pre>
<p>Different algorithms can have different requirements for the iterators they accept. For example, <a href="qtalgorithms.html#qFill">qFill</a>() accepts two <a href="#forward-iterators">forward iterators</a>. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if <a href="qlist.html#ConstIterator-typedef">QList::ConstIterator</a> is passed as an <a href="#output-iterators">output iterator</a>), you will always get a compiler error, although not necessarily a very informative one.</p>
<p>Some algorithms have special requirements on the value type stored in the containers. For example, <a href="qtalgorithms.html#qEqual">qEqual</a>() requires that the value type supports operator==(), which it uses to compare items. Similarly, <a href="qtalgorithms.html#qDeleteAll">qDeleteAll</a>() requires that the value type is a non-const pointer type (for example, <a href="qwidget.html">QWidget</a> *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</p>
<a name="binaryfind-example"></a><p>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use <a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g&#x2e;, <tt>&amp;amp</tt>;) in the <tt>name_table</tt> array and return the corresponding Unicode value from the <tt>value_table</tt> if the entity is recognized:</p>
<pre class="cpp"> <span class="type"><a href="qchar.html">QChar</a></span> resolveEntity(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>entity)
 {
     <span class="keyword">static</span> <span class="keyword">const</span> QLatin1String name_table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
         <span class="string">&quot;AElig&quot;</span><span class="operator">,</span> <span class="string">&quot;Aacute&quot;</span><span class="operator">,</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">,</span> <span class="string">&quot;zwnj&quot;</span>
     };
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> value_table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
         <span class="number">0x0061</span><span class="operator">,</span> <span class="number">0x00c1</span><span class="operator">,</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">,</span> <span class="number">0x200c</span>
     };
     <span class="type">int</span> N <span class="operator">=</span> <span class="keyword">sizeof</span>(name_table) <span class="operator">/</span> <span class="keyword">sizeof</span>(name_table<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>);

     <span class="keyword">const</span> QLatin1String <span class="operator">*</span>name <span class="operator">=</span> <a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>(name_table<span class="operator">,</span> name_table <span class="operator">+</span> N<span class="operator">,</span>
                                             entity);
     <span class="type">int</span> index <span class="operator">=</span> name <span class="operator">-</span> name_table;
     <span class="keyword">if</span> (index <span class="operator">=</span><span class="operator">=</span> N)
         <span class="keyword">return</span> <span class="type"><a href="qchar.html">QChar</a></span>();

     <span class="keyword">return</span> <span class="type"><a href="qchar.html">QChar</a></span>(value_table<span class="operator">[</span>index<span class="operator">]</span>);
 }</pre>
<p>This kind of code is for advanced users only; for most applications, a <a href="qmap.html">QMap</a>- or <a href="qhash.html">QHash</a>-based approach would work just as well:</p>
<pre class="cpp"> <span class="type"><a href="qchar.html">QChar</a></span> resolveEntity(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>entity)
 {
     <span class="keyword">static</span> <span class="type"><a href="qmap.html">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> entityMap;

     <span class="keyword">if</span> (<span class="operator">!</span>entityMap) {
         entityMap<span class="operator">.</span>insert(<span class="string">&quot;AElig&quot;</span><span class="operator">,</span> <span class="number">0x0061</span>);
         entityMap<span class="operator">.</span>insert(<span class="string">&quot;Aacute&quot;</span><span class="operator">,</span> <span class="number">0x00c1</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         entityMap<span class="operator">.</span>insert(<span class="string">&quot;zwnj&quot;</span><span class="operator">,</span> <span class="number">0x200c</span>);
     }
     <span class="keyword">return</span> <span class="type"><a href="qchar.html">QChar</a></span>(entityMap<span class="operator">.</span>value(entity));
 }</pre>
<a name="types-of-iterators"></a>
<h2>Types of Iterators</h2>
<p>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</p>
<a name="input-iterators"></a>
<h3>Input Iterators</h3>
<p>An <i>input iterator</i> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: <tt>==</tt> and <tt>!=</tt> for comparing two iterators, unary <tt>*</tt> for retrieving the value stored in the item, and prefix <tt>++</tt> for advancing to the next item.</p>
<p>The Qt containers' iterator types (const and non-const) are all input iterators.</p>
<a name="output-iterators"></a>
<h3>Output Iterators</h3>
<p>An <i>output iterator</i> is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary <tt>*</tt> for writing a value (i.e&#x2e;, <tt>*it = val</tt>) and prefix <tt>++</tt> for advancing to the next item.</p>
<p>The Qt containers' non-const iterator types are all output iterators.</p>
<a name="forward-iterators"></a>
<h3>Forward Iterators</h3>
<p>A <i>forward iterator</i> is an iterator that meets the requirements of both input iterators and output iterators.</p>
<p>The Qt containers' non-const iterator types are all forward iterators.</p>
<a name="bidirectional-iterators"></a>
<h3>Bidirectional Iterators</h3>
<p>A <i>bidirectional iterator</i> is an iterator that meets the requirements of forward iterators but that in addition supports prefix <tt>--</tt> for iterating backward.</p>
<p>The Qt containers' non-const iterator types are all bidirectional iterators.</p>
<a name="random-access-iterators"></a>
<h3>Random Access Iterators</h3>
<p>The last category, <i>random access iterators</i>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</p>
<table class="generic">
<tr valign="top" class="odd"><td ><tt>i += n</tt></td><td >advances iterator <tt>i</tt> by <tt>n</tt> positions</td></tr>
<tr valign="top" class="even"><td ><tt>i -= n</tt></td><td >moves iterator <tt>i</tt> back by <tt>n</tt> positions</td></tr>
<tr valign="top" class="odd"><td ><tt>i + n</tt> or <tt>n + i</tt></td><td >returns the iterator for the item <tt>n</tt> positions ahead of iterator <tt>i</tt></td></tr>
<tr valign="top" class="even"><td ><tt>i - n</tt></td><td >returns the iterator for the item <tt>n</tt> positions behind of iterator <tt>i</tt></td></tr>
<tr valign="top" class="odd"><td ><tt>i - j</tt></td><td >returns the number of items between iterators <tt>i</tt> and <tt>j</tt></td></tr>
<tr valign="top" class="even"><td ><tt>i[n]</tt></td><td >same as <tt>*(i + n)</tt></td></tr>
<tr valign="top" class="odd"><td ><tt>i &lt; j</tt></td><td >returns true if iterator <tt>j</tt> comes after iterator <tt>i</tt></td></tr>
</table>
<p><a href="qlist.html">QList</a> and <a href="qvector.html">QVector</a>'s non-const iterator types are random access iterators.</p>
</div>
<p><b>See also </b><a href="containers.html">container classes</a> and <a href="qtglobal.html">&lt;QtGlobal&gt;</a>.</p>
<!-- @@@<QtAlgorithms> -->
<h2>Function Documentation</h2>
<!-- $$$qBinaryFind[overload1]$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn"><a name="qBinaryFind"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of an occurrence of <i>value</i>. If there are no occurrences of <i>value</i>, returns <i>end</i>.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<p>If there are many occurrences of the same value, any one of them could be returned. Use <a href="qtalgorithms.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms.html#qUpperBound">qUpperBound</a>() if you need finer control.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
 vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span>
         qBinaryFind(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
 <span class="comment">// i == vect.begin() + 2 (or 3 or 4)</span></pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <tt>operator&lt;()</tt>.</p>
<p>See the <a href="qtalgorithms.html#binaryfind-example">detailed description</a> for an example usage.</p>
<p><b>See also </b><a href="qtalgorithms.html#qLowerBound">qLowerBound</a>(), <a href="qtalgorithms.html#qUpperBound">qUpperBound</a>(), and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn"><a name="qBinaryFind-2"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i>, <span class="type">LessThan</span> <i>lessThan</i> )</h3>
<p>This is an overloaded function.</p>
<p>Uses the <i>lessThan</i> function instead of <tt>operator&lt;()</tt> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindconstContainer&constT& -->
<h3 class="fn"><a name="qBinaryFind-3"></a><span class="type">Container::const_iterator</span> <span class="name">qBinaryFind</span> ( const <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qBinaryFind(<i>container</i>.begin(), <i>container</i>.end(), value);</p>
<!-- @@@qBinaryFind -->
<!-- $$$qCopy[overload1]$$$qCopyInputIteratorInputIteratorOutputIterator -->
<h3 class="fn"><a name="qCopy"></a><span class="type">OutputIterator</span> <span class="name">qCopy</span> ( <span class="type">InputIterator</span> <i>begin1</i>, <span class="type">InputIterator</span> <i>end1</i>, <span class="type">OutputIterator</span> <i>begin2</i> )</h3>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [<i>begin2</i>, ..&#x2e;), in the order in which they appear.</p>
<p>The item at position <i>begin1</i> is assigned to that at position <i>begin2</i>; the item at position <i>begin1</i> + 1 is assigned to that at position <i>begin2</i> + 1; and so on.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect1(<span class="number">3</span>);
 qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect1<span class="operator">.</span>begin());
 <span class="comment">// vect: [ &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span>

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect2(<span class="number">8</span>);
 qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect2<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">2</span>);
 <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qCopyBackward">qCopyBackward</a>(), <a href="qtalgorithms.html#input-iterators">input iterators</a>, and <a href="qtalgorithms.html#output-iterators">output iterators</a>.</p>
<!-- @@@qCopy -->
<!-- $$$qCopyBackward[overload1]$$$qCopyBackwardBiIterator1BiIterator1BiIterator2 -->
<h3 class="fn"><a name="qCopyBackward"></a><span class="type">BiIterator2</span> <span class="name">qCopyBackward</span> ( <span class="type">BiIterator1</span> <i>begin1</i>, <span class="type">BiIterator1</span> <i>end1</i>, <span class="type">BiIterator2</span> <i>end2</i> )</h3>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [..&#x2e;, <i>end2</i>).</p>
<p>The item at position <i>end1</i> - 1 is assigned to that at position <i>end2</i> - 1; the item at position <i>end1</i> - 2 is assigned to that at position <i>end2</i> - 2; and so on.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">5</span>);
 qCopyBackward(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>end());
 <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qCopy">qCopy</a>() and <a href="qtalgorithms.html#bidirectional-iterators">bidirectional iterators</a>.</p>
<!-- @@@qCopyBackward -->
<!-- $$$qCount[overload1]$$$qCountInputIteratorInputIteratorconstT&Size& -->
<h3 class="fn"><a name="qCount"></a><span class="type">void</span> <span class="name">qCount</span> ( <span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i>, <span class="type">Size</span> &amp; <i>n</i> )</h3>
<p>Returns the number of occurrences of <i>value</i> in the range [<i>begin</i>, <i>end</i>), which is returned in <i>n</i>. <i>n</i> is never initialized, the count is added to <i>n</i>. It is the caller's responsibility to initialize <i>n</i>.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

 <span class="type">int</span> countOf6 <span class="operator">=</span> <span class="number">0</span>;
 qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> countOf6);
 <span class="comment">// countOf6 == 3</span>

 <span class="type">int</span> countOf7 <span class="operator">=</span> <span class="number">0</span>;
 qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> countOf7);
 <span class="comment">// countOf7 == 0</span></pre>
<p>This function requires the item type (in the example above, <tt>int</tt>) to implement <tt>operator==()</tt>.</p>
<p><b>See also </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qCount -->
<!-- $$$qCount$$$qCountconstContainer&constT&Size& -->
<h3 class="fn"><a name="qCount-2"></a><span class="type">void</span> <span class="name">qCount</span> ( const <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i>, <span class="type">Size</span> &amp; <i>n</i> )</h3>
<p>This is an overloaded function.</p>
<p>Instead of operating on iterators, as in the other overload, this function operates on the specified <i>container</i> to obtain the number of instances of <i>value</i> in the variable passed as a reference in argument <i>n</i>.</p>
<!-- @@@qCount -->
<!-- $$$qDeleteAll[overload1]$$$qDeleteAllForwardIteratorForwardIterator -->
<h3 class="fn"><a name="qDeleteAll"></a><span class="type">void</span> <span class="name">qDeleteAll</span> ( <span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i> )</h3>
<p>Deletes all the items in the range [<i>begin</i>, <i>end</i>) using the C++ <tt>delete</tt> operator. The item type must be a pointer type (for example, <tt>QWidget *</tt>).</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span>Employee <span class="operator">*</span><span class="operator">&gt;</span> list;
 list<span class="operator">.</span>append(<span class="keyword">new</span> Employee(<span class="string">&quot;Blackpool&quot;</span><span class="operator">,</span> <span class="string">&quot;Stephen&quot;</span>));
 list<span class="operator">.</span>append(<span class="keyword">new</span> Employee(<span class="string">&quot;Twist&quot;</span><span class="operator">,</span> <span class="string">&quot;Oliver&quot;</span>));

 qDeleteAll(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
 list<span class="operator">.</span>clear();</pre>
<p>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls <tt>delete</tt> on them. In the example above, we call clear() on the container to remove the items.</p>
<p>This function can also be used to delete items stored in associative containers, such as <a href="qmap.html">QMap</a> and <a href="qhash.html">QHash</a>. Only the objects stored in each container will be deleted by this function; objects used as keys will not be deleted.</p>
<p><b>See also </b><a href="qtalgorithms.html#forward-iterators">forward iterators</a>.</p>
<!-- @@@qDeleteAll -->
<!-- $$$qDeleteAll$$$qDeleteAllconstContainer& -->
<h3 class="fn"><a name="qDeleteAll-2"></a><span class="type">void</span> <span class="name">qDeleteAll</span> ( const <span class="type">Container</span> &amp; <i>c</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qDeleteAll(<i>c</i>.begin(), <i>c</i>.end()).</p>
<!-- @@@qDeleteAll -->
<!-- $$$qEqual[overload1]$$$qEqualInputIterator1InputIterator1InputIterator2 -->
<h3 class="fn"><a name="qEqual"></a><span class="type">bool</span> <span class="name">qEqual</span> ( <span class="type">InputIterator1</span> <i>begin1</i>, <span class="type">InputIterator1</span> <i>end1</i>, <span class="type">InputIterator2</span> <i>begin2</i> )</h3>
<p>Compares the items in the range [<i>begin1</i>, <i>end1</i>) with the items in the range [<i>begin2</i>, ..&#x2e;)&#x2e; Returns true if all the items compare equal; otherwise returns false.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">3</span>);
 vect<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;one&quot;</span>;
 vect<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;two&quot;</span>;
 vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;three&quot;</span>;

 <span class="type">bool</span> ret1 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
 <span class="comment">// ret1 == true</span>

 vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;seven&quot;</span>;
 <span class="type">bool</span> ret2 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
 <span class="comment">// ret2 == false</span></pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <tt>operator==()</tt>.</p>
<p><b>See also </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qEqual -->
<!-- $$$qFill[overload1]$$$qFillForwardIteratorForwardIteratorconstT& -->
<h3 class="fn"><a name="qFill"></a><span class="type">void</span> <span class="name">qFill</span> ( <span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Fills the range [<i>begin</i>, <i>end</i>) with <i>value</i>.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 qFill(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;eleven&quot;</span>);
 <span class="comment">// list: [ &quot;eleven&quot;, &quot;eleven&quot;, &quot;eleven&quot; ]</span>

 qFill(list<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;six&quot;</span>);
 <span class="comment">// list: [ &quot;eleven&quot;, &quot;six&quot;, &quot;six&quot; ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qCopy">qCopy</a>() and <a href="qtalgorithms.html#forward-iterators">forward iterators</a>.</p>
<!-- @@@qFill -->
<!-- $$$qFill$$$qFillContainer&constT& -->
<h3 class="fn"><a name="qFill-2"></a><span class="type">void</span> <span class="name">qFill</span> ( <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qFill(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qFill -->
<!-- $$$qFind[overload1]$$$qFindInputIteratorInputIteratorconstT& -->
<h3 class="fn"><a name="qFind"></a><span class="type">InputIterator</span> <span class="name">qFind</span> ( <span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Returns an iterator to the first occurrence of <i>value</i> in a container in the range [<i>begin</i>, <i>end</i>). Returns <i>end</i> if <i>value</i> isn't found.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

 <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i1 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;two&quot;</span>);
 <span class="comment">// i1 == list.begin() + 1</span>

 <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i2 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;seventy&quot;</span>);
 <span class="comment">// i2 == list.end()</span></pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <tt>operator==()</tt>.</p>
<p>If the items in the range are in ascending order, you can get faster results by using <a href="qtalgorithms.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>() instead of qFind().</p>
<p><b>See also </b><a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>() and <a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qFind -->
<!-- $$$qFind$$$qFindconstContainer&constT& -->
<h3 class="fn"><a name="qFind-2"></a><span class="type">Container::const_iterator</span> <span class="name">qFind</span> ( const <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qFind(<i>container</i>.constBegin(), <i>container</i>.constEnd(), value);</p>
<!-- @@@qFind -->
<!-- $$$qGreater[overload1]$$$qGreater -->
<h3 class="fn"><a name="qGreater"></a><span class="type">LessThan</span> <span class="name">qGreater</span> ()</h3>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms.html#qSort">qSort</a>() or <a href="qtalgorithms.html#qStableSort">qStableSort</a>().</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 <a href="qtalgorithms.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qGreater<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
 <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qLess">qLess&lt;T&gt;</a>().</p>
<!-- @@@qGreater -->
<!-- $$$qLess[overload1]$$$qLess -->
<h3 class="fn"><a name="qLess"></a><span class="type">LessThan</span> <span class="name">qLess</span> ()</h3>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms.html#qSort">qSort</a>() or <a href="qtalgorithms.html#qStableSort">qStableSort</a>().</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 <a href="qtalgorithms.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qLess<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
 <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qGreater">qGreater&lt;T&gt;</a>().</p>
<!-- @@@qLess -->
<!-- $$$qLowerBound[overload1]$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn"><a name="qLowerBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the first ocurrence of <i>value</i>. If no such item is found, returns the position where it should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
 list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
 <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

 i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
 list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
 <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span></pre>
<p>This function requires the item type (in the example above, <tt>int</tt>) to implement <tt>operator&lt;()</tt>.</p>
<p>qLowerBound() can be used in conjunction with <a href="qtalgorithms.html#qUpperBound">qUpperBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp"> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
 vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
         qLowerBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
         <a href="qtalgorithms.html#qUpperBound">qUpperBound</a>(begin6<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
     <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
 <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qUpperBound">qUpperBound</a>() and <a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn"><a name="qLowerBound-2"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i>, <span class="type">LessThan</span> <i>lessThan</i> )</h3>
<p>This is an overloaded function.</p>
<p>Uses the <i>lessThan</i> function instead of <tt>operator&lt;()</tt> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundconstContainer&constT& -->
<h3 class="fn"><a name="qLowerBound-3"></a><span class="type">Container::const_iterator</span> <span class="name">qLowerBound</span> ( const <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>For read-only iteration over containers, this function is broadly equivalent to qLowerBound(<i>container</i>.begin(), <i>container</i>.end(), value). However, since it returns a const iterator, you cannot use it to modify the container; for example, to insert items.</p>
<!-- @@@qLowerBound -->
<!-- $$$qSort[overload1]$$$qSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn"><a name="qSort"></a><span class="type">void</span> <span class="name">qSort</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i> )</h3>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using the quicksort algorithm.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 qSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
 <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span></pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <tt>int</tt>) to implement <tt>operator&lt;()</tt>.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p><b>See also </b><a href="qtalgorithms.html#qStableSort">qStableSort</a>() and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn"><a name="qSort-2"></a><span class="type">void</span> <span class="name">qSort</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i> )</h3>
<p>This is an overloaded function.</p>
<p>Uses the <i>lessThan</i> function instead of <tt>operator&lt;()</tt> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp"> <span class="type">bool</span> caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
 {
     <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
 }

 <span class="type">int</span> doSomething()
 {
     <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
     list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
     <a href="qtalgorithms.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
     <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
 }</pre>
<p>To sort values in reverse order, pass <a href="qtalgorithms.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 <a href="qtalgorithms.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
 <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span></pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p>An alternative to using <a href="qtalgorithms.html#qSort">qSort</a>() is to put the items to sort in a <a href="qmap.html">QMap</a>, using the sort key as the <a href="qmap.html">QMap</a> key. This is often more convenient than defining a <i>lessThan</i> function. For example, the following code shows how to sort a list of strings case insensitively using <a href="qmap.html">QMap</a>:</p>
<pre class="cpp"> <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;

 <span class="type"><a href="qmap.html">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> map;
 <a href="qtglobal.html#foreach">foreach</a> (<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>str<span class="operator">,</span> list)
     map<span class="operator">.</span>insert(str<span class="operator">.</span>toLower()<span class="operator">,</span> str);

 list <span class="operator">=</span> map<span class="operator">.</span>values();</pre>
<p><b>See also </b><a href="qmap.html">QMap</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortContainer& -->
<h3 class="fn"><a name="qSort-3"></a><span class="type">void</span> <span class="name">qSort</span> ( <span class="type">Container</span> &amp; <i>container</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qSort(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qSort -->
<!-- $$$qStableSort[overload1]$$$qStableSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn"><a name="qStableSort"></a><span class="type">void</span> <span class="name">qStableSort</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i> )</h3>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using a stable sorting algorithm.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 qStableSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
 <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span></pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <tt>int</tt>) to implement <tt>operator&lt;()</tt>.</p>
<p><b>See also </b><a href="qtalgorithms.html#qSort">qSort</a>() and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn"><a name="qStableSort-2"></a><span class="type">void</span> <span class="name">qStableSort</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i> )</h3>
<p>This is an overloaded function.</p>
<p>Uses the <i>lessThan</i> function instead of <tt>operator&lt;()</tt> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp"> <span class="type">bool</span> caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
 {
     <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
 }

 <span class="type">int</span> doSomething()
 {
     <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
     list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
     <a href="qtalgorithms.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
     <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
 }</pre>
<p>Note that earlier versions of Qt allowed using a lessThan function that took its arguments by non-const reference. From 4.3 and on this is no longer possible, the arguments has to be passed by const reference or value.</p>
<p>To sort values in reverse order, pass <a href="qtalgorithms.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
 <a href="qtalgorithms.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
 <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span></pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortContainer& -->
<h3 class="fn"><a name="qStableSort-3"></a><span class="type">void</span> <span class="name">qStableSort</span> ( <span class="type">Container</span> &amp; <i>container</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qStableSort(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qStableSort -->
<!-- $$$qSwap[overload1]$$$qSwapT&T& -->
<h3 class="fn"><a name="qSwap"></a><span class="type">void</span> <span class="name">qSwap</span> ( <span class="type">T</span> &amp; <i>var1</i>, <span class="type">T</span> &amp; <i>var2</i> )</h3>
<p>Exchanges the values of variables <i>var1</i> and <i>var2</i>.</p>
<p>Example:</p>
<pre class="cpp"> <span class="type">double</span> pi <span class="operator">=</span> <span class="number">3.14</span>;
 <span class="type">double</span> e <span class="operator">=</span> <span class="number">2.71</span>;

 qSwap(pi<span class="operator">,</span> e);
 <span class="comment">// pi == 2.71, e == 3.14</span></pre>
<!-- @@@qSwap -->
<!-- $$$qUpperBound[overload1]$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn"><a name="qUpperBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the one-past-the-last occurrence of <i>value</i>. If no such item is found, returns the position where the item should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<p>Example:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
 list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
 <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

 i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
 list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
 <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span></pre>
<p>This function requires the item type (in the example above, <tt>int</tt>) to implement <tt>operator&lt;()</tt>.</p>
<p>qUpperBound() can be used in conjunction with <a href="qtalgorithms.html#qLowerBound">qLowerBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp"> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
 vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
         <a href="qtalgorithms.html#qLowerBound">qLowerBound</a>(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
         qUpperBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
     <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
 <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span></pre>
<p><b>See also </b><a href="qtalgorithms.html#qLowerBound">qLowerBound</a>() and <a href="qtalgorithms.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn"><a name="qUpperBound-2"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span> ( <span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp; <i>value</i>, <span class="type">LessThan</span> <i>lessThan</i> )</h3>
<p>This is an overloaded function.</p>
<p>Uses the <i>lessThan</i> function instead of <tt>operator&lt;()</tt> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundconstContainer&constT& -->
<h3 class="fn"><a name="qUpperBound-3"></a><span class="type">Container::const_iterator</span> <span class="name">qUpperBound</span> ( const <span class="type">Container</span> &amp; <i>container</i>, const <span class="type">T</span> &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>This is the same as qUpperBound(<i>container</i>.begin(), <i>container</i>.end(), value);</p>
<!-- @@@qUpperBound -->
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
