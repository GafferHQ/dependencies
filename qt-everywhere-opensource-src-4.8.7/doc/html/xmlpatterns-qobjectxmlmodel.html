<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qobjectxmlmodel.qdoc -->
  <title>Qt 4.8: QObject XML Model Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="all-examples.html">Examples</a></li>
<li>QObject XML Model Example</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level2"><a href="#the-user-interface">The User Interface</a></li>
<li class="level1"><a href="#code-walk-through">Code Walk-Through</a></li>
<li class="level2"><a href="#the-custom-node-model-class-qobjextxmlmodel">The Custom Node Model Class: QObjextXmlModel</a></li>
<li class="level3"><a href="#accessing-the-node-model">Accessing The Node Model</a></li>
<li class="level3"><a href="#traversing-the-node-model">Traversing The Node Model</a></li>
<li class="level3"><a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a></li>
</ul>
</div>
<h1 class="title">QObject XML Model Example</h1>
<span class="subtitle"></span>
<!-- $$$xmlpatterns/qobjectxmlmodel-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="xmlpatterns-qobjectxmlmodel-mainwindow-cpp.html">xmlpatterns/qobjectxmlmodel/mainwindow.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-mainwindow-h.html">xmlpatterns/qobjectxmlmodel/mainwindow.h</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-cpp.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-h.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.h</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-forms-mainwindow-ui.html">xmlpatterns/qobjectxmlmodel/forms/mainwindow.ui</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-statisticsinhtml-xq.html">xmlpatterns/qobjectxmlmodel/queries/statisticsInHTML.xq</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-wholetree-xq.html">xmlpatterns/qobjectxmlmodel/queries/wholeTree.xq</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-main-cpp.html">xmlpatterns/qobjectxmlmodel/main.cpp</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-qobjectxmlmodel-pro.html">xmlpatterns/qobjectxmlmodel/qobjectxmlmodel.pro</a></li>
<li><a href="xmlpatterns-qobjectxmlmodel-queries-qrc.html">xmlpatterns/qobjectxmlmodel/queries.qrc</a></li>
</ul>
<p>The XML Model example shows how to use <a href="qtxmlpatterns.html">QtXmlPatterns</a> to query <a href="qobject.html">QObject</a> trees by modeling the non-XML data structure of a <a href="qobject.html">QObject</a> tree to look like XML.<a name="introduction"></a>
<h2>Introduction</h2>
<p>This example illustrates two important points about using <a href="xmlprocessing.html">XQuery</a> to query non-XML data modeled to look like XML. The first point is that a custom node model class doesn't always have to actually build the node model. Sometimes the node model can be an already existing data structure, like the <a href="qobject.html">QObject</a> tree used in this example. The second point is to explain what is required to make non-XML data look like XML.</p>
<p>In this example, we want to model a <a href="qobject.html">QObject</a> tree to look like XML. That is easy to do because a <a href="qobject.html">QObject</a> tree maps to the XML tree structure in a staightforward way. Each <a href="qobject.html">QObject</a> node is modeled as an XML element node. However, when we want to add the <a href="qmetaobject.html">QMetaObject</a> tree to the <a href="qobject.html">QObject</a> tree node model, we are trying to add a second tree to the node model. The <a href="qmetaobject.html">QMetaObject</a> tree exists <i>behind</i> the <a href="qobject.html">QObject</a> tree. Adding the <a href="qmetaobject.html">QMetaObject</a> tree to the node model changes the two dimensional tree into a three dimensional tree.</p>
<p>The query engine can only traverse two dimensional trees, because an XML document is always a two dimensional tree. If we want to add the <a href="qmetaobject.html">QMetaObject</a> tree to the node model, we have to somehow flatten it into the same plane as the <a href="qobject.html">QObject</a> tree. This requires that the node model class must build an auxiliary data structure and make it part of the two dimensional <a href="qobject.html">QObject</a> node model. How to do this is explained in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="the-user-interface"></a>
<h3>The User Interface</h3>
<p>The UI for this example was created using Qt Designer:</p>
<p class="centerAlign"><img src="images/qobjectxmlmodel-example.png" alt="" /></p><a name="code-walk-through"></a>
<h2>Code Walk-Through</h2>
<p>The strategy for this example is different from the strategy for the <a href="xmlpatterns-filetree.html">file system example</a>. In the file system example, the node model class had to actually build a node model because the non-XML data to be traversed was the computer's file system, a structure stored on disk in a form that the query engine couldn't use. The node model class had to build an analog of the computer's file system in memory.</p>
<p>For this example, the data structure to be traversed already exists in memory in a usable form. It is the <a href="qobject.html">QObject</a> tree of the example application itself. All we need is the pointer to the root of the <a href="qobject.html">QObject</a> tree.</p>
<p><b>Note:</b> When we add the <a href="qmetaobject.html">QMetaObject</a> tree to the node model, the node model class will have to build an auxiliary data structure to move the <a href="qmetaobject.html">QMetaObject</a> tree into the same plane as the <a href="qobject.html">QObject</a> tree. This is explained later in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="the-custom-node-model-class-qobjextxmlmodel"></a>
<h3>The Custom Node Model Class: QObjextXmlModel</h3>
<p>The node model class for this example is QObjextXmlModel, which is derived from <a href="qsimplexmlnodemodel.html">QSimpleXmlNodeModel</a>. QObjextXmlModel implements the callback interface functions that don't have implementations in <a href="qsimplexmlnodemodel.html">QSimpleXmlNodeModel</a>:</p>
<pre class="cpp">     <span class="keyword">virtual</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">::</span>DocumentOrder compareOrder(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n2) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qxmlname.html">QXmlName</a></span> name(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qurl.html">QUrl</a></span> documentUri(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">::</span>NodeKind kind(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> root(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qvariant.html">QVariant</a></span> typedValue(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&gt;</span> attributes(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&amp;</span>) <span class="keyword">const</span>;
     <span class="keyword">virtual</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> nextFromSimpleAxis(SimpleAxis<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&amp;</span>) <span class="keyword">const</span>;</pre>
<p>The node model class declares three data members:</p>
<a name="three-data-members"></a><pre class="cpp">     <span class="keyword">const</span> <span class="type"><a href="qurl.html">QUrl</a></span>              m_baseURI;
     <span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span><span class="keyword">const</span>          m_root;
     <span class="keyword">const</span> AllMetaObjects    m_allMetaObjects;</pre>
<p>The constructor sets <tt>m_baseURI</tt> to the <a href="qurl.html">QUrl</a> constructed from the <a href="qcoreapplication.html#applicationFilePath">file path</a> of the application executable. This is the value returned by <a href="qabstractxmlnodemodel.html#documentUri">documentUri()</a>. The constructor sets <tt>m_root</tt> to point to the <a href="qobject.html">QObject</a> tree for the example application. This is the node model that the query engine will use. And the constructor calls a local function to build the auxiliary data structure (<tt>m_allMetaObjects</tt>) for including the <a href="qmetaobject.html">QMetaObject</a> tree in the node model. How this auxiliary data structure is incorporated into the <a href="qobject.html">QObject</a> node model is discussed in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<a name="accessing-the-node-model"></a>
<h4>Accessing The Node Model</h4>
<p>Since the query engine knows nothing about <a href="qobject.html">QObject</a> trees, it can only access them by calling functions in the node model callback interface. The query engine passes a <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> to uniquely identify a node in the node model. The <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> is constructed from a pointer to the <a href="qobject.html">QObject</a> that represents the node. <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> creates the <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a>, as in the local <tt>root()</tt> function, for example:</p>
<pre class="cpp"> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>root() <span class="keyword">const</span>
 {
     <span class="keyword">return</span> createIndex(m_root);
 }</pre>
<p>A <a href="qobject.html">QObject</a> represents an element node in the node model, but we also need to represent attribute nodes. For example, the class name of a <a href="qobject.html">QObject</a> is an attribute of the <a href="qobject.html">QObject</a>, so it should be an attribute node in the node model. A <a href="qobject.html">QObject</a>'s class name is obtained from the <a href="qobject.html">QObject</a>. (Actually, it is in the <a href="qmetaobject.html">QMetaObject</a>, which is obtained from the <a href="qobject.html">QObject</a>). This means that a single <a href="qobject.html">QObject</a> logically represents multiple nodes in the node model: the element node and potentially many attribute nodes.</p>
<p>To uniquely identify an attribute node, we need the pointer to the <a href="qobject.html">QObject</a> containing the attribute, and an additional value that identifies the attribute in the <a href="qobject.html">QObject</a>. For this <i>additional data</i> value, we use <tt>enum QObjectNodeType</tt>:</p>
<pre class="cpp">     <span class="keyword">enum</span> <span class="type">QObjectNodeType</span>
     {
         IsQObject               <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span>
         <span class="type">QObjectProperty</span>         <span class="operator">=</span> <span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span><span class="operator">,</span>
         MetaObjects             <span class="operator">=</span> <span class="number">2</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span><span class="operator">,</span>
         MetaObject              <span class="operator">=</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span><span class="operator">,</span>
         MetaObjectClassName     <span class="operator">=</span> <span class="number">4</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span><span class="operator">,</span>
         MetaObjectSuperClass    <span class="operator">=</span> <span class="number">5</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span><span class="operator">,</span>
         <span class="type">QObjectClassName</span>        <span class="operator">=</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span>
     };</pre>
<p>Ignore the <tt>MetaObjectXXX</tt> values for now. They will be explained in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>. Here we are interested in the three node types for <a href="qobject.html">QObject</a> nodes: <tt>IsQObject</tt>, which represents the element node type for a <a href="qobject.html">QObject</a>, and <tt>QObjectProperty</tt> and <tt>QObjectClassName</tt>, which represent the attribute node types for the attributes of a <a href="qobject.html">QObject</a>.</p>
<p>The <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> function called in the <tt>root()</tt> snippet above is the overload that accepts a <tt>void*</tt> pointer and a second parameter, <tt>additionalData</tt>, with default value 0 (<tt>IsQObject</tt>). Wherever you see a call to <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> that only passes the <a href="qobject.html">QObject</a> pointer, it is creating the node index for a <a href="qobject.html">QObject</a> element node. To create the node index for the class name attribute, for example, the <a href="#qobject-attributes">attributes()</a> function uses <tt>createIndex(object,QObjectClassName)</tt>.</p>
<a name="qobject-attributes"></a><pre class="cpp"> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&gt;</span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>attributes(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&amp;</span> n) <span class="keyword">const</span>
 {
      <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&gt;</span> result;
      <span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span><span class="keyword">const</span> object <span class="operator">=</span> asQObject(n);

      <span class="keyword">switch</span>(toNodeType(n))
      {
         <span class="keyword">case</span> IsQObject:
         {
             <span class="keyword">const</span> <span class="type"><a href="qmetaobject.html">QMetaObject</a></span> <span class="operator">*</span><span class="keyword">const</span> metaObject <span class="operator">=</span> object<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
             <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount();
             result<span class="operator">.</span>append(createIndex(object<span class="operator">,</span> <span class="type">QObjectClassName</span>));

             <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; <span class="operator">+</span><span class="operator">+</span>i) {
                 <span class="keyword">const</span> <span class="type"><a href="qmetaproperty.html">QMetaProperty</a></span> qmp(metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i));
                 <span class="keyword">const</span> <span class="type">int</span> ii <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>indexOfProperty(qmp<span class="operator">.</span>name());
                 <span class="keyword">if</span> (i <span class="operator">=</span><span class="operator">=</span> ii)
                     result<span class="operator">.</span>append(createIndex(object<span class="operator">,</span> <span class="type">QObjectProperty</span> <span class="operator">|</span> i));
             }
             <span class="keyword">return</span> result;
         }
         <span class="keyword">default</span>:
             <span class="keyword">return</span> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span><span class="operator">&gt;</span>();
      }
 }</pre>
<p><a href="#qobject-attributes">attributes()</a> is one of the callback functions you have to implement in your custom node model class. It returns a <a href="qvector.html">QVector</a> of <a href="qxmlnodemodelindex.html">node indexes</a> for all the attribute nodes for <a href="qobject.html">QObject</a> <tt>n</tt>. It calls <a href="qabstractxmlnodemodel.html#createIndex">createIndex()</a> in two places. Both calls use the <a href="qobject.html">QObject</a> pointer from the current node <tt>n</tt> (the element node), and just add a different value for the <i>additional data</i> parameter. This makes sense because, in XML, the attributes of an element are part of that element.</p>
<a name="traversing-the-node-model"></a>
<h4>Traversing The Node Model</h4>
<p>The query engine traverses the <a href="qobject.html">QObject</a> tree by calling back to the node model class's implementation of <a href="#qobject-nextfromsimpleaxis">nextFromSimpleAxis()</a>. This function is the heart of the callback interface, and it will probably be the most complex to implement in your custom node model class. Below is a partial listing of the implementation for this example. The full listing will be shown in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>, where we discuss traversing the <a href="qmetaobject.html">QMetaObject</a> tree.</p>
<a name="qobject-nextfromsimpleaxis"></a><pre class="cpp"> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>nextFromSimpleAxis(SimpleAxis axis<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>
 {
     <span class="keyword">switch</span> (toNodeType(n))
     {
         <span class="keyword">case</span> IsQObject:
         {
             <span class="keyword">switch</span> (axis)
             {
                 <span class="keyword">case</span> Parent:
                     <span class="keyword">return</span> createIndex(asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>parent());

                 <span class="keyword">case</span> FirstChild:
                 {
                     <span class="keyword">if</span> (<span class="operator">!</span>asQObject(n) <span class="operator">|</span><span class="operator">|</span> asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>children()<span class="operator">.</span>isEmpty())
                         <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                     <span class="keyword">else</span>
                         <span class="keyword">return</span> createIndex(asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>children()<span class="operator">.</span>first());
                 }

                 <span class="keyword">case</span> NextSibling:
                     <span class="keyword">return</span> qObjectSibling(<span class="number">1</span><span class="operator">,</span> n);

                 <span class="keyword">case</span> PreviousSibling:
                 {
                     <span class="keyword">if</span> (asQObject(n) <span class="operator">=</span><span class="operator">=</span> m_root)
                         <span class="keyword">return</span> createIndex(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span>(<span class="number">0</span>)<span class="operator">,</span> MetaObjects);
                     <span class="keyword">else</span>
                         <span class="keyword">return</span> qObjectSibling(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> n);
                 }
             }
             Q_ASSERT(<span class="keyword">false</span>);
         }

         <span class="keyword">case</span> <span class="type">QObjectClassName</span>:
         <span class="keyword">case</span> <span class="type">QObjectProperty</span>:
         {
             Q_ASSERT(axis <span class="operator">=</span><span class="operator">=</span> Parent);
             <span class="keyword">return</span> createIndex(asQObject(n));
         }
     }

     Q_ASSERT(<span class="keyword">false</span>);
     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
 }</pre>
<p>The main switch uses <tt>toNodeType()</tt>, which obtains the node type from <a href="qxmlnodemodelindex.html#additionalData">QXmlNodeModelIndex::additionalData</a>():</p>
<pre class="cpp"> <span class="type">QObjectXmlModel</span><span class="operator">::</span><span class="type">QObjectNodeType</span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>toNodeType(<span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n)
 {
     <span class="keyword">return</span> <span class="type">QObjectNodeType</span>(n<span class="operator">.</span>additionalData() <span class="operator">&amp;</span> (<span class="number">15</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">26</span>));
 }</pre>
<p><tt>case IsObject</tt> case is the most interesting. It switches again on the value of the <tt>axis</tt> parameter, which specifies the direction the query engine wants to take from the current node. It is one of the four enum values of <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">QAbstractXmlNodeModel::SimpleAxis</a>. The <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a> and <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">FirstChild</a> cases reduce to calls to <a href="qobject.html#parent">QObject::parent</a>() and <a href="qobject.html#children">QObject::children</a>() respectively. Note that a default constructed <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> is returned in the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a> case if the current node is the root, and in the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">FirstChild</a> case if the current node has no children.</p>
<p>For the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">NextSibling</a> and <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a> axes, the helper function <tt>qObjectSibling()</tt> is called, with +1 to traverse to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">NextSibling</a> and -1 to traverse to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a>.</p>
<pre class="cpp"> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>qObjectSibling(<span class="keyword">const</span> <span class="type">int</span> pos<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>
 {
     Q_ASSERT(pos <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span> <span class="operator">|</span><span class="operator">|</span> pos <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>);
     Q_ASSERT(asQObject(n));

     <span class="keyword">const</span> <span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>parent();
     <span class="keyword">if</span> (parent) {
         <span class="keyword">const</span> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>children <span class="operator">=</span> parent<span class="operator">-</span><span class="operator">&gt;</span>children();
         <span class="keyword">const</span> <span class="type">int</span> siblingPos <span class="operator">=</span> children<span class="operator">.</span>indexOf(asQObject(n)) <span class="operator">+</span> pos;

         <span class="keyword">if</span> (siblingPos <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> siblingPos <span class="operator">&lt;</span> children<span class="operator">.</span>count())
             <span class="keyword">return</span> createIndex(children<span class="operator">.</span>at(siblingPos));
         <span class="keyword">else</span>
             <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
     }
     <span class="keyword">else</span>
         <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
 }</pre>
<p><tt>qObjectSibling()</tt> determines whether or not the node has any siblings. It is called with <tt>n</tt>, the index of the current node. If the current node is a child, then it has a parent with children (the current node one of these). So, we get the <a href="qobject.html#parent">parent</a>, obtain the parent's <a href="qobject.html#children">child list</a>, find the current node in the list, and construct the node index for the next or previous child (sibling) and return it.</p>
<p><b>Note:</b> In <a href="#qobject-nextfromsimpleaxis">nextFromSimpleAxis()</a>, the special case of asking for the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">PreviousSibling</a> of the root node is discussed in <a href="#including-the-qmetaobject-tree">Including The QMetaObject Tree</a>.</p>
<p>Traversing away from a <tt>QObjectClassName</tt> attribute node or a <tt>QObjectProperty</tt> attribute node might seem a bit confusing at first glance. The only move allowed from an attribute node is to the <a href="qabstractxmlnodemodel.html#SimpleAxis-enum">Parent</a>, because attribute nodes don't have children. But these two cases simply return the <a href="qxmlnodemodelindex.html">node index</a> of the current node.</p>
<pre class="cpp">         <span class="keyword">case</span> <span class="type">QObjectClassName</span>:
         <span class="keyword">case</span> <span class="type">QObjectProperty</span>:
         {
             Q_ASSERT(axis <span class="operator">=</span><span class="operator">=</span> Parent);
             <span class="keyword">return</span> createIndex(asQObject(n));
         }</pre>
<p>Since <tt>n</tt> is the <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> of the current node, all this does is create another <a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a> for the current node and return it. This was explained above in <a href="#accessing-the-node-model">Accessing The Node Model</a>, where we saw that each <a href="qobject.html">QObject</a> in the node model actually represents an element node and potentially many attribute nodes. Traversing to the parent node of an attribute simply creates a node index for the same <a href="qobject.html">QObject</a>, but with an <i>additional data</i> value of 0 (<tt>IsQObject</tt>).</p>
<p>If we only wanted to traverse the <a href="qobject.html">QObject</a> tree with <a href="xmlprocessing.html">XQuery</a>, we could just implement the rest of the virtual callback functions listed earlier and we would be done. The implementations for the remaining functions are straightforward. But if we also want to use <a href="xmlprocessing.html">XQuery</a> to traverse the <a href="qmetaobject.html">QMetaObject</a> tree, we must include the <a href="qmetaobject.html">QMetaObject</a> tree in the custom node model.</p>
<a name="including-the-qmetaobject-tree"></a>
<h4>Including The QMetaObject Tree</h4>
<p>The <a href="metaobjects.html#meta-object-system">metaobject system</a> not only enables Qt's <a href="signalsandslots.html#signals-and-slots">signals and slots</a>, it also provides type information that is useful at run-time; e.g&#x2e;, getting and setting properties without knowing the property names at compile time. Each <a href="qobject.html">QObject</a> has an associated <a href="qmetaobject.html">QMetaObject</a> tree which contains all this useful type information. Given a <a href="qobject.html">QObject</a>, its <a href="qmetaobject.html">QMetaObject</a> is obtained with <a href="qobject.html#metaObject">QObject::metaObject</a>(). Then <a href="qmetaobject.html#superClass">QMetaObject::superClass</a>() can be called repeatedly to get the <a href="qmetaobject.html">QMetaObject</a> for each class in the class hierarchy for the original <a href="qobject.html">QObject</a>.</p>
<p>However, the <a href="qmetaobject.html">QMetaObject</a> hierarchy is a second tree in a plan that exists logically behind the plane of the <a href="qobject.html">QObject</a> tree. The <a href="qtxmlpatterns.html">QtXmlPatterns</a> query engine can only traverse a two dimensional node model that represents an XML tree. If we want to include the <a href="qmetaobject.html">QMetaObject</a> in the same node model that represents the <a href="qobject.html">QObject</a> tree, we must find a way to flatten the <a href="qmetaobject.html">QMetaObject</a> tree into the same plane as the <a href="qobject.html">QObject</a> tree.</p>
<p>The node model class declares <a href="#all-metaobjects">m_allMetaObjects</a> as a vector of pointers to <a href="qmetaobject.html">QMetaObject</a>:</p>
<a name="all-metaobjects"></a><pre class="cpp">     <span class="keyword">typedef</span> <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="qmetaobject.html">QMetaObject</a></span> <span class="operator">*</span><span class="operator">&gt;</span> AllMetaObjects;
     <span class="keyword">const</span> AllMetaObjects    m_allMetaObjects;</pre>
<p>This vector gets populated by the QObjectXmlModel constructor by calling the private allMetaObjects() function:</p>
<pre class="cpp"> <span class="type">QObjectXmlModel</span><span class="operator">::</span>AllMetaObjects <span class="type">QObjectXmlModel</span><span class="operator">::</span>allMetaObjects() <span class="keyword">const</span>
 {
     <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query(namePool());
     query<span class="operator">.</span>bindVariable(<span class="string">&quot;root&quot;</span><span class="operator">,</span> root());
     query<span class="operator">.</span>setQuery(<span class="string">&quot;declare variable $root external;&quot;</span>
                    <span class="string">&quot;$root/descendant-or-self::QObject&quot;</span>);
     Q_ASSERT(query<span class="operator">.</span>isValid());

     <span class="type"><a href="qxmlresultitems.html">QXmlResultItems</a></span> result;
     query<span class="operator">.</span>evaluateTo(<span class="operator">&amp;</span>result);
     <span class="type"><a href="qxmlitem.html">QXmlItem</a></span> i(result<span class="operator">.</span>next());

     AllMetaObjects objects;
     <span class="keyword">while</span> (<span class="operator">!</span>i<span class="operator">.</span>isNull()) {
         <span class="keyword">const</span> <span class="type"><a href="qmetaobject.html">QMetaObject</a></span> <span class="operator">*</span>moo <span class="operator">=</span> asQObject(i<span class="operator">.</span>toNodeModelIndex())<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
         <span class="keyword">while</span> (moo) {
             <span class="keyword">if</span> (<span class="operator">!</span>objects<span class="operator">.</span>contains(moo))
                 objects<span class="operator">.</span>append(moo);
             moo <span class="operator">=</span> moo<span class="operator">-</span><span class="operator">&gt;</span>superClass();
         }
         i <span class="operator">=</span> result<span class="operator">.</span>next();
     }

     Q_ASSERT(<span class="operator">!</span>objects<span class="operator">.</span>contains(<span class="number">0</span>));
     <span class="keyword">return</span> objects;
 }</pre>
<p>The first half of the function is an example of the standard code pattern for using <a href="qtxmlpatterns.html">QtXmlPatterns</a> to run an <a href="xmlprocessing.html">XQuery</a>. First it creates an instance of <a href="qxmlquery.html">QXmlQuery</a>. Then it <a href="qxmlquery.html#bindVariable">binds</a> the <a href="xmlprocessing.html">XQuery</a> variable <tt>$root</tt> to the root node of the of the node model; i.e&#x2e;, the root of the <a href="qobject.html">QObject</a> tree. Then it <a href="qxmlquery.html#setQuery">sets the query</a> to be an <a href="xmlprocessing.html">XQuery</a> that returns all the <a href="qtwebkit-bridge.html#qobjects">QObjects</a> in the node model. Finally, the query is evaluated into a <a href="qxmlresultitems.html">result item list</a>.</p>
<p><b>Note:</b> <a href="qxmlquery.html#bindVariable">QXmlQuery::bindVariable</a>() must be called before <a href="qxmlquery.html#setQuery">QXmlQuery::setQuery</a>(), because setting the query causes <a href="qtxmlpatterns.html">QtXmlPatterns</a> to <i>compile</i> the <a href="xmlprocessing.html">XQuery</a>, which requires knowledge of the variable bindings.</p>
<p>The second half of the function traverses the <a href="qxmlresultitems.html">result item list</a>, getting the <a href="qmetaobject.html">QMetaObject</a> hierarchy for each <a href="qobject.html">QObject</a> and appending it to <a href="#all-metaobjects">m_allMetaObjects</a>, if it isn't already there. But how do we include this vector of pointers to QMetaObjects in the node model? The key insight is shown in the full listing of <a href="#full-listing-of-nextfromsimpleaxis">nextFromSimpleAxis()</a>, where we are interested now in the <tt>MetaObjectXXX</tt> cases:</p>
<a name="full-listing-of-nextfromsimpleaxis"></a><pre class="cpp"> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="type">QObjectXmlModel</span><span class="operator">::</span>nextFromSimpleAxis(SimpleAxis axis<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> <span class="operator">&amp;</span>n) <span class="keyword">const</span>
 {
     <span class="keyword">switch</span> (toNodeType(n))
     {
         <span class="keyword">case</span> IsQObject:
         {
             <span class="keyword">switch</span> (axis)
             {
                 <span class="keyword">case</span> Parent:
                     <span class="keyword">return</span> createIndex(asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>parent());

                 <span class="keyword">case</span> FirstChild:
                 {
                     <span class="keyword">if</span> (<span class="operator">!</span>asQObject(n) <span class="operator">|</span><span class="operator">|</span> asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>children()<span class="operator">.</span>isEmpty())
                         <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                     <span class="keyword">else</span>
                         <span class="keyword">return</span> createIndex(asQObject(n)<span class="operator">-</span><span class="operator">&gt;</span>children()<span class="operator">.</span>first());
                 }

                 <span class="keyword">case</span> NextSibling:
                     <span class="keyword">return</span> qObjectSibling(<span class="number">1</span><span class="operator">,</span> n);

                 <span class="keyword">case</span> PreviousSibling:
                 {
                     <span class="keyword">if</span> (asQObject(n) <span class="operator">=</span><span class="operator">=</span> m_root)
                         <span class="keyword">return</span> createIndex(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span>(<span class="number">0</span>)<span class="operator">,</span> MetaObjects);
                     <span class="keyword">else</span>
                         <span class="keyword">return</span> qObjectSibling(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> n);
                 }
             }
             Q_ASSERT(<span class="keyword">false</span>);
         }

         <span class="keyword">case</span> <span class="type">QObjectClassName</span>:
         <span class="keyword">case</span> <span class="type">QObjectProperty</span>:
         {
             Q_ASSERT(axis <span class="operator">=</span><span class="operator">=</span> Parent);
             <span class="keyword">return</span> createIndex(asQObject(n));
         }
         <span class="keyword">case</span> MetaObjects:
         {
             <span class="keyword">switch</span> (axis)
             {
                 <span class="keyword">case</span> Parent:
                     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                 <span class="keyword">case</span> PreviousSibling:
                     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                 <span class="keyword">case</span> NextSibling:
                     <span class="keyword">return</span> root();
                 <span class="keyword">case</span> FirstChild:
                 {
                     <span class="keyword">return</span> createIndex(<span class="keyword">const_cast</span><span class="operator">&lt;</span><span class="type"><a href="qmetaobject.html">QMetaObject</a></span><span class="operator">*</span><span class="operator">&gt;</span>(m_allMetaObjects<span class="operator">.</span>first())<span class="operator">,</span>MetaObject);
                 }
             }
             Q_ASSERT(<span class="keyword">false</span>);
         }

         <span class="keyword">case</span> MetaObject:
         {
             <span class="keyword">switch</span> (axis)
             {
                 <span class="keyword">case</span> FirstChild:
                     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                 <span class="keyword">case</span> Parent:
                     <span class="keyword">return</span> createIndex(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span>(<span class="number">0</span>)<span class="operator">,</span> MetaObjects);
                 <span class="keyword">case</span> PreviousSibling:
                     <span class="keyword">return</span> metaObjectSibling(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> n);
                 <span class="keyword">case</span> NextSibling:
                     <span class="keyword">return</span> metaObjectSibling(<span class="number">1</span><span class="operator">,</span> n);
             }
         }

         <span class="keyword">case</span> MetaObjectClassName:
         <span class="keyword">case</span> MetaObjectSuperClass:
         {
             Q_ASSERT(axis <span class="operator">=</span><span class="operator">=</span> Parent);
             <span class="keyword">return</span> createIndex(asQObject(n)<span class="operator">,</span> MetaObject);
         }
     }

     Q_ASSERT(<span class="keyword">false</span>);
     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
 }</pre>
<p>But first, revisit the <tt>PreviousSibling</tt> case for the <tt>IsQObject</tt> case:</p>
<pre class="cpp">                 <span class="keyword">case</span> PreviousSibling:
                 {
                     <span class="keyword">if</span> (asQObject(n) <span class="operator">=</span><span class="operator">=</span> m_root)
                         <span class="keyword">return</span> createIndex(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span>(<span class="number">0</span>)<span class="operator">,</span> MetaObjects);
                     <span class="keyword">else</span>
                         <span class="keyword">return</span> qObjectSibling(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> n);
                 }</pre>
<p>When asking for the previous sibling of the root of the <a href="qobject.html">QObject</a> tree, it creates a node model index with a null <a href="qobject.html">QObject</a> pointer and an <tt>additionalData</tt> value of <tt>MetaObjects</tt>. This effectively allows the query engine to jump from the <a href="qobject.html">QObject</a> tree to the <a href="qmetaobject.html">QMetaObject</a> tree.</p>
<p>The query engine can jump from the <a href="qmetaobject.html">QMetaObject</a> tree back to the <a href="qobject.html">QObject</a> tree in the <tt>NextSibling</tt> case of case <tt>MetaObjects</tt>, where the <tt>root()</tt> function is called:</p>
<pre class="cpp">         <span class="keyword">case</span> MetaObjects:
         {
             <span class="keyword">switch</span> (axis)
             {
                 <span class="keyword">case</span> Parent:
                     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                 <span class="keyword">case</span> PreviousSibling:
                     <span class="keyword">return</span> <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span>();
                 <span class="keyword">case</span> NextSibling:
                     <span class="keyword">return</span> root();
                 <span class="keyword">case</span> FirstChild:
                 {
                     <span class="keyword">return</span> createIndex(<span class="keyword">const_cast</span><span class="operator">&lt;</span><span class="type"><a href="qmetaobject.html">QMetaObject</a></span><span class="operator">*</span><span class="operator">&gt;</span>(m_allMetaObjects<span class="operator">.</span>first())<span class="operator">,</span>MetaObject);
                 }
             }
             Q_ASSERT(<span class="keyword">false</span>);
         }</pre>
<p>Having jumped from the <a href="qobject.html">QObject</a> tree to the <a href="qmetaobject.html">QMetaObject</a> tree, the query engine will use the <tt>MetaObject</tt>, <tt>MetaObjectClassName</tt>, and <tt>MetaObjectSuperClass</tt> cases, which are similar to the cases for <tt>IsQObject</tt>, <tt>QObjectProperty</tt>, and <tt>QObjectClassName</tt>.</p>
</div>
<!-- @@@xmlpatterns/qobjectxmlmodel -->
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
