<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qscreen_qws.cpp -->
  <title>Qt 4.8: QScreen Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtgui.html">QtGui</a></li>
<li>QScreen</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#protected-variables">Protected Variables</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#framebuffer-management">Framebuffer Management</a></li>
<li class="level2"><a href="#palette-management">Palette Management</a></li>
<li class="level2"><a href="#drawing-on-screen">Drawing on Screen</a></li>
<li class="level2"><a href="#properties">Properties</a></li>
<li class="level2"><a href="#subclassing-and-initial-values">Subclassing and Initial Values</a></li>
</ul>
</div>
<h1 class="title">QScreen Class Reference</h1>
<!-- $$$QScreen-brief -->
<p>The QScreen class is a base class for screen drivers in Qt for Embedded Linux. <a href="#details">More...</a></p>
<!-- @@@QScreen -->
<pre class="cpp"> <span class="preprocessor">#include &lt;QScreen&gt;</span></pre><p><b>Inherited by: </b><a href="qproxyscreen.html">QProxyScreen</a>.</p>
<ul>
<li><a href="qscreen-members.html">List of all members, including inherited members</a></li>
<li><a href="qscreen-qt3.html">Qt 3 support members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#ClassId-enum">ClassId</a></b> { LinuxFBClass, TransformedClass, VNCClass, MultiClass, ..., CustomClass }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#PixelType-enum">PixelType</a></b> { NormalPixel, BGRPixel }</td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#QScreen">QScreen</a></b> ( int <i>display_id</i>, ClassId <i>classId</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#QScreen-2">QScreen</a></b> ( int <i>displayId</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#dtor.QScreen">~QScreen</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#alloc">alloc</a></b> ( unsigned int <i>red</i>, unsigned int <i>green</i>, unsigned int <i>blue</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uchar * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#base">base</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#blank">blank</a></b> ( bool <i>on</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#blit">blit</a></b> ( const QImage &amp; <i>image</i>, const QPoint &amp; <i>topLeft</i>, const QRegion &amp; <i>region</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ClassId </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#classId">classId</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRgb * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#clut">clut</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#colorCount">colorCount</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#connect">connect</a></b> ( const QString &amp; <i>displaySpec</i> ) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QWSWindowSurface * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#createSurface">createSurface</a></b> ( const QString &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QWSWindowSurface * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#createSurface-2">createSurface</a></b> ( QWidget * <i>widget</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#depth">depth</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#deviceHeight">deviceHeight</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#deviceWidth">deviceWidth</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#disconnect">disconnect</a></b> () = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#exposeRegion">exposeRegion</a></b> ( QRegion <i>region</i>, int <i>windowIndex</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#height">height</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#initDevice">initDevice</a></b> () = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#isInterlaced">isInterlaced</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#isTransformed">isTransformed</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#linestep">linestep</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapFromDevice">mapFromDevice</a></b> ( const QSize &amp; <i>size</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPoint </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapFromDevice-2">mapFromDevice</a></b> ( const QPoint &amp; <i>point</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRect </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapFromDevice-3">mapFromDevice</a></b> ( const QRect &amp; <i>rectangle</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QImage </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapFromDevice-4">mapFromDevice</a></b> ( const QImage &amp; <i>image</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRegion </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapFromDevice-5">mapFromDevice</a></b> ( const QRegion &amp; <i>region</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapToDevice">mapToDevice</a></b> ( const QSize &amp; <i>size</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPoint </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapToDevice-2">mapToDevice</a></b> ( const QPoint &amp; <i>point</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRect </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapToDevice-3">mapToDevice</a></b> ( const QRect &amp; <i>rectangle</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QImage </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapToDevice-4">mapToDevice</a></b> ( const QImage &amp; <i>image</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRegion </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapToDevice-5">mapToDevice</a></b> ( const QRegion &amp; <i>region</i>, const QSize &amp; <i>screenSize</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#offset">offset</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#onCard">onCard</a></b> ( const unsigned char * <i>buffer</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#onCard-2">onCard</a></b> ( const unsigned char * <i>buffer</i>, ulong &amp; <i>offset</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#physicalHeight">physicalHeight</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#physicalWidth">physicalWidth</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage::Format </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixelFormat">pixelFormat</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PixelType </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixelType">pixelType</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixmapDepth">pixmapDepth</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRegion </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#region">region</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#restore">restore</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#save">save</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#screenSize">screenSize</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#setDirty">setDirty</a></b> ( const QRect &amp; <i>rectangle</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#setMode">setMode</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i> ) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#shutdownDevice">shutdownDevice</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#solidFill">solidFill</a></b> ( const QColor &amp; <i>color</i>, const QRegion &amp; <i>region</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a></b> ( const QPoint &amp; <i>position</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QScreen *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#subScreens">subScreens</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#supportsDepth">supportsDepth</a></b> ( int <i>depth</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#totalSize">totalSize</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#transformOrientation">transformOrientation</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#width">width</a></b> () const</td></tr>
</table>
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QScreen * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#instance">instance</a></b> ()</td></tr>
</table>
<a name="protected-functions"></a>
<h2>Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#setPixelFormat">setPixelFormat</a></b> ( QImage::Format <i>format</i> )</td></tr>
</table>
<a name="protected-variables"></a>
<h2>Protected Variables</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#d-var">d</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uchar * </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#data-var">data</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#dh-var">dh</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#dw-var">dw</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#grayscale-var">grayscale</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#h-var">h</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#lstep-var">lstep</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#mapsize-var">mapsize</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#physHeight-var">physHeight</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#physWidth-var">physWidth</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PixelType </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#pixeltype-var">pixeltype</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRgb </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#screenclut-var">screenclut</a></b>[256]</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#screencols-var">screencols</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#size-var">size</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#w-var">w</a></b></td></tr>
</table>
<a name="related-non-members"></a>
<h2>Related Non-Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscreen.html#setTransformation">setTransformation</a></b> ( int <i>transformation</i>, int <i>screenNo</i> = -1 )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QScreen-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QScreen class is a base class for screen drivers in Qt for Embedded Linux.</p>
<p>Note that this class is only available in <a href="qt-embedded-linux.html">Qt for Embedded Linux</a>.</p>
<p><a href="qt-embedded-linux.html">Qt for Embedded Linux</a> provides ready-made drivers for several screen protocols, see the <a href="qt-embedded-displaymanagement.html">display management</a> documentation for details. Custom screen drivers can be implemented by subclassing the QScreen class and creating a screen driver plugin (derived from <a href="qscreendriverplugin.html">QScreenDriverPlugin</a>). The default implementation of the <a href="qscreendriverfactory.html">QScreenDriverFactory</a> class will automatically detect the plugin, and load the driver into the server application at run-time using Qt's <a href="plugins-howto.html">plugin system</a>.</p>
<p>When rendering, the default behavior is for each client to render its widgets as well as its decorations into memory, while the server copies the memory content to the device's framebuffer using the screen driver. See the <a href="qt-embedded-architecture.html">Qt for Embedded Linux Architecture</a> overview for details (note that it is possible for the clients to manipulate and control the underlying hardware directly as well).</p>
<p>Starting with Qt 4.2, it is also possible to add an accelerated graphics driver to take advantage of available hardware resources. See the <a href="qt-embedded-accel.html">Adding an Accelerated Graphics Driver to Qt for Embedded Linux</a> documentation for details.</p>
<a name="framebuffer-management"></a>
<h3>Framebuffer Management</h3>
<p>When a <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> application starts running, it calls the screen driver's <a href="qscreen.html#connect">connect</a>() function to map the framebuffer and the accelerated drivers that the graphics card control registers. The <a href="qscreen.html#connect">connect</a>() function should then read out the parameters of the framebuffer and use them as required to set this class's protected variables.</p>
<p>The <a href="qscreen.html#initDevice">initDevice</a>() function can be reimplemented to initialize the graphics card. Note, however, that <a href="qscreen.html#connect">connect</a>() is called <i>before</i> the <a href="qscreen.html#initDevice">initDevice</a>() function, so, for some hardware configurations, some of the initialization that would normally be done in the <a href="qscreen.html#initDevice">initDevice</a>() function might have to be done in the <a href="qscreen.html#connect">connect</a>() function.</p>
<p>Likewise, just before a <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> application exits, it calls the screen driver's <a href="qscreen.html#disconnect">disconnect</a>() function. The server application will in addition call the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function before it calls <a href="qscreen.html#disconnect">disconnect</a>(). Note that the default implementation of the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function only hides the mouse cursor.</p>
<p>QScreen also provides the <a href="qscreen.html#save">save</a>() and <a href="qscreen.html#restore">restore</a>() functions, making it possible to save and restore the state of the graphics card. Note that the default implementations do nothing. Hardware screen drivers should reimplement these functions to save (and restore) its registers, enabling switching between virtual consoles.</p>
<p>In addition, you can use the <a href="qscreen.html#base">base</a>() function to retrieve a pointer to the beginning of the framebuffer, and the <a href="qscreen.html#region">region</a>() function to retrieve the framebuffer's region. Use the <a href="qscreen.html#onCard">onCard</a>() function to determine whether the framebuffer is within the graphics card's memory, and the <a href="qscreen.html#totalSize">totalSize</a>() function to determine the size of the available graphics card memory (including the screen). Finally, you can use the <a href="qscreen.html#offset">offset</a>() function to retrieve the offset between the framebuffer's coordinates and the application's coordinate system.</p>
<a name="palette-management"></a>
<h3>Palette Management</h3>
<p>QScreen provides several functions to retrieve information about the color palette: The <a href="qscreen.html#clut">clut</a>() function returns a pointer to the color lookup table (i.e&#x2e; its color palette). Use the <a href="qscreen.html#colorCount">colorCount</a>() function to determine the number of entries in this table, and the <a href="qscreen.html#alloc">alloc</a>() function to retrieve the palette index of the color that is the closest match to a given RGB value.</p>
<p>To determine if the screen driver supports a given color depth, use the <a href="qscreen.html#supportsDepth">supportsDepth</a>() function that returns true of the specified depth is supported.</p>
<a name="drawing-on-screen"></a>
<h3>Drawing on Screen</h3>
<p>When a screen update is required, the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server runs through all the top-level windows that intersect with the region that is about to be updated, and ensures that the associated clients have updated their memory buffer. Then the server calls the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function that composes the window surfaces and copies the content of memory to screen by calling the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions.</p>
<p>The <a href="qscreen.html#blit">blit</a>() function copies a given region in a given image to a specified point using device coordinates, while the <a href="qscreen.html#solidFill">solidFill</a>() function fills the given region of the screen with the specified color. Note that normally there is no need to call either of these functions explicitly.</p>
<p>In addition, QScreen provides the <a href="qscreen.html#blank">blank</a>() function that can be reimplemented to prevent any contents from being displayed on the screen, and the <a href="qscreen.html#setDirty">setDirty</a>() function that can be reimplemented to indicate that a given rectangle of the screen has been altered. Note that the default implementations of these functions do nothing.</p>
<p>Reimplement the <a href="qscreen.html#mapFromDevice">mapFromDevice</a>() and <a href="qscreen.html#mapToDevice">mapToDevice</a>() functions to map objects from the framebuffer coordinate system to the coordinate space used by the application, and vice versa. Be aware that the default implementations simply return the given objects as they are.</p>
<a name="properties"></a>
<h3>Properties</h3>
<table class="generic">
<thead><tr class="qt-style"><th >Property</th><th >Functions</th></tr></thead>
<tr valign="top" class="odd"><td >Size</td><td >The size of the screen can be retrieved using the <a href="qscreen.html#screenSize">screenSize</a>() function. The size is returned in bytes.<p>The framebuffer's logical width and height can be retrieved using <a href="qscreen.html#width">width</a>() and <a href="qscreen.html#height">height</a>(), respectively. These functions return values are given in pixels. Alternatively, the <a href="qscreen.html#physicalWidth">physicalWidth</a>() and <a href="qscreen.html#physicalHeight">physicalHeight</a>() function returns the same metrics in millimeters. QScreen also provides the <a href="qscreen.html#deviceWidth">deviceWidth</a>() and <a href="qscreen.html#deviceHeight">deviceHeight</a>() functions returning the physical width and height of the device in pixels. Note that the latter metrics can differ from the ones used if the display is centered within the framebuffer.</p>
</td></tr>
<tr valign="top" class="even"><td >Resolution</td><td >Reimplement the <a href="qscreen.html#setMode">setMode</a>() function to be able to set the framebuffer to a new resolution (width and height) and bit depth.<p>The current depth of the framebuffer can be always be retrieved using the <a href="qscreen.html#depth">depth</a>() function. Use the <a href="qscreen.html#pixmapDepth">pixmapDepth</a>() function to obtain the preferred depth for pixmaps.</p>
</td></tr>
<tr valign="top" class="odd"><td >Pixmap Alignment</td><td >Use the <a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a>() function to retrieve the value to which the start address of pixmaps held in the graphics card's memory, should be aligned.<p>Use the <a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a>() to retrieve the value to which the <i>individual scanlines</i> of pixmaps should be aligned.</p>
</td></tr>
<tr valign="top" class="even"><td >Image Display</td><td >The <a href="qscreen.html#isInterlaced">isInterlaced</a>() function tells whether the screen is displaying images progressively, and the <a href="qscreen.html#isTransformed">isTransformed</a>() function whether it is rotated. The <a href="qscreen.html#transformOrientation">transformOrientation</a>() function can be reimplemented to return the current rotation.</td></tr>
<tr valign="top" class="odd"><td >Scanlines</td><td >Use the <a href="qscreen.html#linestep">linestep</a>() function to retrieve the length of each scanline of the framebuffer.</td></tr>
<tr valign="top" class="even"><td >Pixel Type</td><td >The <a href="qscreen.html#pixelType">pixelType</a>() function returns the screen's pixel storage format as described by the <a href="qscreen.html#PixelType-enum">PixelType</a> enum.</td></tr>
</table>
<a name="subclassing-and-initial-values"></a>
<h3>Subclassing and Initial Values</h3>
<p>You need to set the following members when implementing a subclass of QScreen:</p>
<table class="generic">
<thead><tr class="qt-style"><th >Member</th><th >Initial Value</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qscreen.html#data-var">data</a></td><td >A pointer to the framebuffer if possible; 0 otherwise.</td></tr>
<tr valign="top" class="even"><td ><a href="qscreen.html#lstep-var">lstep</a></td><td >The number of bytes between each scanline in the framebuffer.</td></tr>
<tr valign="top" class="odd"><td ><a href="qscreen.html#w-var">w</a></td><td >The logical screen width in pixels.</td></tr>
<tr valign="top" class="even"><td ><a href="qscreen.html#h-var">h</a></td><td >The logical screen height in pixels.</td></tr>
<tr valign="top" class="odd"><td ><a href="qscreen.html#dw-var">dw</a></td><td >The real screen width in pixels.</td></tr>
<tr valign="top" class="even"><td ><a href="qscreen.html#dh-var">dh</a></td><td >The real screen height in pixels.</td></tr>
<tr valign="top" class="odd"><td ><a href="qscreen.html#d-var">d</a></td><td >The number of bits per pixel.</td></tr>
<tr valign="top" class="even"><td ><a href="qscreen.html#physWidth-var">physWidth</a></td><td >The screen width in millimeters.</td></tr>
<tr valign="top" class="odd"><td ><a href="qscreen.html#physHeight-var">physHeight</a></td><td >The screen height in millimeters.</td></tr>
</table>
<p>The logical screen values are the same as the real screen values unless the screen is transformed in some way; e.g&#x2e;, rotated.</p>
<p>See also the <a href="qws-svgalib.html">Accelerated Graphics Driver Example</a> for an example that shows how to initialize these values.</p>
</div>
<p><b>See also </b><a href="qscreendriverplugin.html">QScreenDriverPlugin</a>, <a href="qscreendriverfactory.html">QScreenDriverFactory</a>, and <a href="qt-embedded-displaymanagement.html">Qt for Embedded Linux Display Management</a>.</p>
<!-- @@@QScreen -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ClassId$$$LinuxFBClass$$$TransformedClass$$$VNCClass$$$MultiClass$$$VFbClass$$$DirectFBClass$$$SvgalibClass$$$ProxyClass$$$GLClass$$$IntfbClass$$$CustomClass -->
<h3 class="fn"><a name="ClassId-enum"></a>enum QScreen::<span class="name">ClassId</span></h3>
<p>This enum defines the class identifiers for the known screen subclasses.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QScreen::LinuxFBClass</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">QLinuxFBScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::TransformedClass</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">QTransformedScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::VNCClass</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">QVNCScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::MultiClass</tt></td><td class="topAlign"><tt>3</tt></td><td class="topAlign">QMultiScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::VFbClass</tt></td><td class="topAlign"><tt>4</tt></td><td class="topAlign">QVFbScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::DirectFBClass</tt></td><td class="topAlign"><tt>5</tt></td><td class="topAlign">QDirectFBScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::SvgalibClass</tt></td><td class="topAlign"><tt>6</tt></td><td class="topAlign">QSvgalibScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::ProxyClass</tt></td><td class="topAlign"><tt>7</tt></td><td class="topAlign"><a href="qproxyscreen.html">QProxyScreen</a></td></tr>
<tr><td class="topAlign"><tt>QScreen::GLClass</tt></td><td class="topAlign"><tt>8</tt></td><td class="topAlign">QGLScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::IntfbClass</tt></td><td class="topAlign"><tt>9</tt></td><td class="topAlign">QIntfbScreen</td></tr>
<tr><td class="topAlign"><tt>QScreen::CustomClass</tt></td><td class="topAlign"><tt>1024</tt></td><td class="topAlign">Unknown <a href="qscreen.html">QScreen</a> subclass</td></tr>
</table>
<p><b>See also </b><a href="qscreen.html#classId">classId</a>().</p>
<!-- @@@ClassId -->
<!-- $$$PixelType$$$NormalPixel$$$BGRPixel -->
<h3 class="fn"><a name="PixelType-enum"></a>enum QScreen::<span class="name">PixelType</span></h3>
<p>This enum describes the pixel storage format of the screen, i.e&#x2e; the order of the red (R), green (G) and blue (B) components of a pixel.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QScreen::NormalPixel</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">Red-green-blue (RGB)</td></tr>
<tr><td class="topAlign"><tt>QScreen::BGRPixel</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">Blue-green-red (BGR)</td></tr>
</table>
<p><b>See also </b><a href="qscreen.html#pixelType">pixelType</a>().</p>
<!-- @@@PixelType -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QScreen[overload1]$$$QScreenintClassId -->
<h3 class="fn"><a name="QScreen"></a>QScreen::<span class="name">QScreen</span> ( <span class="type">int</span> <i>display_id</i>, <span class="type"><a href="qscreen.html#ClassId-enum">ClassId</a></span> <i>classId</i> )</h3>
<p>Constructs a new screen driver.</p>
<p>The <i>display_id</i> identifies the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server to connect to. The <i>classId</i> specifies the class identifier.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@QScreen -->
<!-- $$$QScreen$$$QScreenint -->
<h3 class="fn"><a name="QScreen-2"></a>QScreen::<span class="name">QScreen</span> ( <span class="type">int</span> <i>displayId</i> )</h3>
<p>Constructs a new screen driver.</p>
<p>The <i>displayId</i> identifies the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server to connect to.</p>
<!-- @@@QScreen -->
<!-- $$$~QScreen[overload1]$$$~QScreen -->
<h3 class="fn"><a name="dtor.QScreen"></a>QScreen::<span class="name">~QScreen</span> ()<tt> [virtual]</tt></h3>
<p>Destroys this screen driver.</p>
<!-- @@@~QScreen -->
<!-- $$$alloc[overload1]$$$allocunsignedintunsignedintunsignedint -->
<h3 class="fn"><a name="alloc"></a><span class="type">int</span> QScreen::<span class="name">alloc</span> ( <span class="type">unsigned</span> <span class="type">int</span> <i>red</i>, <span class="type">unsigned</span> <span class="type">int</span> <i>green</i>, <span class="type">unsigned</span> <span class="type">int</span> <i>blue</i> )<tt> [virtual]</tt></h3>
<p>Returns the index in the screen's palette which is the closest match to the given RGB value (<i>red</i>, <i>green</i>, <i>blue</i>).</p>
<p>Note that this function only apply in paletted modes like 8-bit, i.e&#x2e; in modes where only the palette indexes (and not the actual color values) are stored in memory.</p>
<p><b>See also </b><a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#colorCount">colorCount</a>().</p>
<!-- @@@alloc -->
<!-- $$$base[overload1]$$$base -->
<h3 class="fn"><a name="base"></a><span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * QScreen::<span class="name">base</span> () const</h3>
<p>Returns a pointer to the beginning of the framebuffer.</p>
<p><b>See also </b><a href="qscreen.html#onCard">onCard</a>(), <a href="qscreen.html#region">region</a>(), and <a href="qscreen.html#totalSize">totalSize</a>().</p>
<!-- @@@base -->
<!-- $$$blank[overload1]$$$blankbool -->
<h3 class="fn"><a name="blank"></a><span class="type">void</span> QScreen::<span class="name">blank</span> ( <span class="type">bool</span> <i>on</i> )<tt> [virtual]</tt></h3>
<p>Prevents the screen driver form displaying any content on the screen.</p>
<p>Note that the default implementation does nothing.</p>
<p>Reimplement this function to prevent the screen driver from displaying any contents on the screen if <i>on</i> is true; otherwise the contents is expected to be shown.</p>
<p><b>See also </b><a href="qscreen.html#blit">blit</a>().</p>
<!-- @@@blank -->
<!-- $$$blit[overload1]$$$blitconstQImage&constQPoint&constQRegion& -->
<h3 class="fn"><a name="blit"></a><span class="type">void</span> QScreen::<span class="name">blit</span> ( const <span class="type"><a href="qimage.html">QImage</a></span> &amp; <i>image</i>, const <span class="type"><a href="qpoint.html">QPoint</a></span> &amp; <i>topLeft</i>, const <span class="type"><a href="qregion.html">QRegion</a></span> &amp; <i>region</i> )<tt> [virtual]</tt></h3>
<p>Copies the given <i>region</i> in the given <i>image</i> to the point specified by <i>topLeft</i> using device coordinates.</p>
<p>This function is called from the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function; it is not intended to be called explicitly.</p>
<p>Reimplement this function to make use of <a href="qt-embedded-accel.html">accelerated hardware</a>. Note that this function must be reimplemented if the framebuffer format is not supported by <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> (See the <a href="qt-embedded-displaymanagement.html">Display Management</a> documentation for more details).</p>
<p><b>See also </b><a href="qscreen.html#exposeRegion">exposeRegion</a>(), <a href="qscreen.html#solidFill">solidFill</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<!-- @@@blit -->
<!-- $$$classId[overload1]$$$classId -->
<h3 class="fn"><a name="classId"></a><span class="type"><a href="qscreen.html#ClassId-enum">ClassId</a></span> QScreen::<span class="name">classId</span> () const</h3>
<p>Returns the class identifier for the screen object.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@classId -->
<!-- $$$clut[overload1]$$$clut -->
<h3 class="fn"><a name="clut"></a><span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * QScreen::<span class="name">clut</span> ()</h3>
<p>Returns a pointer to the screen's color lookup table (i.e&#x2e; its color palette).</p>
<p>Note that this function only apply in paletted modes like 8-bit, i.e&#x2e; in modes where only the palette indexes (and not the actual color values) are stored in memory.</p>
<p><b>See also </b><a href="qscreen.html#alloc">alloc</a>(), <a href="qscreen.html#depth">depth</a>(), and <a href="qscreen.html#colorCount">colorCount</a>().</p>
<!-- @@@clut -->
<!-- $$$colorCount[overload1]$$$colorCount -->
<h3 class="fn"><a name="colorCount"></a><span class="type">int</span> QScreen::<span class="name">colorCount</span> ()</h3>
<p>Returns the number of entries in the screen's color lookup table (i.e&#x2e; its color palette). A pointer to the color table can be retrieved using the <a href="qscreen.html#clut">clut</a>() function.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#alloc">alloc</a>().</p>
<!-- @@@colorCount -->
<!-- $$$connect[overload1]$$$connectconstQString& -->
<h3 class="fn"><a name="connect"></a><span class="type">bool</span> QScreen::<span class="name">connect</span> ( const <span class="type"><a href="qstring.html">QString</a></span> &amp; <i>displaySpec</i> )<tt> [pure virtual]</tt></h3>
<p>This function is called by every <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> application on startup, and must be implemented to map in the framebuffer and the accelerated drivers that the graphics card control registers. Note that connect must be called <i>before</i> the <a href="qscreen.html#initDevice">initDevice</a>() function.</p>
<p>Ensure that true is returned if a connection to the screen device is made. Otherwise, return false. Upon making the connection, the function should read out the parameters of the framebuffer and use them as required to set this class's protected variables.</p>
<p>The <i>displaySpec</i> argument is passed by the <a href="qt-embedded-envvars.html#qws-display">QWS_DISPLAY</a> environment variable or the -display command line parameter, and has the following syntax:</p>
<pre class="cpp"> <span class="operator">[</span>screen driver<span class="operator">]</span><span class="operator">[</span>:driver specific options<span class="operator">]</span><span class="operator">[</span>:display number<span class="operator">]</span></pre>
<p>For example, to use the mach64 driver on fb1 as display 2:</p>
<pre class="cpp"> Mach64:<span class="operator">/</span>dev<span class="operator">/</span>fb1:<span class="number">2</span></pre>
<p>See <a href="qt-embedded-displaymanagement.html">Qt for Embedded Linux Display Management</a> for more details.</p>
<p><b>See also </b><a href="qscreen.html#disconnect">disconnect</a>(), <a href="qscreen.html#initDevice">initDevice</a>(), and <a href="qt-embedded-running.html">Running Qt for Embedded Linux Applications</a>.</p>
<!-- @@@connect -->
<!-- $$$createSurface[overload1]$$$createSurfaceconstQString& -->
<h3 class="fn"><a name="createSurface"></a><span class="type">QWSWindowSurface</span> * QScreen::<span class="name">createSurface</span> ( const <span class="type"><a href="qstring.html">QString</a></span> &amp; <i>key</i> ) const<tt> [virtual]</tt></h3>
<p>Creates and returns a new window surface matching the given <i>key</i>.</p>
<p>The server application will call this function whenever it needs to create a server side representation of a window, e.g&#x2e; when copying the content of memory to the screen using the screen driver.</p>
<p>Note that this function must be reimplemented when adding an accelerated graphics driver. See the <a href="qt-embedded-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qt-embedded-architecture.html">Qt for Embedded Linux Architecture</a>.</p>
<!-- @@@createSurface -->
<!-- $$$createSurface$$$createSurfaceQWidget* -->
<h3 class="fn"><a name="createSurface-2"></a><span class="type">QWSWindowSurface</span> * QScreen::<span class="name">createSurface</span> ( <span class="type"><a href="qwidget.html">QWidget</a></span> * <i>widget</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a new window surface for the given <i>widget</i>.</p>
<!-- @@@createSurface -->
<!-- $$$depth[overload1]$$$depth -->
<h3 class="fn"><a name="depth"></a><span class="type">int</span> QScreen::<span class="name">depth</span> () const</h3>
<p>Returns the depth of the framebuffer, in bits per pixel.</p>
<p>Note that the returned depth is the number of bits each pixel fills rather than the number of significant bits, so 24bpp and 32bpp express the same range of colors (8 bits of red, green and blue).</p>
<p><b>See also </b><a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#pixmapDepth">pixmapDepth</a>().</p>
<!-- @@@depth -->
<!-- $$$deviceHeight[overload1]$$$deviceHeight -->
<h3 class="fn"><a name="deviceHeight"></a><span class="type">int</span> QScreen::<span class="name">deviceHeight</span> () const</h3>
<p>Returns the full height of the framebuffer device in pixels.</p>
<p>Note that the returned height can differ from the height which <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> will actually use, that is if the display is centered within the framebuffer.</p>
<p><b>See also </b><a href="qscreen.html#height">height</a>(), <a href="qscreen.html#physicalHeight">physicalHeight</a>(), and <a href="qscreen.html#deviceWidth">deviceWidth</a>().</p>
<!-- @@@deviceHeight -->
<!-- $$$deviceWidth[overload1]$$$deviceWidth -->
<h3 class="fn"><a name="deviceWidth"></a><span class="type">int</span> QScreen::<span class="name">deviceWidth</span> () const</h3>
<p>Returns the physical width of the framebuffer device in pixels.</p>
<p>Note that the returned width can differ from the width which <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> will actually use, that is if the display is centered within the framebuffer.</p>
<p><b>See also </b><a href="qscreen.html#width">width</a>(), <a href="qscreen.html#physicalWidth">physicalWidth</a>(), and <a href="qscreen.html#deviceHeight">deviceHeight</a>().</p>
<!-- @@@deviceWidth -->
<!-- $$$disconnect[overload1]$$$disconnect -->
<h3 class="fn"><a name="disconnect"></a><span class="type">void</span> QScreen::<span class="name">disconnect</span> ()<tt> [pure virtual]</tt></h3>
<p>This function is called by every <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> application before exiting, and must be implemented to unmap the framebuffer. Note that a server application will call the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function prior to this function.</p>
<p><b>See also </b><a href="qscreen.html#connect">connect</a>(), <a href="qscreen.html#shutdownDevice">shutdownDevice</a>(), and <a href="qt-embedded-running.html">Running Qt for Embedded Linux Applications</a>.</p>
<!-- @@@disconnect -->
<!-- $$$exposeRegion[overload1]$$$exposeRegionQRegionint -->
<h3 class="fn"><a name="exposeRegion"></a><span class="type">void</span> QScreen::<span class="name">exposeRegion</span> ( <span class="type"><a href="qregion.html">QRegion</a></span> <i>region</i>, <span class="type">int</span> <i>windowIndex</i> )<tt> [virtual]</tt></h3>
<p>This function is called by the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server whenever a screen update is required. <i>region</i> is the area on the screen that must be updated, and <i>windowIndex</i> is the index into <a href="qwsserver.html#clientWindows">QWSServer::clientWindows</a>() of the window that required the update. <a href="qwswindow.html#state">QWSWindow::state</a>() gives more information about the cause.</p>
<p>The default implementation composes the affected windows and paints the given <i>region</i> on screen by calling the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions</p>
<p>This function can be reimplemented to perform composition in hardware, or to perform transition effects. For simpler hardware acceleration, or to interface with this is typically done by reimplementing the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions instead.</p>
<p>Note that there is no need to call this function explicitly.</p>
<p><b>See also </b><a href="qscreen.html#blit">blit</a>(), <a href="qscreen.html#solidFill">solidFill</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<!-- @@@exposeRegion -->
<!-- $$$height[overload1]$$$height -->
<h3 class="fn"><a name="height"></a><span class="type">int</span> QScreen::<span class="name">height</span> () const</h3>
<p>Returns the logical height of the framebuffer in pixels.</p>
<p><b>See also </b><a href="qscreen.html#deviceHeight">deviceHeight</a>(), <a href="qscreen.html#physicalHeight">physicalHeight</a>(), and <a href="qscreen.html#width">width</a>().</p>
<!-- @@@height -->
<!-- $$$initDevice[overload1]$$$initDevice -->
<h3 class="fn"><a name="initDevice"></a><span class="type">bool</span> QScreen::<span class="name">initDevice</span> ()<tt> [pure virtual]</tt></h3>
<p>This function is called by the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server to initialize the framebuffer. Note that a server application will call the <a href="qscreen.html#connect">connect</a>() function prior to this function.</p>
<p>Implement this function to make accelerated drivers set up the graphics card. Return true to indicate success and false to indicate failure.</p>
<p><b>See also </b><a href="qscreen.html#shutdownDevice">shutdownDevice</a>() and <a href="qscreen.html#connect">connect</a>().</p>
<!-- @@@initDevice -->
<!-- $$$instance[overload1]$$$instance -->
<h3 class="fn"><a name="instance"></a><span class="type">QScreen</span> * QScreen::<span class="name">instance</span> ()<tt> [static]</tt></h3>
<p>Returns a pointer to the application's <a href="qscreen.html">QScreen</a> instance.</p>
<p>If this screen consists of several subscreens, operations to the returned instance will affect all its subscreens. Use the subscreens() function to retrieve access to a particular subscreen.</p>
<p><b>See also </b><a href="qscreen.html#subScreens">subScreens</a>() and <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>().</p>
<!-- @@@instance -->
<!-- $$$isInterlaced[overload1]$$$isInterlaced -->
<h3 class="fn"><a name="isInterlaced"></a><span class="type">bool</span> QScreen::<span class="name">isInterlaced</span> () const<tt> [virtual]</tt></h3>
<p>Returns true if the display is interlaced (i.e&#x2e; is displaying images progressively like a television screen); otherwise returns false.</p>
<p>If the display is interlaced, the drawing is altered to look better.</p>
<p><b>See also </b><a href="qscreen.html#isTransformed">isTransformed</a>() and <a href="qscreen.html#linestep">linestep</a>().</p>
<!-- @@@isInterlaced -->
<!-- $$$isTransformed[overload1]$$$isTransformed -->
<h3 class="fn"><a name="isTransformed"></a><span class="type">bool</span> QScreen::<span class="name">isTransformed</span> () const<tt> [virtual]</tt></h3>
<p>Returns true if the screen is transformed (for instance, rotated 90 degrees); otherwise returns false.</p>
<p><b>See also </b><a href="qscreen.html#transformOrientation">transformOrientation</a>() and <a href="qscreen.html#isInterlaced">isInterlaced</a>().</p>
<!-- @@@isTransformed -->
<!-- $$$linestep[overload1]$$$linestep -->
<h3 class="fn"><a name="linestep"></a><span class="type">int</span> QScreen::<span class="name">linestep</span> () const</h3>
<p>Returns the length of each scanline of the framebuffer in bytes.</p>
<p><b>See also </b><a href="qscreen.html#isInterlaced">isInterlaced</a>().</p>
<!-- @@@linestep -->
<!-- $$$mapFromDevice[overload1]$$$mapFromDeviceconstQSize& -->
<h3 class="fn"><a name="mapFromDevice"></a><span class="type"><a href="qsize.html">QSize</a></span> QScreen::<span class="name">mapFromDevice</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i> ) const<tt> [virtual]</tt></h3>
<p>Maps the given <i>size</i> from the framebuffer coordinate system to the coordinate space used by the application. Note that the default implementation simply returns the given <i>size</i> as it is.</p>
<p>Reimplement this function to use the given device's coordinate system when mapping.</p>
<p><b>See also </b><a href="qscreen.html#mapToDevice">mapToDevice</a>().</p>
<!-- @@@mapFromDevice -->
<!-- $$$mapFromDevice$$$mapFromDeviceconstQPoint&constQSize& -->
<h3 class="fn"><a name="mapFromDevice-2"></a><span class="type"><a href="qpoint.html">QPoint</a></span> QScreen::<span class="name">mapFromDevice</span> ( const <span class="type"><a href="qpoint.html">QPoint</a></span> &amp; <i>point</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>point</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>point</i> as it is.</p>
<!-- @@@mapFromDevice -->
<!-- $$$mapFromDevice$$$mapFromDeviceconstQRect&constQSize& -->
<h3 class="fn"><a name="mapFromDevice-3"></a><span class="type"><a href="qrect.html">QRect</a></span> QScreen::<span class="name">mapFromDevice</span> ( const <span class="type"><a href="qrect.html">QRect</a></span> &amp; <i>rectangle</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>rectangle</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>rectangle</i> as it is.</p>
<!-- @@@mapFromDevice -->
<!-- $$$mapFromDevice$$$mapFromDeviceconstQImage& -->
<h3 class="fn"><a name="mapFromDevice-4"></a><span class="type"><a href="qimage.html">QImage</a></span> QScreen::<span class="name">mapFromDevice</span> ( const <span class="type"><a href="qimage.html">QImage</a></span> &amp; <i>image</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>image</i> from the framebuffer coordinate system to the coordinate space used by the application. Note that the default implementation simply returns the given <i>image</i> as it is.</p>
<!-- @@@mapFromDevice -->
<!-- $$$mapFromDevice$$$mapFromDeviceconstQRegion&constQSize& -->
<h3 class="fn"><a name="mapFromDevice-5"></a><span class="type"><a href="qregion.html">QRegion</a></span> QScreen::<span class="name">mapFromDevice</span> ( const <span class="type"><a href="qregion.html">QRegion</a></span> &amp; <i>region</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>region</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>region</i> as it is.</p>
<!-- @@@mapFromDevice -->
<!-- $$$mapToDevice[overload1]$$$mapToDeviceconstQSize& -->
<h3 class="fn"><a name="mapToDevice"></a><span class="type"><a href="qsize.html">QSize</a></span> QScreen::<span class="name">mapToDevice</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i> ) const<tt> [virtual]</tt></h3>
<p>Maps the given <i>size</i> from the coordinate space used by the application to the framebuffer coordinate system. Note that the default implementation simply returns the given <i>size</i> as it is.</p>
<p>Reimplement this function to use the given device's coordinate system when mapping.</p>
<p><b>See also </b><a href="qscreen.html#mapFromDevice">mapFromDevice</a>().</p>
<!-- @@@mapToDevice -->
<!-- $$$mapToDevice$$$mapToDeviceconstQPoint&constQSize& -->
<h3 class="fn"><a name="mapToDevice-2"></a><span class="type"><a href="qpoint.html">QPoint</a></span> QScreen::<span class="name">mapToDevice</span> ( const <span class="type"><a href="qpoint.html">QPoint</a></span> &amp; <i>point</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>point</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>point</i> as it is.</p>
<!-- @@@mapToDevice -->
<!-- $$$mapToDevice$$$mapToDeviceconstQRect&constQSize& -->
<h3 class="fn"><a name="mapToDevice-3"></a><span class="type"><a href="qrect.html">QRect</a></span> QScreen::<span class="name">mapToDevice</span> ( const <span class="type"><a href="qrect.html">QRect</a></span> &amp; <i>rectangle</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>rectangle</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>rectangle</i> as it is.</p>
<!-- @@@mapToDevice -->
<!-- $$$mapToDevice$$$mapToDeviceconstQImage& -->
<h3 class="fn"><a name="mapToDevice-4"></a><span class="type"><a href="qimage.html">QImage</a></span> QScreen::<span class="name">mapToDevice</span> ( const <span class="type"><a href="qimage.html">QImage</a></span> &amp; <i>image</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>image</i> from the coordinate space used by the application to the framebuffer coordinate system. Note that the default implementation returns the given <i>image</i> as it is.</p>
<!-- @@@mapToDevice -->
<!-- $$$mapToDevice$$$mapToDeviceconstQRegion&constQSize& -->
<h3 class="fn"><a name="mapToDevice-5"></a><span class="type"><a href="qregion.html">QRegion</a></span> QScreen::<span class="name">mapToDevice</span> ( const <span class="type"><a href="qregion.html">QRegion</a></span> &amp; <i>region</i>, const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>screenSize</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>Maps the given <i>region</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>region</i> as it is.</p>
<!-- @@@mapToDevice -->
<!-- $$$offset[overload1]$$$offset -->
<h3 class="fn"><a name="offset"></a><span class="type"><a href="qpoint.html">QPoint</a></span> QScreen::<span class="name">offset</span> () const</h3>
<p>Returns the logical offset of the screen, i.e&#x2e;, the offset between (0,0) in screen coordinates and the application coordinate system.</p>
<p>This function was introduced in Qt 4.2.</p>
<!-- @@@offset -->
<!-- $$$onCard[overload1]$$$onCardconstunsignedchar* -->
<h3 class="fn"><a name="onCard"></a><span class="type">bool</span> QScreen::<span class="name">onCard</span> ( const <span class="type">unsigned</span> <span class="type">char</span> * <i>buffer</i> ) const<tt> [virtual]</tt></h3>
<p>Returns true if the specified <i>buffer</i> is within the graphics card's memory; otherwise returns false (i.e&#x2e; if it's in main RAM).</p>
<p><b>See also </b><a href="qscreen.html#base">base</a>() and <a href="qscreen.html#totalSize">totalSize</a>().</p>
<!-- @@@onCard -->
<!-- $$$onCard$$$onCardconstunsignedchar*ulong& -->
<h3 class="fn"><a name="onCard-2"></a><span class="type">bool</span> QScreen::<span class="name">onCard</span> ( const <span class="type">unsigned</span> <span class="type">char</span> * <i>buffer</i>, <span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> &amp; <i>offset</i> ) const<tt> [virtual]</tt></h3>
<p>This is an overloaded function.</p>
<p>If the specified <i>buffer</i> is within the graphics card's memory, this function stores the offset from the start of graphics card memory (in bytes), in the location specified by the <i>offset</i> parameter.</p>
<!-- @@@onCard -->
<!-- $$$physicalHeight[overload1]$$$physicalHeight -->
<h3 class="fn"><a name="physicalHeight"></a><span class="type">int</span> QScreen::<span class="name">physicalHeight</span> () const</h3>
<p>Returns the physical height of the screen in millimeters.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qscreen.html#height">height</a>(), <a href="qscreen.html#deviceHeight">deviceHeight</a>(), and <a href="qscreen.html#physicalWidth">physicalWidth</a>().</p>
<!-- @@@physicalHeight -->
<!-- $$$physicalWidth[overload1]$$$physicalWidth -->
<h3 class="fn"><a name="physicalWidth"></a><span class="type">int</span> QScreen::<span class="name">physicalWidth</span> () const</h3>
<p>Returns the physical width of the screen in millimeters.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qscreen.html#width">width</a>(), <a href="qscreen.html#deviceWidth">deviceWidth</a>(), and <a href="qscreen.html#physicalHeight">physicalHeight</a>().</p>
<!-- @@@physicalWidth -->
<!-- $$$pixelFormat[overload1]$$$pixelFormat -->
<h3 class="fn"><a name="pixelFormat"></a><span class="type"><a href="qimage.html#Format-enum">QImage::Format</a></span> QScreen::<span class="name">pixelFormat</span> () const</h3>
<p>Returns the pixel format of the screen, or <tt>QImage::Format_Invalid</tt> if the pixel format is not a supported image format.</p>
<p><b>See also </b><a href="qscreen.html#setPixelFormat">setPixelFormat</a>().</p>
<!-- @@@pixelFormat -->
<!-- $$$pixelType[overload1]$$$pixelType -->
<h3 class="fn"><a name="pixelType"></a><span class="type"><a href="qscreen.html#PixelType-enum">PixelType</a></span> QScreen::<span class="name">pixelType</span> () const</h3>
<p>Returns the pixel storage format of the screen.</p>
<!-- @@@pixelType -->
<!-- $$$pixmapDepth[overload1]$$$pixmapDepth -->
<h3 class="fn"><a name="pixmapDepth"></a><span class="type">int</span> QScreen::<span class="name">pixmapDepth</span> () const<tt> [virtual]</tt></h3>
<p>Returns the preferred depth for pixmaps, in bits per pixel.</p>
<p><b>See also </b><a href="qscreen.html#depth">depth</a>().</p>
<!-- @@@pixmapDepth -->
<!-- $$$pixmapLinestepAlignment[overload1]$$$pixmapLinestepAlignment -->
<h3 class="fn"><a name="pixmapLinestepAlignment"></a><span class="type">int</span> QScreen::<span class="name">pixmapLinestepAlignment</span> ()<tt> [virtual]</tt></h3>
<p>Returns the value (in bits) to which individual scanlines of pixmaps held in the graphics card's memory, should be aligned.</p>
<p>Note that the default implementation returns 64; reimplement this function to override the return value, e.g&#x2e;, when implementing an accelerated driver (see the <a href="qt-embedded-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details).</p>
<p><b>See also </b><a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a>().</p>
<!-- @@@pixmapLinestepAlignment -->
<!-- $$$pixmapOffsetAlignment[overload1]$$$pixmapOffsetAlignment -->
<h3 class="fn"><a name="pixmapOffsetAlignment"></a><span class="type">int</span> QScreen::<span class="name">pixmapOffsetAlignment</span> ()<tt> [virtual]</tt></h3>
<p>Returns the value (in bits) to which the start address of pixmaps held in the graphics card's memory, should be aligned.</p>
<p>Note that the default implementation returns 64; reimplement this function to override the return value, e.g&#x2e;, when implementing an accelerated driver (see the <a href="qt-embedded-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details).</p>
<p><b>See also </b><a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a>().</p>
<!-- @@@pixmapOffsetAlignment -->
<!-- $$$region[overload1]$$$region -->
<h3 class="fn"><a name="region"></a><span class="type"><a href="qregion.html">QRegion</a></span> QScreen::<span class="name">region</span> () const<tt> [virtual]</tt></h3>
<p>Returns the region covered by this screen driver.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qscreen.html#base">base</a>() and <a href="qscreen.html#screenSize">screenSize</a>().</p>
<!-- @@@region -->
<!-- $$$restore[overload1]$$$restore -->
<h3 class="fn"><a name="restore"></a><span class="type">void</span> QScreen::<span class="name">restore</span> ()<tt> [virtual]</tt></h3>
<p>Restores the previously saved state of the graphics card.</p>
<p>For example, hardware screen drivers should reimplement the <a href="qscreen.html#save">save</a>() and restore() functions to save and restore its registers, enabling swintching between virtual consoles.</p>
<p>Note that the default implementation does nothing.</p>
<p><b>See also </b><a href="qscreen.html#save">save</a>().</p>
<!-- @@@restore -->
<!-- $$$save[overload1]$$$save -->
<h3 class="fn"><a name="save"></a><span class="type">void</span> QScreen::<span class="name">save</span> ()<tt> [virtual]</tt></h3>
<p>Saves the current state of the graphics card.</p>
<p>For example, hardware screen drivers should reimplement the save() and <a href="qscreen.html#restore">restore</a>() functions to save and restore its registers, enabling swintching between virtual consoles.</p>
<p>Note that the default implementation does nothing.</p>
<p><b>See also </b><a href="qscreen.html#restore">restore</a>().</p>
<!-- @@@save -->
<!-- $$$screenSize[overload1]$$$screenSize -->
<h3 class="fn"><a name="screenSize"></a><span class="type">int</span> QScreen::<span class="name">screenSize</span> () const</h3>
<p>Returns the size of the screen in bytes.</p>
<p>The screen size is always located at the beginning of framebuffer memory, i.e&#x2e; it can also be retrieved using the <a href="qscreen.html#base">base</a>() function.</p>
<p><b>See also </b><a href="qscreen.html#base">base</a>() and <a href="qscreen.html#region">region</a>().</p>
<!-- @@@screenSize -->
<!-- $$$setDirty[overload1]$$$setDirtyconstQRect& -->
<h3 class="fn"><a name="setDirty"></a><span class="type">void</span> QScreen::<span class="name">setDirty</span> ( const <span class="type"><a href="qrect.html">QRect</a></span> &amp; <i>rectangle</i> )<tt> [virtual]</tt></h3>
<p>Marks the given <i>rectangle</i> as dirty.</p>
<p>Note that the default implementation does nothing; reimplement this function to indicate that the given <i>rectangle</i> has been altered.</p>
<!-- @@@setDirty -->
<!-- $$$setMode[overload1]$$$setModeintintint -->
<h3 class="fn"><a name="setMode"></a><span class="type">void</span> QScreen::<span class="name">setMode</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i> )<tt> [pure virtual]</tt></h3>
<p>Implement this function to reset the framebuffer's resolution (<i>width</i> and <i>height</i>) and bit <i>depth</i>.</p>
<p>After the resolution has been set, existing paint engines will be invalid and the framebuffer should be completely redrawn. In a multiple-process situation, all other applications must be notified to reset their mode and update themselves accordingly.</p>
<!-- @@@setMode -->
<!-- $$$setPixelFormat[overload1]$$$setPixelFormatQImage::Format -->
<h3 class="fn"><a name="setPixelFormat"></a><span class="type">void</span> QScreen::<span class="name">setPixelFormat</span> ( <span class="type"><a href="qimage.html#Format-enum">QImage::Format</a></span> <i>format</i> )<tt> [protected]</tt></h3>
<p>Sets the screen's pixel format to <i>format</i>.</p>
<p><b>See also </b><a href="qscreen.html#pixelFormat">pixelFormat</a>().</p>
<!-- @@@setPixelFormat -->
<!-- $$$shutdownDevice[overload1]$$$shutdownDevice -->
<h3 class="fn"><a name="shutdownDevice"></a><span class="type">void</span> QScreen::<span class="name">shutdownDevice</span> ()<tt> [virtual]</tt></h3>
<p>This function is called by the <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> server before it calls the <a href="qscreen.html#disconnect">disconnect</a>() function when exiting.</p>
<p>Note that the default implementation only hides the mouse cursor; reimplement this function to do the necessary graphics card specific cleanup.</p>
<p><b>See also </b><a href="qscreen.html#initDevice">initDevice</a>() and <a href="qscreen.html#disconnect">disconnect</a>().</p>
<!-- @@@shutdownDevice -->
<!-- $$$solidFill[overload1]$$$solidFillconstQColor&constQRegion& -->
<h3 class="fn"><a name="solidFill"></a><span class="type">void</span> QScreen::<span class="name">solidFill</span> ( const <span class="type"><a href="qcolor.html">QColor</a></span> &amp; <i>color</i>, const <span class="type"><a href="qregion.html">QRegion</a></span> &amp; <i>region</i> )<tt> [virtual]</tt></h3>
<p>Fills the given <i>region</i> of the screen with the specified <i>color</i>.</p>
<p>This function is called from the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function; it is not intended to be called explicitly.</p>
<p>Reimplement this function to make use of <a href="qt-embedded-accel.html">accelerated hardware</a>. Note that this function must be reimplemented if the framebuffer format is not supported by <a href="qt-embedded-linux.html">Qt for Embedded Linux</a> (See the <a href="qt-embedded-displaymanagement.html">Display Management</a> documentation for more details).</p>
<p><b>See also </b><a href="qscreen.html#exposeRegion">exposeRegion</a>(), <a href="qscreen.html#blit">blit</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<!-- @@@solidFill -->
<!-- $$$subScreenIndexAt[overload1]$$$subScreenIndexAtconstQPoint& -->
<h3 class="fn"><a name="subScreenIndexAt"></a><span class="type">int</span> QScreen::<span class="name">subScreenIndexAt</span> ( const <span class="type"><a href="qpoint.html">QPoint</a></span> &amp; <i>position</i> ) const</h3>
<p>Returns the index of the subscreen at the given <i>position</i>; returns -1 if no screen is found.</p>
<p>The index identifies the subscreen in the list of pointers returned by the <a href="qscreen.html#subScreens">subScreens</a>() function.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qscreen.html#instance">instance</a>() and <a href="qscreen.html#subScreens">subScreens</a>().</p>
<!-- @@@subScreenIndexAt -->
<!-- $$$subScreens[overload1]$$$subScreens -->
<h3 class="fn"><a name="subScreens"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">QScreen</span> *&gt; QScreen::<span class="name">subScreens</span> () const<tt> [virtual]</tt></h3>
<p>Returns a list of this screen's subscreens. Use the <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>() function to retrieve the index of a screen at a given position.</p>
<p>Note that if <i>this</i> screen consists of several subscreens, operations to <i>this</i> instance will affect all subscreens by default.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="qscreen.html#instance">instance</a>() and <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>().</p>
<!-- @@@subScreens -->
<!-- $$$supportsDepth[overload1]$$$supportsDepthint -->
<h3 class="fn"><a name="supportsDepth"></a><span class="type">bool</span> QScreen::<span class="name">supportsDepth</span> ( <span class="type">int</span> <i>depth</i> ) const<tt> [virtual]</tt></h3>
<p>Returns true if the screen supports the specified color <i>depth</i>; otherwise returns false.</p>
<p><b>See also </b><a href="qscreen.html#clut">clut</a>().</p>
<!-- @@@supportsDepth -->
<!-- $$$totalSize[overload1]$$$totalSize -->
<h3 class="fn"><a name="totalSize"></a><span class="type">int</span> QScreen::<span class="name">totalSize</span> () const</h3>
<p>Returns the size of the available graphics card memory (including the screen) in bytes.</p>
<p><b>See also </b><a href="qscreen.html#onCard">onCard</a>().</p>
<!-- @@@totalSize -->
<!-- $$$transformOrientation[overload1]$$$transformOrientation -->
<h3 class="fn"><a name="transformOrientation"></a><span class="type">int</span> QScreen::<span class="name">transformOrientation</span> () const<tt> [virtual]</tt></h3>
<p>Returns the current rotation as an integer value.</p>
<p>Note that the default implementation returns 0; reimplement this function to override this value.</p>
<p><b>See also </b><a href="qscreen.html#isTransformed">isTransformed</a>().</p>
<!-- @@@transformOrientation -->
<!-- $$$width[overload1]$$$width -->
<h3 class="fn"><a name="width"></a><span class="type">int</span> QScreen::<span class="name">width</span> () const</h3>
<p>Returns the logical width of the framebuffer in pixels.</p>
<p><b>See also </b><a href="qscreen.html#deviceWidth">deviceWidth</a>(), <a href="qscreen.html#physicalWidth">physicalWidth</a>(), and <a href="qscreen.html#height">height</a>().</p>
<!-- @@@width -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
<!-- $$$d -->
<h3 class="fn"><a name="d-var"></a><span class="type">int</span> QScreen::<span class="name">d</span></h3>
<p>This variable holds the pixel depth.</p>
<p>This is the number of significant bits used to set a pixel color. This variable <i>must</i> be initialized by a subclass.</p>
<!-- @@@d -->
<!-- $$$data -->
<h3 class="fn"><a name="data-var"></a><span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * QScreen::<span class="name">data</span></h3>
<p>This variable holds points to the first visible pixel in the frame buffer.</p>
<p>You must initialize this variable if you are using the default implementation of non-buffered painting <a href="qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a>, <a href="qpixmap.html#grabWindow">QPixmap::grabWindow</a>() or <a href="qdirectpainter.html#frameBuffer">QDirectPainter::frameBuffer</a>(). If you initialize this variable, you must also initialize <a href="qscreen.html#size-var">QScreen::size</a> and <a href="qscreen.html#mapsize-var">QScreen::mapsize</a>.</p>
<p><b>See also </b><a href="qscreen.html#size-var">QScreen::size</a> and <a href="qscreen.html#mapsize-var">QScreen::mapsize</a>.</p>
<!-- @@@data -->
<!-- $$$dh -->
<h3 class="fn"><a name="dh-var"></a><span class="type">int</span> QScreen::<span class="name">dh</span></h3>
<p>This variable holds the device height.</p>
<p>This is the number of pixels in a column of the physical screen. It <i>must</i> be initialized by a subclass. Normally, it should be set to the logical height <a href="qscreen.html#h-var">QScreen::h</a>, but it might be different, e.g&#x2e;, if you are doing rotations in software.</p>
<p><b>See also </b><a href="qscreen.html#h-var">QScreen::h</a>.</p>
<!-- @@@dh -->
<!-- $$$dw -->
<h3 class="fn"><a name="dw-var"></a><span class="type">int</span> QScreen::<span class="name">dw</span></h3>
<p>This variable holds the device width.</p>
<p>This is the number of pixels in a row of the physical screen. It <i>must</i> be initialized by a subclass. Normally, it should be set to the logical width <a href="qscreen.html#w-var">QScreen::w</a>, but it might be different, e.g&#x2e;, if you are doing rotations in software.</p>
<p><b>See also </b><a href="qscreen.html#w-var">QScreen::w</a>.</p>
<!-- @@@dw -->
<!-- $$$grayscale -->
<h3 class="fn"><a name="grayscale-var"></a><span class="type">bool</span> QScreen::<span class="name">grayscale</span></h3>
<p>This variable holds the gray scale screen mode flag.</p>
<p>Set this variable to true in a subclass, if you are using a grayscale screen mode. e.g&#x2e;, in an 8-bit mode where you don't want to use the palette, but you want to use the grayscales.</p>
<!-- @@@grayscale -->
<!-- $$$h -->
<h3 class="fn"><a name="h-var"></a><span class="type">int</span> QScreen::<span class="name">h</span></h3>
<p>This variable holds the logical height of the screen.</p>
<p>This variable <i>must</i> be initialized by a subclass.</p>
<!-- @@@h -->
<!-- $$$lstep -->
<h3 class="fn"><a name="lstep-var"></a><span class="type">int</span> QScreen::<span class="name">lstep</span></h3>
<p>This variable holds the number of bytes representing a line in the frame buffer.</p>
<p>i.e&#x2e;, <i>line step</i>. <tt>data[lstep * 2]</tt> is the address of the first visible pixel in the third line of the frame buffer.</p>
<p><b>See also </b><a href="qscreen.html#data-var">data</a>.</p>
<!-- @@@lstep -->
<!-- $$$mapsize -->
<h3 class="fn"><a name="mapsize-var"></a><span class="type">int</span> QScreen::<span class="name">mapsize</span></h3>
<p>This variable holds the total number of bytes in the frame buffer.</p>
<p>This is the total number of bytes in the block pointed to by the <a href="qscreen.html#data-var">QScreen::data</a> pointer. You must initialize this variable if you initialize the <a href="qscreen.html#data-var">QScreen::data</a> pointer.</p>
<p><b>See also </b><a href="qscreen.html#data-var">QScreen::data</a> and <a href="qscreen.html#size-var">QScreen::size</a>.</p>
<!-- @@@mapsize -->
<!-- $$$physHeight -->
<h3 class="fn"><a name="physHeight-var"></a><span class="type">int</span> QScreen::<span class="name">physHeight</span></h3>
<p>This variable holds the physical height of the screen in millimeters.</p>
<p>Currently, this variable is used when calculating the screen DPI, which in turn is used when deciding the actual font size Qt is using.</p>
<!-- @@@physHeight -->
<!-- $$$physWidth -->
<h3 class="fn"><a name="physWidth-var"></a><span class="type">int</span> QScreen::<span class="name">physWidth</span></h3>
<p>This variable holds the physical width of the screen in millimeters.</p>
<p>Currently, this variable is used when calculating the screen DPI, which in turn is used when deciding the actual font size Qt is using.</p>
<!-- @@@physWidth -->
<!-- $$$pixeltype -->
<h3 class="fn"><a name="pixeltype-var"></a><span class="type"><a href="qscreen.html#PixelType-enum">PixelType</a></span> QScreen::<span class="name">pixeltype</span></h3>
<p>This variable holds set to BGRPixel.</p>
<p>Set this variable to <a href="qscreen.html#PixelType-enum">BGRPixel</a> in a subclass, if the screen pixel format is a BGR type and you have used <a href="qscreen.html#setPixelFormat">setPixelFormat</a>() to set the pixel format to the corresponding RGB format. e.g&#x2e;, you have set the pixel format to <a href="qimage.html#Format-enum">QImage::Format_RGB555</a>, but your screen really uses BGR, not RGB.</p>
<!-- @@@pixeltype -->
<!-- $$$screenclut -->
<h3 class="fn"><a name="screenclut-var"></a><span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> QScreen::<span class="name">screenclut</span>[256]</h3>
<p>This variable holds the color table.</p>
<p>Initialize this variable in a subclass using a paletted screen mode, and initialize its partner, <a href="qscreen.html#screencols-var">QScreen::screencols</a>.</p>
<p><b>See also </b><a href="qscreen.html#screencols-var">screencols</a>.</p>
<!-- @@@screenclut -->
<!-- $$$screencols -->
<h3 class="fn"><a name="screencols-var"></a><span class="type">int</span> QScreen::<span class="name">screencols</span></h3>
<p>This variable holds the number of entries in the color table.</p>
<p>Initialize this variable in a subclass using a paletted screen mode, and initialize its partner, <a href="qscreen.html#screenclut-var">QScreen::screenclut</a>.</p>
<p><b>See also </b><a href="qscreen.html#screenclut-var">screenclut</a>.</p>
<!-- @@@screencols -->
<!-- $$$size -->
<h3 class="fn"><a name="size-var"></a><span class="type">int</span> QScreen::<span class="name">size</span></h3>
<p>This variable holds the number of bytes in the visible region of the frame buffer.</p>
<p>This is the number of bytes in the visible part of the block pointed to by the <a href="qscreen.html#data-var">QScreen::data</a> pointer. You must initialize this variable if you initialize the <a href="qscreen.html#data-var">QScreen::data</a> pointer.</p>
<p><b>See also </b><a href="qscreen.html#data-var">QScreen::data</a> and <a href="qscreen.html#mapsize-var">QScreen::mapsize</a>.</p>
<!-- @@@size -->
<!-- $$$w -->
<h3 class="fn"><a name="w-var"></a><span class="type">int</span> QScreen::<span class="name">w</span></h3>
<p>This variable holds the logical width of the screen.</p>
<p>This variable <i>must</i> be initialized by a subclass.</p>
<!-- @@@w -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$setTransformation[overload1]$$$setTransformationintint -->
<h3 class="fn"><a name="setTransformation"></a><span class="type">void</span> QWSDisplay::<span class="name">setTransformation</span> ( <span class="type">int</span> <i>transformation</i>, <span class="type">int</span> <i>screenNo</i> = -1 )<tt> [static]</tt></h3>
<p>Here it is. <i>transformation</i> and <i>screenNo</i></p>
<!-- @@@setTransformation -->
</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
