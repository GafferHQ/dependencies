<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- videowidget.qdoc -->
  <title>Qt 4.8: Video Widget Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="all-examples.html">Examples</a></li>
<li>Video Widget Example</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#videowidgetsurface-class-definition">VideoWidgetSurface Class Definition</a></li>
<li class="level1"><a href="#videowidgetsurface-class-implementation">VideoWidgetSurface Class Implementation</a></li>
<li class="level1"><a href="#videowidget-class-definition">VideoWidget Class Definition</a></li>
<li class="level1"><a href="#videowidget-class-implementation">VideoWidget Class Implementation</a></li>
</ul>
</div>
<h1 class="title">Video Widget Example</h1>
<span class="subtitle"></span>
<!-- $$$multimedia/videowidget-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="multimedia-videowidget-videoplayer-cpp.html">multimedia/videowidget/videoplayer.cpp</a></li>
<li><a href="multimedia-videowidget-videoplayer-h.html">multimedia/videowidget/videoplayer.h</a></li>
<li><a href="multimedia-videowidget-videowidget-cpp.html">multimedia/videowidget/videowidget.cpp</a></li>
<li><a href="multimedia-videowidget-videowidget-h.html">multimedia/videowidget/videowidget.h</a></li>
<li><a href="multimedia-videowidget-videowidgetsurface-cpp.html">multimedia/videowidget/videowidgetsurface.cpp</a></li>
<li><a href="multimedia-videowidget-videowidgetsurface-h.html">multimedia/videowidget/videowidgetsurface.h</a></li>
<li><a href="multimedia-videowidget-main-cpp.html">multimedia/videowidget/main.cpp</a></li>
<li><a href="multimedia-videowidget-videowidget-pro.html">multimedia/videowidget/videowidget.pro</a></li>
</ul>
<p>The Video Widget example shows how to implement a video widget using <a href="qtmultimedia.html">QtMultimedia</a>'s <a href="qabstractvideosurface.html">QAbstractVideoSurface</a><p class="centerAlign"><img src="images/video-videowidget.png" alt="" /></p><a name="videowidgetsurface-class-definition"></a>
<h2>VideoWidgetSurface Class Definition</h2>
<pre class="cpp"> <span class="keyword">class</span> VideoWidgetSurface : <span class="keyword">public</span> <span class="type"><a href="qabstractvideosurface.html">QAbstractVideoSurface</a></span>
 {
     Q_OBJECT
 <span class="keyword">public</span>:
     VideoWidgetSurface(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget<span class="operator">,</span> <span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);

     <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>PixelFormat<span class="operator">&gt;</span> supportedPixelFormats(
             <span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>HandleType handleType <span class="operator">=</span> <span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>NoHandle) <span class="keyword">const</span>;
     <span class="type">bool</span> isFormatSupported(<span class="keyword">const</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">&amp;</span>format<span class="operator">,</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">*</span>similar) <span class="keyword">const</span>;

     <span class="type">bool</span> start(<span class="keyword">const</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">&amp;</span>format);
     <span class="type">void</span> stop();

     <span class="type">bool</span> present(<span class="keyword">const</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span> <span class="operator">&amp;</span>frame);

     <span class="type"><a href="qrect.html">QRect</a></span> videoRect() <span class="keyword">const</span> { <span class="keyword">return</span> targetRect; }
     <span class="type">void</span> updateVideoRect();

     <span class="type">void</span> paint(<span class="type"><a href="qpainter.html">QPainter</a></span> <span class="operator">*</span>painter);

 <span class="keyword">private</span>:
     <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget;
     <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span>Format imageFormat;
     <span class="type"><a href="qrect.html">QRect</a></span> targetRect;
     <span class="type"><a href="qsize.html">QSize</a></span> imageSize;
     <span class="type"><a href="qrect.html">QRect</a></span> sourceRect;
     <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span> currentFrame;
 };</pre>
<p>The VideoWidgetSurface class inherits <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> and paints video frames on a <a href="qwidget.html">QWidget</a>. This is a separate class to VideoWidget as both <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> and <a href="qwidget.html">QWidget</a> inherit <a href="qobject.html">QObject</a>.</p>
<p>In addition to the functions from <a href="qabstractvideosurface.html">QAbstractVideoSurface</a>, VideoWidgetSurface has functions for determining the video display rectangle, and painting the video.</p>
<a name="videowidgetsurface-class-implementation"></a>
<h2>VideoWidgetSurface Class Implementation</h2>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>PixelFormat<span class="operator">&gt;</span> VideoWidgetSurface<span class="operator">::</span>supportedPixelFormats(
         <span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>HandleType handleType) <span class="keyword">const</span>
 {
     <span class="keyword">if</span> (handleType <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>NoHandle) {
         <span class="keyword">return</span> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>PixelFormat<span class="operator">&gt;</span>()
                 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>Format_RGB32
                 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>Format_ARGB32
                 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>Format_ARGB32_Premultiplied
                 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>Format_RGB565
                 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>Format_RGB555;
     } <span class="keyword">else</span> {
         <span class="keyword">return</span> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>PixelFormat<span class="operator">&gt;</span>();
     }
 }</pre>
<p>From the supportedPixelFormats() function we return a list of pixel formats the surface can paint. The order of the list hints at which formats are preferred by the surface. Assuming a 32-bit RGB backbuffer, we'd expect that a 32-bit RGB type with no alpha to be fastest to paint so QVideoFrame::Image_RGB32 is first in the list.</p>
<p>Since we don't support rendering using any special frame handles we don't return any pixel formats if handleType is not <a href="qabstractvideobuffer.html#HandleType-enum">QAbstractVideoBuffer::NoHandle</a>.</p>
<pre class="cpp"> <span class="type">bool</span> VideoWidgetSurface<span class="operator">::</span>isFormatSupported(
         <span class="keyword">const</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">&amp;</span>format<span class="operator">,</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">*</span>similar) <span class="keyword">const</span>
 {
     Q_UNUSED(similar);

     <span class="keyword">const</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span>Format imageFormat <span class="operator">=</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>imageFormatFromPixelFormat(format<span class="operator">.</span>pixelFormat());
     <span class="keyword">const</span> <span class="type"><a href="qsize.html">QSize</a></span> size <span class="operator">=</span> format<span class="operator">.</span>frameSize();

     <span class="keyword">return</span> imageFormat <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span>Format_Invalid
             <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>size<span class="operator">.</span>isEmpty()
             <span class="operator">&amp;</span><span class="operator">&amp;</span> format<span class="operator">.</span>handleType() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>NoHandle;
 }</pre>
<p>In isFormatSupported() we test if the frame type of a surface format maps to a valid <a href="qimage.html">QImage</a> format, that the frame size is not empty, and the handle type is <a href="qabstractvideobuffer.html#HandleType-enum">QAbstractVideoBuffer::NoHandle</a>. Note that the <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> implementation of isFormatSupported() will verify that the list of supported pixel formats returned by <tt>supportedPixelFormats(format.handleType())</tt> contains the pixel format and that the size is not empty so a reimplementation wasn't strictly necessary in this case.</p>
<pre class="cpp"> <span class="type">bool</span> VideoWidgetSurface<span class="operator">::</span>start(<span class="keyword">const</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span> <span class="operator">&amp;</span>format)
 {
     <span class="keyword">const</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span>Format imageFormat <span class="operator">=</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span><span class="operator">::</span>imageFormatFromPixelFormat(format<span class="operator">.</span>pixelFormat());
     <span class="keyword">const</span> <span class="type"><a href="qsize.html">QSize</a></span> size <span class="operator">=</span> format<span class="operator">.</span>frameSize();

     <span class="keyword">if</span> (imageFormat <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span>Format_Invalid <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>size<span class="operator">.</span>isEmpty()) {
         <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>imageFormat <span class="operator">=</span> imageFormat;
         imageSize <span class="operator">=</span> size;
         sourceRect <span class="operator">=</span> format<span class="operator">.</span>viewport();

         <span class="type"><a href="qabstractvideosurface.html">QAbstractVideoSurface</a></span><span class="operator">::</span>start(format);

         widget<span class="operator">-</span><span class="operator">&gt;</span>updateGeometry();
         updateVideoRect();

         <span class="keyword">return</span> <span class="keyword">true</span>;
     } <span class="keyword">else</span> {
         <span class="keyword">return</span> <span class="keyword">false</span>;
     }
 }</pre>
<p>To start our surface we'll extract the image format and size from the selected video format and save it for use in the paint() function. If the image format, or size are invalid then we'll set an error and return false. Otherwise we'll save the format and confirm the surface has been started, by calling <a href="qabstractvideosurface.html#start">QAbstractVideoSurface::start</a>(). Finally since the video size may have changed we'll trigger an update of the widget, and video geometry.</p>
<pre class="cpp"> <span class="type">void</span> VideoWidgetSurface<span class="operator">::</span>updateVideoRect()
 {
     <span class="type"><a href="qsize.html">QSize</a></span> size <span class="operator">=</span> surfaceFormat()<span class="operator">.</span>sizeHint();
     size<span class="operator">.</span>scale(widget<span class="operator">-</span><span class="operator">&gt;</span>size()<span class="operator">.</span>boundedTo(size)<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>KeepAspectRatio);

     targetRect <span class="operator">=</span> <span class="type"><a href="qrect.html">QRect</a></span>(<span class="type"><a href="qpoint.html">QPoint</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>)<span class="operator">,</span> size);
     targetRect<span class="operator">.</span>moveCenter(widget<span class="operator">-</span><span class="operator">&gt;</span>rect()<span class="operator">.</span>center());
 }</pre>
<p>The updateVideoRect() function calculates the region within the widget the video occupies. The <a href="qvideosurfaceformat.html#sizeHint">size hint</a> of the video format gives a suggested size for the video calculated from the <a href="qvideosurfaceformat.html#viewport">viewport</a> and <a href="qvideosurfaceformat.html#pixelAspectRatio">pixel aspect ratio</a>. If the suggested size fits within the widget then we create a new rect of that size in the center of the widget. Otherwise we shrink the size maintaining the aspect ratio so that it does fit.</p>
<pre class="cpp"> <span class="type">bool</span> VideoWidgetSurface<span class="operator">::</span>present(<span class="keyword">const</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span> <span class="operator">&amp;</span>frame)
 {
     <span class="keyword">if</span> (surfaceFormat()<span class="operator">.</span>pixelFormat() <span class="operator">!</span><span class="operator">=</span> frame<span class="operator">.</span>pixelFormat()
             <span class="operator">|</span><span class="operator">|</span> surfaceFormat()<span class="operator">.</span>frameSize() <span class="operator">!</span><span class="operator">=</span> frame<span class="operator">.</span>size()) {
         setError(IncorrectFormatError);
         stop();

         <span class="keyword">return</span> <span class="keyword">false</span>;
     } <span class="keyword">else</span> {
         currentFrame <span class="operator">=</span> frame;

         widget<span class="operator">-</span><span class="operator">&gt;</span>repaint(targetRect);

         <span class="keyword">return</span> <span class="keyword">true</span>;
     }
 }</pre>
<p>We can't paint from outside a paint event, so when a new frame is received in present() we save a reference to it and force an immediate repaint of the video region. We retain the saved reference to the frame after the repaint so that the widget can be repainted between frame changes if necessary.</p>
<p>If the format of the frame doesn't match the surface format we can't paint it or very likely any future frames. So we set an <a href="qabstractvideosurface.html#Error-enum">UnsupportedFormatError</a> on our surface and stop it immediately.</p>
<pre class="cpp"> <span class="type">void</span> VideoWidgetSurface<span class="operator">::</span>paint(<span class="type"><a href="qpainter.html">QPainter</a></span> <span class="operator">*</span>painter)
 {
     <span class="keyword">if</span> (currentFrame<span class="operator">.</span>map(<span class="type"><a href="qabstractvideobuffer.html">QAbstractVideoBuffer</a></span><span class="operator">::</span>ReadOnly)) {
         <span class="keyword">const</span> <span class="type"><a href="qtransform.html">QTransform</a></span> oldTransform <span class="operator">=</span> painter<span class="operator">-</span><span class="operator">&gt;</span>transform();

         <span class="keyword">if</span> (surfaceFormat()<span class="operator">.</span>scanLineDirection() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qvideosurfaceformat.html">QVideoSurfaceFormat</a></span><span class="operator">::</span>BottomToTop) {
            painter<span class="operator">-</span><span class="operator">&gt;</span>scale(<span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>);
            painter<span class="operator">-</span><span class="operator">&gt;</span>translate(<span class="number">0</span><span class="operator">,</span> <span class="operator">-</span>widget<span class="operator">-</span><span class="operator">&gt;</span>height());
         }

         <span class="type"><a href="qimage.html">QImage</a></span> image(
                 currentFrame<span class="operator">.</span>bits()<span class="operator">,</span>
                 currentFrame<span class="operator">.</span>width()<span class="operator">,</span>
                 currentFrame<span class="operator">.</span>height()<span class="operator">,</span>
                 currentFrame<span class="operator">.</span>bytesPerLine()<span class="operator">,</span>
                 imageFormat);

         painter<span class="operator">-</span><span class="operator">&gt;</span>drawImage(targetRect<span class="operator">,</span> image<span class="operator">,</span> sourceRect);

         painter<span class="operator">-</span><span class="operator">&gt;</span>setTransform(oldTransform);

         currentFrame<span class="operator">.</span>unmap();
     }
 }</pre>
<p>The paint() function is called by the video widget to paint the current video frame. Before we draw the frame first we'll check the format for the scan line direction and if the scan lines are arranged from bottom to top we'll flip the painter so the frame isn't drawn upside down. Then using the image format information saved in the start() function we'll construct a new <a href="qimage.html">QImage</a> from the current video frame, and draw it to the the widget.</p>
<pre class="cpp"> <span class="type">void</span> VideoWidgetSurface<span class="operator">::</span>stop()
 {
     currentFrame <span class="operator">=</span> <span class="type"><a href="qvideoframe.html">QVideoFrame</a></span>();
     targetRect <span class="operator">=</span> <span class="type"><a href="qrect.html">QRect</a></span>();

     <span class="type"><a href="qabstractvideosurface.html">QAbstractVideoSurface</a></span><span class="operator">::</span>stop();

     widget<span class="operator">-</span><span class="operator">&gt;</span>update();
 }</pre>
<p>When the surface is stopped we need to release the current frame and invalidate the video region. Then we confirm the surface has been stopped by calling <a href="qabstractvideosurface.html#stop">QAbstractVideoSurface::stop</a>() which sets the started state to false and finally we update so the video widget so paints over the last frame.</p>
<a name="videowidget-class-definition"></a>
<h2>VideoWidget Class Definition</h2>
<p>The VideoWidget class uses the VideoWidgetSurface class to implement a video widget.</p>
<pre class="cpp"> <span class="keyword">class</span> VideoWidget : <span class="keyword">public</span> <span class="type"><a href="qwidget.html">QWidget</a></span>
 {
     Q_OBJECT
 <span class="keyword">public</span>:
     VideoWidget(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);
     <span class="operator">~</span>VideoWidget();

     <span class="type"><a href="qabstractvideosurface.html">QAbstractVideoSurface</a></span> <span class="operator">*</span>videoSurface() <span class="keyword">const</span> { <span class="keyword">return</span> surface; }

     <span class="type"><a href="qsize.html">QSize</a></span> sizeHint() <span class="keyword">const</span>;

 <span class="keyword">protected</span>:
     <span class="type">void</span> paintEvent(<span class="type"><a href="qpaintevent.html">QPaintEvent</a></span> <span class="operator">*</span>event);
     <span class="type">void</span> resizeEvent(<span class="type"><a href="qresizeevent.html">QResizeEvent</a></span> <span class="operator">*</span>event);

 <span class="keyword">private</span>:
     VideoWidgetSurface <span class="operator">*</span>surface;
 };</pre>
<p>The VideoWidget <a href="qwidget.html">QWidget</a> implementation is minimal with just the sizeHint(), paintEvent(), and resizeEvent() functions in addition to the constructor, destructor and an instance of VideoWidgetSurface.</p>
<a name="videowidget-class-implementation"></a>
<h2>VideoWidget Class Implementation</h2>
<pre class="cpp"> VideoWidget<span class="operator">::</span>VideoWidget(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent)
     : <span class="type"><a href="qwidget.html">QWidget</a></span>(parent)
     <span class="operator">,</span> surface(<span class="number">0</span>)
 {
     setAutoFillBackground(<span class="keyword">false</span>);
     setAttribute(<span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>WA_NoSystemBackground<span class="operator">,</span> <span class="keyword">true</span>);
     setAttribute(<span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>WA_PaintOnScreen<span class="operator">,</span> <span class="keyword">true</span>);

     <span class="type"><a href="qpalette.html">QPalette</a></span> palette <span class="operator">=</span> <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>palette();
     palette<span class="operator">.</span>setColor(<span class="type"><a href="qpalette.html">QPalette</a></span><span class="operator">::</span>Background<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>black);
     setPalette(palette);

     setSizePolicy(<span class="type"><a href="qsizepolicy.html">QSizePolicy</a></span><span class="operator">::</span>MinimumExpanding<span class="operator">,</span> <span class="type"><a href="qsizepolicy.html">QSizePolicy</a></span><span class="operator">::</span>MinimumExpanding);

     surface <span class="operator">=</span> <span class="keyword">new</span> VideoWidgetSurface(<span class="keyword">this</span>);
 }</pre>
<p>In the VideoWidget constructor we set some flags to speed up re-paints a little. Setting the <a href="qt.html#WidgetAttribute-enum">Qt::WA_NoSystemBackground</a> flag and disabling automatic background fills will stop Qt from a painting a background that'll be completely obscured by the video. The <a href="qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a> flag will allow us to paint to the screen instead of the back buffer where supported.</p>
<p>Next we set the background color to black, so that any borders around the video are filled in black rather the default background color.</p>
<p>Finally we construct an instance of the VideoWidgetSurface class.</p>
<pre class="cpp"> VideoWidget<span class="operator">::</span><span class="operator">~</span>VideoWidget()
 {
     <span class="keyword">delete</span> surface;
 }</pre>
<p>In the destructor we simply delete the VideoWidgetSurface instance.</p>
<pre class="cpp"> <span class="type"><a href="qsize.html">QSize</a></span> VideoWidget<span class="operator">::</span>sizeHint() <span class="keyword">const</span>
 {
     <span class="keyword">return</span> surface<span class="operator">-</span><span class="operator">&gt;</span>surfaceFormat()<span class="operator">.</span>sizeHint();
 }</pre>
<p>We get the size hint for the widget from the video format of the surface which is calculated from viewport and pixel aspect ratio of the video format.</p>
<pre class="cpp"> <span class="type">void</span> VideoWidget<span class="operator">::</span>paintEvent(<span class="type"><a href="qpaintevent.html">QPaintEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="type"><a href="qpainter.html">QPainter</a></span> painter(<span class="keyword">this</span>);

     <span class="keyword">if</span> (surface<span class="operator">-</span><span class="operator">&gt;</span>isActive()) {
         <span class="keyword">const</span> <span class="type"><a href="qrect.html">QRect</a></span> videoRect <span class="operator">=</span> surface<span class="operator">-</span><span class="operator">&gt;</span>videoRect();

         <span class="keyword">if</span> (<span class="operator">!</span>videoRect<span class="operator">.</span>contains(event<span class="operator">-</span><span class="operator">&gt;</span>rect())) {
             <span class="type"><a href="qregion.html">QRegion</a></span> region <span class="operator">=</span> event<span class="operator">-</span><span class="operator">&gt;</span>region();
             region<span class="operator">.</span>subtract(videoRect);

             <span class="type"><a href="qbrush.html">QBrush</a></span> brush <span class="operator">=</span> palette()<span class="operator">.</span>background();

             foreach (<span class="keyword">const</span> <span class="type"><a href="qrect.html">QRect</a></span> <span class="operator">&amp;</span>rect<span class="operator">,</span> region<span class="operator">.</span>rects())
                 painter<span class="operator">.</span>fillRect(rect<span class="operator">,</span> brush);
         }

         surface<span class="operator">-</span><span class="operator">&gt;</span>paint(<span class="operator">&amp;</span>painter);
     } <span class="keyword">else</span> {
         painter<span class="operator">.</span>fillRect(event<span class="operator">-</span><span class="operator">&gt;</span>rect()<span class="operator">,</span> palette()<span class="operator">.</span>background());
     }
 }</pre>
<p>When the video widget receives a paint event we first check if the surface is started, if not then we simply fill the widget with the background color. If it is then we draw a border around the video region clipped by the paint region, before calling paint on the video surface to draw the current frame.</p>
<pre class="cpp"> <span class="type">void</span> VideoWidget<span class="operator">::</span>resizeEvent(<span class="type"><a href="qresizeevent.html">QResizeEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="type"><a href="qwidget.html">QWidget</a></span><span class="operator">::</span>resizeEvent(event);

     surface<span class="operator">-</span><span class="operator">&gt;</span>updateVideoRect();
 }</pre>
<p>The resizeEvent() function is reimplemented to trigger an update of the video region when the widget is resized.</p>
</div>
<!-- @@@multimedia/videowidget -->
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
