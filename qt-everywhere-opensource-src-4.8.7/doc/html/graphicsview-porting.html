<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- porting4-canvas.qdoc -->
  <title>Qt 4.8: Porting to Graphics View</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li>Porting to Graphics View</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
  <link rel="prev" href="porting4-designer.html" />
  <link rel="next" href="qt3to4.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="porting4-designer.html">Porting UI Files to Qt 4</a>
<a class="nextPage" href="qt3to4.html">qt3to4 - The Qt 3 to 4 Porting Tool</a>
</p><p/>
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#porting-from-q3canvas">Porting from Q3Canvas</a></li>
<li class="level2"><a href="#porting-table">Porting table</a></li>
<li class="level2"><a href="#porting-scenes-with-tiles">Porting scenes with tiles</a></li>
<li class="level1"><a href="#porting-from-q3canvasview">Porting from Q3CanvasView</a></li>
<li class="level2"><a href="#porting-table">Porting table</a></li>
<li class="level2"><a href="#other-differences">Other differences</a></li>
<li class="level1"><a href="#porting-from-q3canvasitem">Porting from Q3CanvasItem</a></li>
<li class="level2"><a href="#q3canvaspolygonalitem">Q3CanvasPolygonalItem</a></li>
<li class="level2"><a href="#q3canvasellipse">Q3CanvasEllipse</a></li>
<li class="level2"><a href="#q3canvasline">Q3CanvasLine</a></li>
<li class="level2"><a href="#q3canvaspolygon">Q3CanvasPolygon</a></li>
<li class="level2"><a href="#q3canvasspline">Q3CanvasSpline</a></li>
<li class="level2"><a href="#q3canvasrectangle">Q3CanvasRectangle</a></li>
<li class="level2"><a href="#q3canvassprite">Q3CanvasSprite</a></li>
<li class="level3"><a href="#q3canvaspixmap-q3canvaspixmaparray">Q3CanvasPixmap, Q3CanvasPixmapArray</a></li>
<li class="level2"><a href="#q3canvastext">Q3CanvasText</a></li>
<li class="level2"><a href="#q3canvasitemlist">Q3CanvasItemList</a></li>
<li class="level1"><a href="#other-resources">Other Resources</a></li>
</ul>
</div>
<h1 class="title">Porting to Graphics View</h1>
<span class="subtitle"></span>
<!-- $$$graphicsview-porting.html-description -->
<div class="descr"> <a name="details"></a>
<a name="qgraphicsview-graphicsview-porting-graphics-canvas"></a><p>Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation. Graphics View was introduced in Qt 4.2, replacing its predecessor, <a href="porting4.html#qcanvas">QCanvas</a>. For more on Graphics View, see <a href="graphicsview.html">Graphics View Framework</a>.</p>
<p>This document walks through the steps needed, class by class and function by function, to port a <a href="porting4.html#qcanvas">QCanvas</a> application to Graphics View.</p>
<p>Qt 4.2 provides two complete examples of <a href="q3canvas.html" class="compat">Q3Canvas</a> applications ported to Graphics View:</p>
<ul>
<li><a href="graphicsview-portedcanvas.html">Ported Canvas Example</a>, the canvas example from Qt 3.</li>
<li><a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, the Asteroids game from the Qt 3 demo.</li>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>Conceptually, the Graphics View classes from Qt 4 and the Canvas classes from Qt 3 provide similar functionality using a similar design. Instead of &quot;canvas&quot;, we use the term &quot;scene&quot;. Otherwise, the class names and functions are almost the same as in Qt 3. The easiest classes to port will be <a href="porting4.html#qcanvas">QCanvas</a> and QCanvasView. Experience shows that most time is spent porting the item classes, depending on the complexity of the QCanvasItem classes you have been using before.</p>
<p>This porting guide will assume you have already ported your application to Qt 4, by making use of <a href="q3canvas.html" class="compat">Q3Canvas</a>. If you have not done so already, as a first step, run the <a href="qt3to4.html#qt3to4">qt3to4</a> tool on your project. This tool will automate the most tedious part of the porting effort.</p>
<p>Some additional steps are usually required before your application will compile and run. You can read more about the porting process in <a href="porting4.html">Porting to Qt 4</a>.</p>
<a name="porting-from-q3canvas"></a>
<h2>Porting from Q3Canvas</h2>
<p><a href="qgraphicsscene.html">QGraphicsScene</a> is the closest equivalent to <a href="q3canvas.html" class="compat">Q3Canvas</a>. There are some noticable differences in this new API: Whereas the <a href="q3canvas.html" class="compat">Q3Canvas</a> classes use integer precision, <a href="qgraphicsscene.html">QGraphicsScene</a> is entirely based on double coordinates, with graphical primitives such as <a href="qpointf.html">QPointF</a> instead of <a href="qpoint.html">QPoint</a>, <a href="qrectf.html">QRectF</a> instead of <a href="qrect.html">QRect</a>, and <a href="qpolygonf.html">QPolygonF</a> and <a href="qpainterpath.html">QPainterPath</a>. The canvas area is defined by a scene rectangle, allowing negative coordinates, as opposed to <a href="q3canvas.html" class="compat">Q3Canvas</a>, which only defines a size (<a href="qsize.html">QSize</a>), and whose top-left corner is always (0, 0).</p>
<p>In addition, there is no explicit support for canvas tiles anymore; see <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a> for more information. The chunks-based indexing system has been replaced with an implicitly maintained internal BSP tree.</p>
<a name="porting-table"></a>
<h3>Porting table</h3>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvas.html" class="compat">Q3Canvas</a></th><th ><a href="qgraphicsscene.html">QGraphicsScene</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#Q3Canvas">Q3Canvas::Q3Canvas</a>()</td><td >There is no <a href="qpixmap.html">QPixmap</a> based constructor, and the concept of tiles is gone. You can use <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> to set a brush pattern for the background, or reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() in a <a href="qgraphicsscene.html">QGraphicsScene</a> subclass (see <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>). In addition, the <a href="qgraphicsscene.html">QGraphicsScene</a> geometry is provided as a full <a href="qrectf.html">QRectF</a>. Instead of <a href="q3canvas.html" class="compat">Q3Canvas</a>(int width, int height), you can use <a href="qgraphicsscene.html">QGraphicsScene</a>(int top, int left, int width, int height).</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#allItems">Q3Canvas::allItems</a>()</td><td ><a href="qgraphicsscene.html#items">QGraphicsScene::items</a>() returns a list of all items on the scene.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#backgroundColor">Q3Canvas::backgroundColor</a>()</td><td >You can assign a color for the background through the <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> or <a href="qgraphicsview.html#backgroundBrush-prop">QGraphicsView::backgroundBrush</a> properties.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#backgroundPixmap">Q3Canvas::backgroundPixmap</a>()</td><td >You can set a tiled pixmap for the background through <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> or <a href="qgraphicsview.html#backgroundBrush-prop">QGraphicsView::backgroundBrush</a>. For more control on the pixmap positioning, you can reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() or <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>().</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#chunkSize">Q3Canvas::chunkSize</a>()</td><td >The closest equivalent to the chunks size in <a href="q3canvas.html" class="compat">Q3Canvas</a> is the depth of <a href="qgraphicsscene.html">QGraphicsScene</a>'s BSP tree. <a href="qgraphicsscene.html">QGraphicsScene</a> assigns a depth automatically, and the size of each scene segment depends on this depth, and <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>(). See <a href="qgraphicsscene.html#itemIndexMethod-prop">QGraphicsScene::itemIndexMethod</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#collisions">Q3Canvas::collisions</a>()</td><td ><a href="qgraphicsscene.html">QGraphicsScene</a> provides several means to detect item collisions. The <a href="qgraphicsscene.html#items">QGraphicsScene::items</a>() overloads return items that collide with a point, a rectangle, a polygon, or an arbitrary vector path (<a href="qpainterpath.html">QPainterPath</a>). You can also call <a href="qgraphicsscene.html#collidingItems">QGraphicsScene::collidingItems</a>() to determine collision with an item.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#drawArea">Q3Canvas::drawArea</a>()</td><td >The <a href="qgraphicsscene.html#render">QGraphicsScene::render</a>() function provides the original behavior <a href="q3canvas.html#drawArea">Q3Canvas::drawArea</a>(). In addition, you can pass a source rectangle for rendering only parts of the scene, and a destination rectangle for rendering onto designated area of the destination device. <a href="qgraphicsscene.html#render">QGraphicsScene::render</a>() can optionally transform the source rectangle to fit into the destination rectangle. See <a href="graphicsview.html#printing">Printing</a></td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#onCanvas">Q3Canvas::onCanvas</a>()</td><td >The is no equivalent to this function in Graphics View. However, you can combine <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>() and <a href="qrectf.html#intersects">QRectF::intersects</a>():<pre class="cpp"> item<span class="operator">-</span><span class="operator">&gt;</span>scene()<span class="operator">.</span>sceneRect()<span class="operator">.</span>intersects(item<span class="operator">-</span><span class="operator">&gt;</span>sceneBoundingRect());</pre>
</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#rect">Q3Canvas::rect</a>()</td><td >The equivalent, <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>(), returns a <a href="qrectf.html">QRectF</a> (double precision coordinates). Its top-left corner can be an arbitrary coordinate (<a href="q3canvas.html#rect">Q3Canvas::rect</a>().topLeft() is always (0, 0)).</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#resize">Q3Canvas::resize</a>()</td><td >You can call QGraphicsScene::setSceneRect(0, 0, width, height) instead.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#retune">Q3Canvas::retune</a>()</td><td >See <a href="qgraphicsscene.html#itemIndexMethod-prop">QGraphicsScene::itemIndexMethod</a>. You can tune the indexing by setting a suitable sceneRect(). The optimal depth of <a href="qgraphicsscene.html">QGraphicsScene</a>'s BSP tree is determined automatically.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#setAdvancePeriod">Q3Canvas::setAdvancePeriod</a>()</td><td >There is no concept of an advance period in the new API; instead, you can connect <a href="qtimer.html#timeout">QTimer::timeout</a>() to the <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() slot to obtain similar functionality. This will cause all items' <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() function to be called. See also <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#setAllChanged">Q3Canvas::setAllChanged</a>()</td><td >You can call <a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() with no arguments.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#setChanged">Q3Canvas::setChanged</a>()</td><td ><a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() will trigger a repaint of the whole scene, or parts of the scene.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#setDoubleBuffering">Q3Canvas::setDoubleBuffering</a>()</td><td ><a href="q3canvas.html" class="compat">Q3Canvas</a>' double buffering enabled cacheing of the scene contents in device (i.e&#x2e;, viewport) coordinates. This cache layer has been moved to the view instead; you can cache <a href="qgraphicsscene.html">QGraphicsScene</a>'s background through <a href="qgraphicsview.html#cacheMode-prop">QGraphicsView::setCacheMode</a>(). <a href="qgraphicsview.html#resetCachedContent">QGraphicsView::resetCachedContent</a>() will reset the areas of the cache that has changed.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#tile">Q3Canvas::tile</a>()</td><td >See <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#setTiles">Q3Canvas::setTiles</a>()</td><td >See <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#setUnchanged">Q3Canvas::setUnchanged</a>()</td><td >There is no equivalent in Graphics View. This call can usually be removed with no side effects.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#setUpdatePeriod">Q3Canvas::setUpdatePeriod</a>()</td><td >There is no concept of an update period in the new API; instead, you can connect <a href="qtimer.html#timeout">QTimer::timeout</a>() to the <a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() slot to obtain similar functionality. See also <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#size">Q3Canvas::size</a>()</td><td ><tt><a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>().size()</tt> returns a <a href="qsizef.html">QSizeF</a>, with double precision coordinates.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#validChunk">Q3Canvas::validChunk</a>()</td><td >To determine if an area is inside the scene area or not, you can combine <a href="qrectf.html#intersects">QRectF::intersects</a>() with <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#resized">Q3Canvas::resized</a>()</td><td ><a href="qgraphicsscene.html">QGraphicsScene</a> emits <a href="qgraphicsscene.html#sceneRectChanged">sceneRectChanged()</a> whenever the scene rect changes.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvas.html#drawBackground">Q3Canvas::drawBackground</a>()</td><td >You can reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() to render the scene background. You can also reimplement <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>() to override this background if you need different backgrounds for different views.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvas.html#drawForeground">Q3Canvas::drawForeground</a>()</td><td >You can reimplement <a href="qgraphicsscene.html#drawForeground">QGraphicsScene::drawForeground</a>() to render the scene foreground. You can also reimplement <a href="qgraphicsview.html#drawForeground">QGraphicsView::drawForeground</a>() to override this foreground if you need different foregrounds for different views.</td></tr>
</table>
<a name="porting-scenes-with-tiles"></a>
<h3>Porting scenes with tiles</h3>
<p><a href="qgraphicsscene.html">QGraphicsScene</a> does not provide an API for tiles. However, you can achieve similar behavior by drawing pixmaps in a reimplementation of <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>().</p>
<p><a href="q3canvas.html" class="compat">Q3Canvas</a>' tile support is based on providing one pixmap containing tiles of a fixed width and height, and then accessing them (reading and replacing tiles) by index. The tiles in the pixmap are arranged from the left to right, top to bottom.</p>
<table class="generic">
<tr valign="top" class="odd"><td >0</td><td >1</td><td >2</td><td >3</td></tr>
<tr valign="top" class="even"><td >4</td><td >5</td><td >6</td><td >7</td></tr>
</table>
<p>With Graphics View, this pixmap can be stored as a member of a subclass of <a href="qgraphicsscene.html">QGraphicsScene</a>. The three main functions that make out the public tile API can then be declared as new members of this class. Here is one example of how to implement tile support:</p>
<pre class="cpp"> <span class="keyword">class</span> TileScene : <span class="keyword">public</span> <span class="type"><a href="qgraphicsscene.html">QGraphicsScene</a></span>
 {
 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

     <span class="type">void</span> setTiles(<span class="keyword">const</span> <span class="type"><a href="qpixmap.html">QPixmap</a></span> <span class="operator">&amp;</span>pixmap<span class="operator">,</span> <span class="type">int</span> h<span class="operator">,</span> <span class="type">int</span> v<span class="operator">,</span>
                   <span class="type">int</span> tileHeight<span class="operator">,</span> <span class="type">int</span> tileWidth);
     <span class="type">void</span> setTile(<span class="type">int</span> x<span class="operator">,</span> <span class="type">int</span> y<span class="operator">,</span> <span class="type">int</span> tilenum);

 <span class="keyword">private</span>:
     <span class="type"><a href="qrect.html">QRect</a></span> tileRect(<span class="type">int</span> x<span class="operator">,</span> <span class="type">int</span> y) <span class="keyword">const</span>;
     <span class="type"><a href="qrect.html">QRect</a></span> tileRect(<span class="type">int</span> tileNum) <span class="keyword">const</span>;

     <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&gt;</span> tiles;
     <span class="type"><a href="qpixmap.html">QPixmap</a></span> tilePixmap;
     <span class="type">int</span> tileW<span class="operator">,</span> tileH;
     <span class="type">int</span> hTiles<span class="operator">,</span> vTiles;
 };</pre>
<p>Depending on how your scene uses tiles, you may be able to simplify this approach. In this example, we will try to mimic the behavior of the <a href="q3canvas.html" class="compat">Q3Canvas</a> functions.</p>
<p>We start by creating a subclass of <a href="qgraphicsscene.html">QGraphicsScene</a> (&quot;TileScene&quot;). In this class, we declare two of the tile functions from <a href="q3canvas.html" class="compat">Q3Canvas</a>, and we then add two helper function that returns the rectangle for a certain tile in our tile pixmap. We will use a two-dimensional vector of ints to keep track of what tiles should be used at what parts of the scene.</p>
<pre class="cpp"> <span class="type">void</span> TileScene<span class="operator">::</span>setTiles(<span class="keyword">const</span> <span class="type"><a href="qpixmap.html">QPixmap</a></span> <span class="operator">&amp;</span>pixmap<span class="operator">,</span> <span class="type">int</span> h<span class="operator">,</span> <span class="type">int</span> v<span class="operator">,</span>
                          <span class="type">int</span> tileHeight<span class="operator">,</span> <span class="type">int</span> tileWidth)
 {
     tilePixmap <span class="operator">=</span> pixmap;
     tileW <span class="operator">=</span> tileWidth;
     tileH <span class="operator">=</span> tileHeight;
     hTiles <span class="operator">=</span> h;
     vTiles <span class="operator">=</span> v;

     tiles<span class="operator">.</span>resize(v);
     <span class="keyword">for</span> (<span class="type">int</span> y <span class="operator">=</span> <span class="number">0</span>; y <span class="operator">&lt;</span> v; <span class="operator">+</span><span class="operator">+</span>y)
         tiles<span class="operator">[</span>y<span class="operator">]</span><span class="operator">.</span>resize(h);
 }</pre>
<p>In setTiles(), we store the pixmap and tile properties as members of the class. Then we resize the tiles vector to match the width and height of our tile grid.</p>
<pre class="cpp"> <span class="type">void</span> TileScene<span class="operator">::</span>setTile(<span class="type">int</span> x<span class="operator">,</span> <span class="type">int</span> y<span class="operator">,</span> <span class="type">int</span> tilenum)
 {
     tiles<span class="operator">[</span>y<span class="operator">]</span><span class="operator">[</span>x<span class="operator">]</span> <span class="operator">=</span> tilenum;
     update(tileRect(x<span class="operator">,</span> y));
 }</pre>
<p>The setTile() function updates the tiles index, and then updates the corresponding rect in the scene by calling tileRect().</p>
<pre class="cpp"> <span class="type"><a href="qrect.html">QRect</a></span> TileScene<span class="operator">::</span>tileRect(<span class="type">int</span> x<span class="operator">,</span> <span class="type">int</span> y) <span class="keyword">const</span>
 {
     <span class="keyword">return</span> <span class="type"><a href="qrect.html">QRect</a></span>(x <span class="operator">*</span> tileW<span class="operator">,</span> y <span class="operator">*</span> tileH<span class="operator">,</span> tileW<span class="operator">,</span> tileH);
 }</pre>
<p>The first tileRect() function returns a <a href="qrect.html">QRect</a> for the tile at position (x, y).</p>
<pre class="cpp"> <span class="type"><a href="qrect.html">QRect</a></span> TileScene<span class="operator">::</span>tileRect(<span class="type">int</span> tileNum) <span class="keyword">const</span>
 {
     <span class="type">int</span> numHTiles <span class="operator">=</span> tilePixmap<span class="operator">.</span>width() <span class="operator">/</span> tileW;
     <span class="type">int</span> numVTiles <span class="operator">=</span> tilePixmap<span class="operator">.</span>height() <span class="operator">/</span> tileH;
     <span class="keyword">return</span> tileRect(tileNum <span class="operator">%</span> numHTiles<span class="operator">,</span> tileNum <span class="operator">/</span> numHTiles);
 }</pre>
<p>The second tileRect() function returns a <a href="qrect.html">QRect</a> for a tile number. With these functions in place, we can implement the drawBackground() function.</p>
<pre class="cpp"> <span class="type">void</span> drawBackground(<span class="type"><a href="qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qrectf.html">QRectF</a></span> <span class="operator">&amp;</span>exposed)
 {
     <span class="keyword">for</span> (<span class="type">int</span> y <span class="operator">=</span> <span class="number">0</span>; y <span class="operator">&lt;</span> vTiles; <span class="operator">+</span><span class="operator">+</span>y) {
         <span class="keyword">for</span> (<span class="type">int</span> x <span class="operator">=</span> <span class="number">0</span>; x <span class="operator">&lt;</span> hTiles; <span class="operator">+</span><span class="operator">+</span>x) {
             <span class="type"><a href="qrect.html">QRect</a></span> destRect <span class="operator">=</span> tileRect(x<span class="operator">,</span> y);
             <span class="keyword">if</span> (exposed<span class="operator">.</span>intersects(destRect)) {
                 painter<span class="operator">-</span><span class="operator">&gt;</span>drawPixmap(destRect<span class="operator">,</span> tilePixmap<span class="operator">,</span>
                                     tileRect(tiles<span class="operator">[</span>y<span class="operator">]</span><span class="operator">[</span>x<span class="operator">]</span>));
             }
         }
     }
 }</pre>
<p>In drawBackground(), we redraw all tiles that have been exposed by intersecting each tile rect with the exposed background area.</p>
<a name="porting-from-q3canvasview"></a>
<h2>Porting from Q3CanvasView</h2>
<p>The closest equivalent to <a href="q3canvasview.html" class="compat">Q3CanvasView</a> in Graphics View is called <a href="qgraphicsview.html">QGraphicsView</a>. In most cases, this is the easiest class to port. In addition to providing all of <a href="q3canvasview.html" class="compat">Q3CanvasView</a>'s functionality, <a href="qgraphicsview.html">QGraphicsView</a> includes some useful new features. You can read more about this in <a href="qgraphicsview.html">QGraphicsView</a>'s documentation.</p>
<a name="porting-table"></a>
<h3>Porting table</h3>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasview.html" class="compat">Q3CanvasView</a></th><th ><a href="qgraphicsview.html">QGraphicsView</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasview.html#Q3CanvasView">Q3CanvasView::Q3CanvasView</a>()</td><td ><a href="qgraphicsview.html">QGraphicsView</a> provides the same constructors as <a href="q3canvasview.html" class="compat">Q3CanvasView</a>, but without the name and flags arguments. You can set the name by calling <a href="qobject.html#objectName-prop">setObjectName()</a>, and the flags by calling <a href="qwidget.html#windowFlags-prop">setWindowFlags()</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasview.html#canvas">Q3CanvasView::canvas</a>()</td><td ><a href="qgraphicsview.html#scene">QGraphicsView::scene</a>() returns the scene that is currently associated with the view. <a href="qgraphicsscene.html">QGraphicsScene</a> also provides the opposite function, <a href="qgraphicsscene.html#views">QGraphicsScene::views</a>(), which returns a list of views observing the scene.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasview.html#inverseWorldMatrix">Q3CanvasView::inverseWorldMatrix</a>()</td><td >You can call <a href="qgraphicsview.html#matrix">QGraphicsView::matrix</a>() and <a href="qmatrix.html#inverted">QMatrix::inverted</a>(). <a href="qgraphicsview.html#mapToScene">QGraphicsView::mapToScene</a>() and <a href="qgraphicsview.html#mapFromScene">QGraphicsView::mapFromScene</a>() allow transforming of viewport shapes to scene shapes, and vice versa.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasview.html#setCanvas">Q3CanvasView::setCanvas</a>()</td><td ><a href="qgraphicsview.html#setScene">QGraphicsView::setScene</a>().</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasview.html#setWorldMatrix">Q3CanvasView::setWorldMatrix</a>()</td><td ><a href="qgraphicsview.html#setMatrix">QGraphicsView::setMatrix</a>(), <a href="qgraphicsview.html#rotate">QGraphicsView::rotate</a>(), <a href="qgraphicsview.html#scale">QGraphicsView::scale</a>(), <a href="qgraphicsview.html#shear">QGraphicsView::shear</a>() and <a href="qgraphicsview.html#translate">QGraphicsView::translate</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasview.html#worldMatrix">Q3CanvasView::worldMatrix</a>()</td><td ><a href="qgraphicsview.html#matrix">QGraphicsView::matrix</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasview.html#drawContents">Q3CanvasView::drawContents</a>()</td><td >The <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>() function draws the background, <a href="qgraphicsview-obsolete.html#drawItems" class="obsolete">QGraphicsView::drawItems</a>() draws the items, and <a href="qgraphicsview.html#drawForeground">QGraphicsView::drawForeground</a>() draws the foreground of the scene in scene coordinates. You can also reimplement these functions in <a href="qgraphicsscene.html">QGraphicsScene</a>.</td></tr>
</table>
<a name="other-differences"></a>
<h3>Other differences</h3>
<p><a href="qgraphicsview.html">QGraphicsView</a> can cache the visible contents of the scene, similar to how <a href="q3canvas.html#setDoubleBuffering">Q3Canvas::setDoubleBuffering</a>() could cache the entire scene contents. You can call <a href="qgraphicsview.html#cacheMode-prop">QGraphicsView::setCacheMode</a>() to configure cacheing, and <a href="qgraphicsview.html#resetCachedContent">QGraphicsView::resetCachedContent</a>() invalidates the cache.</p>
<p>For improved navigation support, you can set a resize or transformation anchor through <a href="qgraphicsview.html#resizeAnchor-prop">QGraphicsView::resizeAnchor</a> and <a href="qgraphicsview.html#transformationAnchor-prop">QGraphicsView::transformationAnchor</a>. This allows you to easily rotate and zoom the view while keeping the center fixed, or zooming towards the position under the mouse cursor. In addition, if you set the <a href="qgraphicsview.html#dragMode-prop">QGraphicsView::dragMode</a> of the view, <a href="qgraphicsview.html">QGraphicsView</a> will provide rubber band selection or click-and-pull navigation using the <a href="qt.html#CursorShape-enum">OpenHandCursor</a> and <a href="qt.html#CursorShape-enum">ClosedHandCursor</a> cursors.</p>
<a name="porting-from-q3canvasitem"></a>
<h2>Porting from Q3CanvasItem</h2>
<p>The closest equivalent to <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> in Graphics View is called <a href="qgraphicsitem.html">QGraphicsItem</a>. Deriving from this class is very common, and because of that, porting from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> often involves more work than <a href="q3canvas.html" class="compat">Q3Canvas</a> and <a href="q3canvasview.html" class="compat">Q3CanvasView</a>.</p>
<p><a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> has become easier to use, easier to subclass, and more powerful with <a href="qgraphicsitem.html">QGraphicsItem</a>. The key difference from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> lies in event propagation and item groups, but you will also find several convenient new features, such as support for tooltips, cursors, item transformation and drag and drop. You can read all about <a href="qgraphicsitem.html">QGraphicsItem</a> in its own class documentation.</p>
<p>This section starts with a table that shows how to port each function from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> to <a href="qgraphicsitem.html">QGraphicsItem</a>. Immediately after that, each of <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>'s standard subclasses have a section of their own.</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasitem.html" class="compat">Q3CanvasItem</a></th><th ><a href="qgraphicsitem.html">QGraphicsItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#advance">Q3CanvasItem::advance</a>()</td><td ><a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() is provided for compatibility. <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() calls <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() for all items. See also <a href="qtimeline.html">QTimeLine</a> and <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#animated">Q3CanvasItem::animated</a>()</td><td >No equivalent; all items are advanced by <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>().</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#boundingRectAdvanced">Q3CanvasItem::boundingRectAdvanced</a>()</td><td >No equivalent. You can translate <a href="qgraphicsitem.html#boundingRect">QGraphicsItem::boundingRect</a>() instead (see <a href="qrectf.html#translate">QRectF::translate</a>()).</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#canvas">Q3CanvasItem::canvas</a>()</td><td ><a href="qgraphicsitem.html#scene">QGraphicsItem::scene</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#collidesWith">Q3CanvasItem::collidesWith</a>()</td><td ><a href="qgraphicsitem.html#collidesWithItem">QGraphicsItem::collidesWithItem</a>() and <a href="qgraphicsitem.html#collidesWithPath">QGraphicsItem::collidesWithPath</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#collisions">Q3CanvasItem::collisions</a>()</td><td ><a href="qgraphicsitem.html#collidingItems">QGraphicsItem::collidingItems</a>() returns a list of all items that collide with an item. You can specify whether you want fast, rough estimate collision between bounding rectangles, or the slower, more accurate shapes.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#draw">Q3CanvasItem::draw</a>()</td><td ><a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>(). See also <a href="qstyleoptiongraphicsitem.html">QStyleOptionGraphicsItem</a>, <a href="qgraphicsscene-obsolete.html#drawItems" class="obsolete">QGraphicsScene::drawItems</a>() and <a href="qgraphicsview-obsolete.html#drawItems" class="obsolete">QGraphicsView::drawItems</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#hide">Q3CanvasItem::hide</a>()</td><td ><a href="qgraphicsitem.html#hide">QGraphicsItem::hide</a>() or <a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#isActive">Q3CanvasItem::isActive</a>()</td><td >No equivalent. To achieve similar behavior, you can add this property in a custom subclass of <a href="qgraphicsitem.html">QGraphicsItem</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#isVisible">Q3CanvasItem::isVisible</a>()</td><td ><a href="qgraphicsitem.html#isVisible">QGraphicsItem::isVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#move">Q3CanvasItem::move</a>()</td><td >You can call <a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>() to change the position of the item.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#rtti">Q3CanvasItem::rtti</a>()</td><td ><a href="qgraphicsitem.html#type">QGraphicsItem::type</a>() and <a href="qgraphicsitem.html#qgraphicsitem_cast">qgraphicsitem_cast</a>().</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#setActive">Q3CanvasItem::setActive</a>()</td><td >No equivalent.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#setAnimated">Q3CanvasItem::setAnimated</a>()</td><td >No equivalent; all items are by default &quot;animated&quot; (i.e&#x2e;, <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() advances all items on the scene).</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#setCanvas">Q3CanvasItem::setCanvas</a>()</td><td >You can call <a href="qgraphicsscene.html#addItem">QGraphicsScene::addItem</a>(), or pass a pointer to the canvas to <a href="qgraphicsitem.html">QGraphicsItem</a>'s constructor.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#setVelocity">Q3CanvasItem::setVelocity</a>()</td><td >No equivalent. You can add x and y velocity as member data of your class, and call QGraphicsItem::moveBy(x, y) from inside <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>(). See also <a href="qtimeline.html">QTimeLine</a> and <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#setVisible">Q3CanvasItem::setVisible</a>()</td><td ><a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#setX">Q3CanvasItem::setX</a>()</td><td ><a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#setY">Q3CanvasItem::setY</a>()</td><td ><a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#setXVelocity">Q3CanvasItem::setXVelocity</a>()</td><td >No equivalent.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#setYVelocity">Q3CanvasItem::setYVelocity</a>()</td><td >No equivalent.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#setZ">Q3CanvasItem::setZ</a>()</td><td ><a href="qgraphicsitem.html#setZValue">QGraphicsItem::setZValue</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#show">Q3CanvasItem::show</a>()</td><td ><a href="qgraphicsitem.html#show">QGraphicsItem::show</a>() or <a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasitem.html#xVelocity">Q3CanvasItem::xVelocity</a>()</td><td >No equivalent.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasitem.html#yVelocity">Q3CanvasItem::yVelocity</a>()</td><td >No equivalent.</td></tr>
</table>
<p>Note that some virtual functions that have passed on to <a href="qgraphicsitem.html">QGraphicsItem</a> have lost their virtuality. An example is <a href="q3canvasitem.html#moveBy">Q3CanvasItem::moveBy</a>(), which was often used to track movement of items. In this case, the virtual <a href="qgraphicsitem.html#itemChange">QGraphicsItem::itemChange</a>() has taken over as a substitute.</p>
<a name="q3canvaspolygonalitem"></a>
<h3>Q3CanvasPolygonalItem</h3>
<p>The closest equivalent to <a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a> in Graphics View is called <a href="qabstractgraphicsshapeitem.html">QAbstractGraphicsShapeItem</a>. Unlike <a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a>, it does not define area points (<a href="q3canvaspolygonalitem.html#areaPoints">Q3CanvasPolygonalItem::areaPoints</a>()); instead, each item's geometry is stored as a member of the subclasses.</p>
<p>The <a href="q3canvaspolygonalitem.html#drawShape">Q3CanvasPolygonalItem::drawShape</a>() function is no longer available; instead, you can set the brush and pen from inside <a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>().</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a></th><th ><a href="qabstractgraphicsshapeitem.html">QAbstractGraphicsShapeItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvaspolygonalitem.html#areaPoints">Q3CanvasPolygonalItem::areaPoints</a>()</td><td >No equivalent; each item's geometry is stored in the respective subclass.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvaspolygonalitem.html#areaPointsAdvanced">Q3CanvasPolygonalItem::areaPointsAdvanced</a>()</td><td >No equivalent; you can use <a href="qpolygonf.html#translate">QPolygonF::translate</a>() or <a href="qpainterpath.html#translate">QPainterPath::translate</a>() instead.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvaspolygonalitem.html#drawShape">Q3CanvasPolygonalItem::drawShape</a>()</td><td ><a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>(). You can set the pen and brush from inside this function.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvaspolygonalitem.html#invalidate">Q3CanvasPolygonalItem::invalidate</a>()</td><td >Call <a href="qgraphicsitem.html#prepareGeometryChange">QGraphicsItem::prepareGeometryChange</a>() before changing the item's geometry.</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvaspolygonalitem.html#isValid">Q3CanvasPolygonalItem::isValid</a>()</td><td >No equivalent; items' geometry is always in a valid state.</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvaspolygonalitem.html#winding">Q3CanvasPolygonalItem::winding</a>()</td><td >This function is only useful for polygon items and path items; see <a href="qgraphicspolygonitem.html#fillRule">QGraphicsPolygonItem::fillRule</a>(), and <a href="qpainterpath.html#fillRule">QPainterPath::fillRule</a>() for <a href="qgraphicspathitem.html">QGraphicsPathItem</a>.</td></tr>
</table>
<a name="q3canvasellipse"></a>
<h3>Q3CanvasEllipse</h3>
<p>The closest equivalent to <a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a> in Graphics View is called <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a>. The most noticable difference to <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a> is that the ellipse is not longer drawn centered around its position; rather, it is drawn using a bounding <a href="qrectf.html">QRectF</a>, just like <a href="qpainter.html#drawEllipse">QPainter::drawEllipse</a>().</p>
<p>For compatibility, you may want to shift the ellipse up and to the left to keep the ellipse centered. Example:</p>
<pre class="cpp">     <span class="comment">// Before</span>
     <span class="type"><a href="q3canvasellipse.html">Q3CanvasEllipse</a></span> ellipse(<span class="number">10</span><span class="operator">,</span> <span class="number">10</span>);

     <span class="comment">// After</span>
     <span class="type"><a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a></span> ellipse(<span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> <span class="number">10</span>);</pre>
<p>Note: <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a> uses <a href="qabstractgraphicsshapeitem.html#pen">QAbstractGraphicsShapeItem::pen</a>() for outlines, whereas <a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a> did not use <a href="q3canvaspolygonalitem.html#pen">Q3CanvasPolygonalItem::pen</a>().</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a></th><th ><a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasellipse.html#angleLength">Q3CanvasEllipse::angleLength</a>()</td><td ><a href="qgraphicsellipseitem.html#spanAngle">QGraphicsEllipseItem::spanAngle</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasellipse.html#angleStart">Q3CanvasEllipse::angleStart</a>()</td><td ><a href="qgraphicsellipseitem.html#startAngle">QGraphicsEllipseItem::startAngle</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasellipse.html#setAngles">Q3CanvasEllipse::setAngles</a>()</td><td ><a href="qgraphicsellipseitem.html#setStartAngle">QGraphicsEllipseItem::setStartAngle</a>() and <a href="qgraphicsellipseitem.html#setSpanAngle">QGraphicsEllipseItem::setSpanAngle</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasellipse.html#setSize">Q3CanvasEllipse::setSize</a>()</td><td ><a href="qgraphicsellipseitem.html#setRect">QGraphicsEllipseItem::setRect</a>()</td></tr>
</table>
<a name="q3canvasline"></a>
<h3>Q3CanvasLine</h3>
<p>The closest equivalent to <a href="q3canvasline.html" class="compat">Q3CanvasLine</a> in Graphics View is called <a href="qgraphicslineitem.html">QGraphicsLineItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasline.html" class="compat">Q3CanvasLine</a></th><th ><a href="qgraphicslineitem.html">QGraphicsLineItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasline.html#endPoint">Q3CanvasLine::endPoint</a>()</td><td ><a href="qgraphicslineitem.html#line">QGraphicsLineItem::line</a>() and <a href="qlinef.html#p2">QLineF::p2</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasline.html#setPoints">Q3CanvasLine::setPoints</a>()</td><td ><a href="qgraphicslineitem.html#setLine">QGraphicsLineItem::setLine</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasline.html#startPoint">Q3CanvasLine::startPoint</a>()</td><td ><a href="qgraphicslineitem.html#line">QGraphicsLineItem::line</a>() and <a href="qlinef.html#p1">QLineF::p1</a>()</td></tr>
</table>
<a name="q3canvaspolygon"></a>
<h3>Q3CanvasPolygon</h3>
<p>The closest equivalent to <a href="q3canvaspolygon.html" class="compat">Q3CanvasPolygon</a> in Graphics View is called <a href="qgraphicspolygonitem.html">QGraphicsPolygonItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvaspolygon.html" class="compat">Q3CanvasPolygon</a></th><th ><a href="qgraphicspolygonitem.html">QGraphicsPolygonItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvaspolygon.html#areaPoints">Q3CanvasPolygon::areaPoints</a>()</td><td ><a href="qgraphicspolygonitem.html#polygon">QGraphicsPolygonItem::polygon</a>() and <a href="qgraphicsitem.html#mapToParent">QGraphicsItem::mapToParent</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvaspolygon.html#points">Q3CanvasPolygon::points</a>()</td><td ><a href="qgraphicspolygonitem.html#polygon">QGraphicsPolygonItem::polygon</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvaspolygon.html#setPoints">Q3CanvasPolygon::setPoints</a>()</td><td ><a href="qgraphicspolygonitem.html#setPolygon">QGraphicsPolygonItem::setPolygon</a>()</td></tr>
</table>
<a name="q3canvasspline"></a>
<h3>Q3CanvasSpline</h3>
<p>The closest equivalent to <a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> in Graphics View is called <a href="qgraphicspathitem.html">QGraphicsPathItem</a>. This item can be used to describe any type of path supported by <a href="qpainter.html">QPainter</a>.</p>
<p><a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> takes its control points as a <a href="q3pointarray.html" class="compat">Q3PointArray</a>, but <a href="qpainterpath.html">QPainterPath</a> operates on a sequence of calls to <a href="qpainterpath.html#moveTo">QPainterPath::moveTo</a>() and <a href="qpainterpath.html#cubicTo">QPainterPath::cubicTo</a>(). Here is how you can convert a bezier curve <a href="q3pointarray.html" class="compat">Q3PointArray</a> to a <a href="qpainterpath.html">QPainterPath</a>:</p>
<pre class="cpp"> <span class="keyword">static</span> <span class="type"><a href="qpainterpath.html">QPainterPath</a></span> fromControlPoints(<span class="keyword">const</span> <span class="type"><a href="q3pointarray.html">Q3PointArray</a></span> <span class="operator">&amp;</span>pa)
 {
     <span class="type"><a href="qpainterpath.html">QPainterPath</a></span> path;
     path<span class="operator">.</span>moveTo(pa<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>);
     <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">1</span>; i <span class="operator">&lt;</span> pa<span class="operator">.</span>size(); i <span class="operator">+</span><span class="operator">=</span> <span class="number">3</span>)
         path<span class="operator">.</span>cubicTo(pa<span class="operator">[</span>i<span class="operator">]</span><span class="operator">,</span> pa<span class="operator">[</span>(i <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> pa<span class="operator">.</span>size()<span class="operator">]</span><span class="operator">,</span> pa<span class="operator">[</span>(i <span class="operator">+</span> <span class="number">2</span>) <span class="operator">%</span> pa<span class="operator">.</span>size()<span class="operator">]</span>);
     <span class="keyword">return</span> path;
 }</pre>
<p>Note: <a href="qgraphicspathitem.html">QGraphicsPathItem</a> uses <a href="qabstractgraphicsshapeitem.html#pen">QAbstractGraphicsShapeItem::pen</a>() for outlines, whereas <a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> did not use <a href="q3canvaspolygonalitem.html#pen">Q3CanvasPolygonalItem::pen</a>().</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a></th><th ><a href="qgraphicspathitem.html">QGraphicsPathItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasspline.html#closed">Q3CanvasSpline::closed</a>()</td><td >No equivalent. You can call QPainterPath::closeSubPath() to close a subpath explicitly.</td></tr>
</table>
<a name="q3canvasrectangle"></a>
<h3>Q3CanvasRectangle</h3>
<p>The closest equivalent to <a href="q3canvasrectangle.html" class="compat">Q3CanvasRectangle</a> in Graphics View is called <a href="qgraphicsrectitem.html">QGraphicsRectItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvasrectangle.html" class="compat">Q3CanvasRectangle</a></th><th ><a href="qgraphicsrectitem.html">QGraphicsRectItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvasrectangle.html#height">Q3CanvasRectangle::height</a>()</td><td ><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#height">QRectF::height</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasrectangle.html#setSize">Q3CanvasRectangle::setSize</a>()</td><td ><a href="qgraphicsrectitem.html#setRect">QGraphicsRectItem::setRect</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasrectangle.html#size">Q3CanvasRectangle::size</a>()</td><td ><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#size">QRectF::size</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvasrectangle.html#width">Q3CanvasRectangle::width</a>()</td><td ><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#width">QRectF::width</a>()</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvasrectangle.html#chunks">Q3CanvasRectangle::chunks</a>()</td><td >No equivalent.</td></tr>
</table>
<a name="q3canvassprite"></a>
<h3>Q3CanvasSprite</h3>
<p><a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> is the item class that differs the most from its <a href="q3canvas.html" class="compat">Q3Canvas</a> predecessor. The closest resemblance of <a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> in Graphics View is <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a>.</p>
<p><a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> supports animated pixmaps; <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a>, however, is a simple single-frame pixmap item. If all you need is a pixmap item, porting is straight-forward. If you do need the animation support, extra work is required; there is no direct porting approach.</p>
<p>For the <a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, a subclass of <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a> is used to replace <a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a>, storing a list of pixmaps and a frame counter. The animation is advanced in <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>().</p>
<a name="q3canvaspixmap-q3canvaspixmaparray"></a>
<h4>Q3CanvasPixmap, Q3CanvasPixmapArray</h4>
<p>These classes have been removed from the API. You can use <a href="qpixmap.html">QPixmap</a> instead of <a href="q3canvaspixmap.html" class="compat">Q3CanvasPixmap</a>, and <a href="qlist.html">QList</a> instead of <a href="q3canvaspixmaparray.html" class="compat">Q3CanvasPixmapArray</a>.</p>
<p><a href="q3canvaspixmaparray.html" class="compat">Q3CanvasPixmapArray</a> included convenience for loading a sequence of pixmaps or masks using a path with a wildcard (see <a href="q3canvaspixmaparray.html#readPixmaps">Q3CanvasPixmapArray::readPixmaps</a>() and <a href="q3canvaspixmaparray.html#readCollisionMasks">Q3CanvasPixmapArray::readCollisionMasks</a>()). To achieve similar functionality using Graphics View, you can load the images by using <a href="qdir.html">QDir</a>:</p>
<pre class="cpp"> wildcardPath<span class="operator">.</span>replace(<span class="string">&quot;%1&quot;</span><span class="operator">,</span> <span class="string">&quot;*&quot;</span>);
 <span class="type"><a href="qfileinfo.html">QFileInfo</a></span> fi(wildcardPath);

 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qpixmap.html">QPixmap</a></span><span class="operator">&gt;</span> frames;
 <a href="qtglobal.html#foreach">foreach</a> (<span class="type"><a href="qstring.html">QString</a></span> entry<span class="operator">,</span> <span class="type"><a href="qdir.html">QDir</a></span>(fi<span class="operator">.</span>path()<span class="operator">,</span> fi<span class="operator">.</span>fileName())<span class="operator">.</span>entryList())
     frames <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qpixmap.html">QPixmap</a></span>(fi<span class="operator">.</span>path() <span class="operator">+</span> <span class="string">&quot;/&quot;</span> <span class="operator">+</span> entry);</pre>
<a name="q3canvastext"></a>
<h3>Q3CanvasText</h3>
<p><a href="q3canvastext.html" class="compat">Q3CanvasText</a> has been split into two classes in Graphics View: <a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a> and <a href="qgraphicstextitem.html">QGraphicsTextItem</a>. For porting, <a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a> should be adequate. <a href="qgraphicstextitem.html">QGraphicsTextItem</a> provides advanced document structuring features similar to that of <a href="qtextedit.html">QTextEdit</a>, and it also allows interaction (e.g&#x2e;, editing and selection).</p>
<table class="generic">
<thead><tr class="qt-style"><th ><a href="q3canvastext.html" class="compat">Q3CanvasText</a></th><th ><a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a></th></tr></thead>
<tr valign="top" class="odd"><td ><a href="q3canvastext.html#color">Q3CanvasText::color</a>()</td><td ><a href="qabstractgraphicsshapeitem.html#pen">QGraphicsSimpleTextItem::pen</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="q3canvastext.html#setColor">Q3CanvasText::setColor</a>()</td><td ><a href="qabstractgraphicsshapeitem.html#setPen">QGraphicsSimpleTextItem::setPen</a>().</td></tr>
<tr valign="top" class="odd"><td ><a href="q3canvastext.html#textFlags">Q3CanvasText::textFlags</a>()</td><td >Use <a href="qgraphicstextitem.html">QGraphicsTextItem</a> instead.</td></tr>
</table>
<a name="q3canvasitemlist"></a>
<h3>Q3CanvasItemList</h3>
<p>Use <a href="qlist.html">QList</a> instead.</p>
<a name="other-resources"></a>
<h2>Other Resources</h2>
<p>The <a href="http://doc.qt.digia.com/qq/qq21-portingcanvas.html">Porting to Qt 4.2's Graphics View</a> article in Qt Quarterly 21 covered the process of porting the Qt 3 canvas example to Qt 4. The result of this is the <a href="graphicsview-portedcanvas.html">Ported Canvas</a> example.</p>
</div>
<!-- @@@graphicsview-porting.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="porting4-designer.html">Porting UI Files to Qt 4</a>
<a class="nextPage" href="qt3to4.html">qt3to4 - The Qt 3 to 4 Porting Tool</a>
</p>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
