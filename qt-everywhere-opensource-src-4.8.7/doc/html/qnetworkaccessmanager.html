<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qnetworkaccessmanager.cpp -->
  <title>Qt 4.8: QNetworkAccessManager Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />
  <link rel="stylesheet" type="text/css" href="style/narrow.css" />
  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->

<script src="scripts/superfish.js" type="text/javascript"></script>
<script src="scripts/narrow.js" type="text/javascript"></script>

</head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.digia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt-project.org/">DEV</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://qt-project.org/doc/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.digia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.8</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt-project.org/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
             <li><a href="#">API Lookup</a> 
                 <ul> 
                     <li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
             </ul> 
             </li> 
             <li><a href="#">Qt Topics</a> 
                 <ul> 
                        <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
                        <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
                        <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
                        <li><a href="supported-platforms.html">Supported Platforms</a></li>  
                        <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
                        <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
              </ul> 
                 </li> 
                 <li><a href="#">Examples</a> 
                     <ul> 
                       <li><a href="all-examples.html">Examples</a></li> 
                       <li><a href="tutorials.html">Tutorials</a></li> 
                       <li><a href="demos.html">Demos</a></li> 
                       <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
                </ul> 
                     </li> 
                 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
 <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
               <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
               <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
               <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
               <li class="defaultLink"><a href="supported-platforms.html">Supported Platforms</a></li>  
               <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
               <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtnetwork.html">QtNetwork</a></li>
<li>QNetworkAccessManager</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#network-and-roaming-support">Network and Roaming support</a></li>
<li class="level2"><a href="#symbian-platform-security-requirements">Symbian Platform Security Requirements</a></li>
</ul>
</div>
<h1 class="title">QNetworkAccessManager Class Reference</h1>
<!-- $$$QNetworkAccessManager-brief -->
<p>The QNetworkAccessManager class allows the application to send network requests and receive replies <a href="#details">More...</a></p>
<!-- @@@QNetworkAccessManager -->
<pre class="cpp"> <span class="preprocessor">#include &lt;QNetworkAccessManager&gt;</span></pre><p><b>Inherits: </b><a href="qobject.html">QObject</a>.</p>
<p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html#reentrant">reentrant</a>.</p>
<p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="qnetworkaccessmanager-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">NetworkAccessibility</a></b> { UnknownAccessibility, NotAccessible, Accessible }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#Operation-enum">Operation</a></b> { HeadOperation, GetOperation, PutOperation, PostOperation, DeleteOperation, CustomOperation }</td></tr>
</table>
<a name="properties"></a>
<h2>Properties</h2>
<ul>
<li class="fn"><b><a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a></b> : NetworkAccessibility</li>
</ul>
<ul>
<li class="fn">1 property inherited from <a href="qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#QNetworkAccessManager">QNetworkAccessManager</a></b> ( QObject * <i>parent</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#dtor.QNetworkAccessManager">~QNetworkAccessManager</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#activeConfiguration">activeConfiguration</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractNetworkCache * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#cache">cache</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#configuration">configuration</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkCookieJar * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#cookieJar">cookieJar</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a></b> ( const QNetworkRequest &amp; <i>request</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#get">get</a></b> ( const QNetworkRequest &amp; <i>request</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#head">head</a></b> ( const QNetworkRequest &amp; <i>request</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NetworkAccessibility </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post">post</a></b> ( const QNetworkRequest &amp; <i>request</i>, QIODevice * <i>data</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post-2">post</a></b> ( const QNetworkRequest &amp; <i>request</i>, const QByteArray &amp; <i>data</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post-3">post</a></b> ( const QNetworkRequest &amp; <i>request</i>, QHttpMultiPart * <i>multiPart</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxy </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxy">proxy</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxyFactory * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxyFactory">proxyFactory</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put">put</a></b> ( const QNetworkRequest &amp; <i>request</i>, QIODevice * <i>data</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put-2">put</a></b> ( const QNetworkRequest &amp; <i>request</i>, QHttpMultiPart * <i>multiPart</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put-3">put</a></b> ( const QNetworkRequest &amp; <i>request</i>, const QByteArray &amp; <i>data</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a></b> ( const QNetworkRequest &amp; <i>request</i>, const QByteArray &amp; <i>verb</i>, QIODevice * <i>data</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setCache">setCache</a></b> ( QAbstractNetworkCache * <i>cache</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setConfiguration">setConfiguration</a></b> ( const QNetworkConfiguration &amp; <i>config</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a></b> ( QNetworkCookieJar * <i>cookieJar</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#networkAccessible-prop">setNetworkAccessible</a></b> ( NetworkAccessibility <i>accessible</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setProxy">setProxy</a></b> ( const QNetworkProxy &amp; <i>proxy</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a></b> ( QNetworkProxyFactory * <i>factory</i> )</td></tr>
</table>
<ul>
<li class="fn">29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#authenticationRequired">authenticationRequired</a></b> ( QNetworkReply * <i>reply</i>, QAuthenticator * <i>authenticator</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#finished">finished</a></b> ( QNetworkReply * <i>reply</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#networkAccessibleChanged">networkAccessibleChanged</a></b> ( QNetworkAccessManager::NetworkAccessibility <i>accessible</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a></b> ( const QNetworkProxy &amp; <i>proxy</i>, QAuthenticator * <i>authenticator</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sslErrors">sslErrors</a></b> ( QNetworkReply * <i>reply</i>, const QList&lt;QSslError&gt; &amp; <i>errors</i> )</td></tr>
</table>
<ul>
<li class="fn">1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2>Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QNetworkReply * </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#createRequest">createRequest</a></b> ( Operation <i>op</i>, const QNetworkRequest &amp; <i>req</i>, QIODevice * <i>outgoingData</i> = 0 )</td></tr>
</table>
<ul>
<li class="fn">8 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">7 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QNetworkAccessManager-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QNetworkAccessManager class allows the application to send network requests and receive replies</p>
<p>The Network Access API is constructed around one QNetworkAccessManager object, which holds the common configuration and settings for the requests it sends. It contains the proxy and cache configuration, as well as the signals related to such issues, and reply signals that can be used to monitor the progress of a network operation. One QNetworkAccessManager should be enough for the whole Qt application.</p>
<p>Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a <a href="qnetworkreply.html">QNetworkReply</a> object. The returned object is used to obtain any data returned in response to the corresponding request.</p>
<p>A simple download off the network could be accomplished with:</p>
<pre class="cpp"> <span class="type">QNetworkAccessManager</span> <span class="operator">*</span>manager <span class="operator">=</span> <span class="keyword">new</span> <span class="type">QNetworkAccessManager</span>(<span class="keyword">this</span>);
 <a href="qobject.html#connect">connect</a>(manager<span class="operator">,</span> SIGNAL(finished(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">*</span>))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(replyFinished(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">*</span>)));

 manager<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkaccessmanager.html#get">get</a>(<span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span>(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">&quot;http://qt.nokia.com&quot;</span>)));</pre>
<p>QNetworkAccessManager has an asynchronous API. When the <tt>replyFinished</tt> slot above is called, the parameter it takes is the <a href="qnetworkreply.html">QNetworkReply</a> object containing the downloaded data as well as meta-data (headers, etc.)&#x2e;</p>
<p><b>Note:</b> After the request has finished, it is the responsibility of the user to delete the <a href="qnetworkreply.html">QNetworkReply</a> object at an appropriate time. Do not directly delete it inside the slot connected to <a href="qnetworkaccessmanager.html#finished">finished</a>(). You can use the <a href="qobject.html#deleteLater">deleteLater</a>() function.</p>
<p><b>Note:</b> QNetworkAccessManager queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. Currently, for the HTTP protocol on desktop platforms, 6 requests are executed in parallel for one host/port combination.</p>
<p>A more involved example, assuming the manager is already existent, can be:</p>
<pre class="cpp"> <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> request;
 request<span class="operator">.</span>setUrl(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">&quot;http://qt.nokia.com&quot;</span>));
 request<span class="operator">.</span>setRawHeader(<span class="string">&quot;User-Agent&quot;</span><span class="operator">,</span> <span class="string">&quot;MyOwnBrowser 1.0&quot;</span>);

 <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkaccessmanager.html#get">get</a>(request);
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(readyRead())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(slotReadyRead()));
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(error(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">::</span>NetworkError))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(slotError(<span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span><span class="operator">::</span>NetworkError)));
 <a href="qobject.html#connect">connect</a>(reply<span class="operator">,</span> SIGNAL(sslErrors(<span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span>))<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> SLOT(slotSslErrors(<span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span>)));</pre>
<a name="network-and-roaming-support"></a>
<h3>Network and Roaming support</h3>
<p>With the addition of the <a href="bearer-management.html">Bearer Management</a> API to Qt 4.7 QNetworkAccessManager gained the ability to manage network connections. QNetworkAccessManager can start the network interface if the device is offline and terminates the interface if the current process is the last one to use the uplink. Note that some platform utilize grace periods from when the last application stops using a uplink until the system actually terminates the connectivity link. Roaming is equally transparent. Any queued/pending network requests are automatically transferred to new access point.</p>
<p>Clients wanting to utilize this feature should not require any changes. In fact it is likely that existing platform specific connection code can simply be removed from the application.</p>
<p><b>Note:</b> The network and roaming support in QNetworkAccessManager is conditional upon the platform supporting connection management. The <a href="qnetworkconfigurationmanager.html#Capability-enum">QNetworkConfigurationManager::NetworkSessionRequired</a> can be used to detect whether QNetworkAccessManager utilizes this feature. Currently only Meego/Harmattan and Symbian platforms provide connection management support.</p>
<p><b>Note:</b> This feature cannot be used in combination with the Bearer Management API as provided by QtMobility. Applications have to migrate to the Qt version of Bearer Management.</p>
<a name="symbian-platform-security-requirements"></a>
<h3>Symbian Platform Security Requirements</h3>
<p>On Symbian, processes which use this class must have the <tt>NetworkServices</tt> platform security capability. If the client process lacks this capability, operations will result in a panic.</p>
<p>Platform security capabilities are added via the <a href="qmake-variable-reference.html#target-capability">TARGET.CAPABILITY</a> qmake variable.</p>
</div>
<p><b>See also </b><a href="qnetworkrequest.html">QNetworkRequest</a>, <a href="qnetworkreply.html">QNetworkReply</a>, and <a href="qnetworkproxy.html">QNetworkProxy</a>.</p>
<!-- @@@QNetworkAccessManager -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$NetworkAccessibility$$$UnknownAccessibility$$$NotAccessible$$$Accessible -->
<h3 class="fn"><a name="NetworkAccessibility-enum"></a>enum QNetworkAccessManager::<span class="name">NetworkAccessibility</span></h3>
<p>Indicates whether the network is accessible via this network access manager.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::UnknownAccessibility</tt></td><td class="topAlign"><tt>-1</tt></td><td class="topAlign">The network accessibility cannot be determined.</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::NotAccessible</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to <a href="qnetworkaccessmanager.html#networkAccessible-prop">setNetworkAccessible</a>().</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::Accessible</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">The network is accessible.</td></tr>
</table>
<p><b>See also </b><a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a>.</p>
<!-- @@@NetworkAccessibility -->
<!-- $$$Operation$$$HeadOperation$$$GetOperation$$$PutOperation$$$PostOperation$$$DeleteOperation$$$CustomOperation$$$UnknownOperation -->
<h3 class="fn"><a name="Operation-enum"></a>enum QNetworkAccessManager::<span class="name">Operation</span></h3>
<p>Indicates the operation this reply is processing.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::HeadOperation</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">retrieve headers operation (created with <a href="qnetworkaccessmanager.html#head">head</a>())</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::GetOperation</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">retrieve headers and download contents (created with <a href="qnetworkaccessmanager.html#get">get</a>())</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::PutOperation</tt></td><td class="topAlign"><tt>3</tt></td><td class="topAlign">upload contents operation (created with <a href="qnetworkaccessmanager.html#put">put</a>())</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::PostOperation</tt></td><td class="topAlign"><tt>4</tt></td><td class="topAlign">send the contents of an HTML form for processing via HTTP POST (created with <a href="qnetworkaccessmanager.html#post">post</a>())</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::DeleteOperation</tt></td><td class="topAlign"><tt>5</tt></td><td class="topAlign">delete contents operation (created with <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>())</td></tr>
<tr><td class="topAlign"><tt>QNetworkAccessManager::CustomOperation</tt></td><td class="topAlign"><tt>6</tt></td><td class="topAlign">custom operation (created with <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>())</td></tr>
</table>
<p>This enum was introduced or modified in Qt 4.7.</p>
<p><b>See also </b><a href="qnetworkreply.html#operation">QNetworkReply::operation</a>().</p>
<!-- @@@Operation -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$networkAccessible-prop$$$networkAccessible$$$setNetworkAccessibleNetworkAccessibility$$$networkAccessibleChangedQNetworkAccessManager::NetworkAccessibility -->
<h3 class="fn"><a name="networkAccessible-prop"></a><span class="name">networkAccessible</span> : <span class="type"><a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">NetworkAccessibility</a></span></h3>
<p>This property holds whether the network is currently accessible via this network access manager.</p>
<p>If the network is <a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">not accessible</a> the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</p>
<p>By default the value of this property reflects the physical state of the device. Applications may override it to disable all network requests via this network access manager by calling</p>
<pre class="cpp"> networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setNetworkAccessible(<span class="type"><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a></span><span class="operator">::</span>NotAccessible);</pre>
<p>Network requests can be reenabled again by calling</p>
<pre class="cpp"> networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setNetworkAccessible(<span class="type"><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a></span><span class="operator">::</span>Accessible);</pre>
<p><b>Note:</b> Calling setNetworkAccessible() does not change the network state.</p>
<p>This property was introduced in Qt 4.7.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> NetworkAccessibility </td><td class="memItemRight bottomAlign"><span class="name"><b>networkAccessible</b></span> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setNetworkAccessible</b></span> ( NetworkAccessibility <i>accessible</i> )</td></tr>
</table>
<p><b>Notifier signal:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qnetworkaccessmanager.html#networkAccessibleChanged">networkAccessibleChanged</a></b></span> ( QNetworkAccessManager::NetworkAccessibility <i>accessible</i> )</td></tr>
</table>
<!-- @@@networkAccessible -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QNetworkAccessManager[overload1]$$$QNetworkAccessManagerQObject* -->
<h3 class="fn"><a name="QNetworkAccessManager"></a>QNetworkAccessManager::<span class="name">QNetworkAccessManager</span> ( <span class="type"><a href="qobject.html">QObject</a></span> * <i>parent</i> = 0 )</h3>
<p>Constructs a <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object that is the center of the Network Access API and sets <i>parent</i> as the parent object.</p>
<!-- @@@QNetworkAccessManager -->
<!-- $$$~QNetworkAccessManager[overload1]$$$~QNetworkAccessManager -->
<h3 class="fn"><a name="dtor.QNetworkAccessManager"></a>QNetworkAccessManager::<span class="name">~QNetworkAccessManager</span> ()</h3>
<p>Destroys the <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object and frees up any resources. Note that <a href="qnetworkreply.html">QNetworkReply</a> objects that are returned from this class have this object set as their parents, which means that they will be deleted along with it if you don't call <a href="qobject.html#setParent">QObject::setParent</a>() on them.</p>
<!-- @@@~QNetworkAccessManager -->
<!-- $$$activeConfiguration[overload1]$$$activeConfiguration -->
<h3 class="fn"><a name="activeConfiguration"></a><span class="type"><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></span> QNetworkAccessManager::<span class="name">activeConfiguration</span> () const</h3>
<p>Returns the current active network configuration.</p>
<p>If the network configuration returned by <a href="qnetworkaccessmanager.html#configuration">configuration</a>() is of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::ServiceNetwork</a> this function will return the current active child network configuration of that configuration. Otherwise returns the same network configuration as <a href="qnetworkaccessmanager.html#configuration">configuration</a>().</p>
<p>Use this function to return the actual network configuration currently in use by the network session.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#configuration">configuration</a>().</p>
<!-- @@@activeConfiguration -->
<!-- $$$authenticationRequired[overload1]$$$authenticationRequiredQNetworkReply*QAuthenticator* -->
<h3 class="fn"><a name="authenticationRequired"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">authenticationRequired</span> ( <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * <i>reply</i>, <span class="type"><a href="qauthenticator.html">QAuthenticator</a></span> * <i>authenticator</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the <i>reply</i> object) in the <i>authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</p>
<p><b>Note:</b> It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>
<!-- @@@authenticationRequired -->
<!-- $$$cache[overload1]$$$cache -->
<h3 class="fn"><a name="cache"></a><span class="type"><a href="qabstractnetworkcache.html">QAbstractNetworkCache</a></span> * QNetworkAccessManager::<span class="name">cache</span> () const</h3>
<p>Returns the cache that is used to store data obtained from the network.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setCache">setCache</a>().</p>
<!-- @@@cache -->
<!-- $$$configuration[overload1]$$$configuration -->
<h3 class="fn"><a name="configuration"></a><span class="type"><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></span> QNetworkAccessManager::<span class="name">configuration</span> () const</h3>
<p>Returns the network configuration that will be used to create the <a href="qnetworksession.html">network session</a> which will be used when processing network requests.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setConfiguration">setConfiguration</a>() and <a href="qnetworkaccessmanager.html#activeConfiguration">activeConfiguration</a>().</p>
<!-- @@@configuration -->
<!-- $$$cookieJar[overload1]$$$cookieJar -->
<h3 class="fn"><a name="cookieJar"></a><span class="type"><a href="qnetworkcookiejar.html">QNetworkCookieJar</a></span> * QNetworkAccessManager::<span class="name">cookieJar</span> () const</h3>
<p>Returns the <a href="qnetworkcookiejar.html">QNetworkCookieJar</a> that is used to store cookies obtained from the network as well as cookies that are about to be sent.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a>().</p>
<!-- @@@cookieJar -->
<!-- $$$createRequest[overload1]$$$createRequestOperationconstQNetworkRequest&QIODevice* -->
<h3 class="fn"><a name="createRequest"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">createRequest</span> ( <span class="type"><a href="qnetworkaccessmanager.html#Operation-enum">Operation</a></span> <i>op</i>, const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>req</i>, <span class="type"><a href="qiodevice.html">QIODevice</a></span> * <i>outgoingData</i> = 0 )<tt> [virtual protected]</tt></h3>
<p>Returns a new <a href="qnetworkreply.html">QNetworkReply</a> object to handle the operation <i>op</i> and request <i>req</i>. The device <i>outgoingData</i> is always 0 for Get and Head requests, but is the value passed to <a href="qnetworkaccessmanager.html#post">post</a>() and <a href="qnetworkaccessmanager.html#put">put</a>() in those operations (the <a href="qbytearray.html">QByteArray</a> variants will pass a <a href="qbuffer.html">QBuffer</a> object).</p>
<p>The default implementation calls <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</a>() on the cookie jar set with <a href="qnetworkaccessmanager.html#setCookieJar">setCookieJar</a>() to obtain the cookies to be sent to the remote server.</p>
<p>The returned object must be in an open state.</p>
<!-- @@@createRequest -->
<!-- $$$deleteResource[overload1]$$$deleteResourceconstQNetworkRequest& -->
<h3 class="fn"><a name="deleteResource"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">deleteResource</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i> )</h3>
<p>Sends a request to delete the resource identified by the URL of <i>request</i>.</p>
<p><b>Note:</b> This feature is currently available for HTTP only, performing an HTTP DELETE request.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>
<!-- @@@deleteResource -->
<!-- $$$finished[overload1]$$$finishedQNetworkReply* -->
<h3 class="fn"><a name="finished"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">finished</span> ( <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * <i>reply</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted whenever a pending network reply is finished. The <i>reply</i> parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the <a href="qnetworkreply.html#finished">QNetworkReply::finished</a>() signal.</p>
<p>See <a href="qnetworkreply.html#finished">QNetworkReply::finished</a>() for information on the status that the object will be in.</p>
<p><b>Note:</b> Do not delete the <i>reply</i> object in the slot connected to this signal. Use <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<p><b>See also </b><a href="qnetworkreply.html#finished">QNetworkReply::finished</a>() and <a href="qnetworkreply.html#error">QNetworkReply::error</a>().</p>
<!-- @@@finished -->
<!-- $$$get[overload1]$$$getconstQNetworkRequest& -->
<h3 class="fn"><a name="get"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">get</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i> )</h3>
<p>Posts a request to obtain the contents of the target <i>request</i> and returns a new <a href="qnetworkreply.html">QNetworkReply</a> object opened for reading which emits the <a href="qiodevice.html#readyRead">readyRead()</a> signal whenever new data arrives.</p>
<p>The contents as well as associated headers will be downloaded.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>
<!-- @@@get -->
<!-- $$$head[overload1]$$$headconstQNetworkRequest& -->
<h3 class="fn"><a name="head"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">head</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i> )</h3>
<p>Posts a request to obtain the network headers for <i>request</i> and returns a new <a href="qnetworkreply.html">QNetworkReply</a> object which will contain such headers.</p>
<p>The function is named after the HTTP request associated (HEAD).</p>
<!-- @@@head -->
<!-- $$$networkAccessibleChanged[overload1]$$$networkAccessibleChangedQNetworkAccessManager::NetworkAccessibility -->
<h3 class="fn"><a name="networkAccessibleChanged"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">networkAccessibleChanged</span> ( <span class="type"><a href="qnetworkaccessmanager.html#NetworkAccessibility-enum">QNetworkAccessManager::NetworkAccessibility</a></span> <i>accessible</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when the value of the <a href="qnetworkaccessmanager.html#networkAccessible-prop">networkAccessible</a> property changes. <i>accessible</i> is the new network accessibility.</p>
<!-- @@@networkAccessibleChanged -->
<!-- $$$post[overload1]$$$postconstQNetworkRequest&QIODevice* -->
<h3 class="fn"><a name="post"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">post</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, <span class="type"><a href="qiodevice.html">QIODevice</a></span> * <i>data</i> )</h3>
<p>Sends an HTTP POST request to the destination specified by <i>request</i> and returns a new <a href="qnetworkreply.html">QNetworkReply</a> object opened for reading that will contain the reply sent by the server. The contents of the <i>data</i> device will be uploaded to the server.</p>
<p><i>data</i> must be open for reading and must remain valid until the <a href="qnetworkaccessmanager.html#finished">finished</a>() signal is emitted for this reply.</p>
<p><b>Note:</b> Sending a POST request on protocols other than HTTP and HTTPS is undefined and will probably fail.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>
<!-- @@@post -->
<!-- $$$post$$$postconstQNetworkRequest&constQByteArray& -->
<h3 class="fn"><a name="post-2"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">post</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp; <i>data</i> )</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i>data</i> byte array to the destination specified by <i>request</i>.</p>
<!-- @@@post -->
<!-- $$$post$$$postconstQNetworkRequest&QHttpMultiPart* -->
<h3 class="fn"><a name="post-3"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">post</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, <span class="type"><a href="qhttpmultipart.html">QHttpMultiPart</a></span> * <i>multiPart</i> )</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i>multiPart</i> message to the destination specified by <i>request</i>.</p>
<p>This can be used for sending MIME multipart messages over HTTP.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also </b><a href="qhttpmultipart.html">QHttpMultiPart</a>, <a href="qhttppart.html">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#put">put</a>().</p>
<!-- @@@post -->
<!-- $$$proxy[overload1]$$$proxy -->
<h3 class="fn"><a name="proxy"></a><span class="type"><a href="qnetworkproxy.html">QNetworkProxy</a></span> QNetworkAccessManager::<span class="name">proxy</span> () const</h3>
<p>Returns the <a href="qnetworkproxy.html">QNetworkProxy</a> that the requests sent using this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object will use. The default value for the proxy is <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy::DefaultProxy</a>.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), <a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>(), and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>
<!-- @@@proxy -->
<!-- $$$proxyAuthenticationRequired[overload1]$$$proxyAuthenticationRequiredconstQNetworkProxy&QAuthenticator* -->
<h3 class="fn"><a name="proxyAuthenticationRequired"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">proxyAuthenticationRequired</span> ( const <span class="type"><a href="qnetworkproxy.html">QNetworkProxy</a></span> &amp; <i>proxy</i>, <span class="type"><a href="qauthenticator.html">QAuthenticator</a></span> * <i>authenticator</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted whenever a proxy requests authentication and <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy <i>proxy</i> in the <i>authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will cache the credentials internally. The next time the proxy requests authentication, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</p>
<p>If the proxy rejects the credentials, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will emit the signal again.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxy">proxy</a>(), <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), and <a href="qnetworkaccessmanager.html#authenticationRequired">authenticationRequired</a>().</p>
<!-- @@@proxyAuthenticationRequired -->
<!-- $$$proxyFactory[overload1]$$$proxyFactory -->
<h3 class="fn"><a name="proxyFactory"></a><span class="type"><a href="qnetworkproxyfactory.html">QNetworkProxyFactory</a></span> * QNetworkAccessManager::<span class="name">proxyFactory</span> () const</h3>
<p>Returns the proxy factory that this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> object is using to determine the proxies to be used for requests.</p>
<p>Note that the pointer returned by this function is managed by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> and could be deleted at any time.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>() and <a href="qnetworkaccessmanager.html#proxy">proxy</a>().</p>
<!-- @@@proxyFactory -->
<!-- $$$put[overload1]$$$putconstQNetworkRequest&QIODevice* -->
<h3 class="fn"><a name="put"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">put</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, <span class="type"><a href="qiodevice.html">QIODevice</a></span> * <i>data</i> )</h3>
<p>Uploads the contents of <i>data</i> to the destination <i>request</i> and returnes a new <a href="qnetworkreply.html">QNetworkReply</a> object that will be open for reply.</p>
<p><i>data</i> must be opened for reading when this function is called and must remain valid until the <a href="qnetworkaccessmanager.html#finished">finished</a>() signal is emitted for this reply.</p>
<p>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</p>
<p><b>Note:</b> For HTTP, this request will send a PUT request, which most servers do not allow. Form upload mechanisms, including that of uploading files through HTML forms, use the POST mechanism.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest">sendCustomRequest</a>().</p>
<!-- @@@put -->
<!-- $$$put$$$putconstQNetworkRequest&QHttpMultiPart* -->
<h3 class="fn"><a name="put-2"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">put</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, <span class="type"><a href="qhttpmultipart.html">QHttpMultiPart</a></span> * <i>multiPart</i> )</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i>multiPart</i> message to the destination specified by <i>request</i>.</p>
<p>This can be used for sending MIME multipart messages over HTTP.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also </b><a href="qhttpmultipart.html">QHttpMultiPart</a>, <a href="qhttppart.html">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#post">post</a>().</p>
<!-- @@@put -->
<!-- $$$put$$$putconstQNetworkRequest&constQByteArray& -->
<h3 class="fn"><a name="put-3"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">put</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp; <i>data</i> )</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i>data</i> byte array to the destination specified by <i>request</i>.</p>
<!-- @@@put -->
<!-- $$$sendCustomRequest[overload1]$$$sendCustomRequestconstQNetworkRequest&constQByteArray&QIODevice* -->
<h3 class="fn"><a name="sendCustomRequest"></a><span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * QNetworkAccessManager::<span class="name">sendCustomRequest</span> ( const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp; <i>request</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp; <i>verb</i>, <span class="type"><a href="qiodevice.html">QIODevice</a></span> * <i>data</i> = 0 )</h3>
<p>Sends a custom request to the server identified by the URL of <i>request</i>.</p>
<p>It is the user's responsibility to send a <i>verb</i> to the server that is valid according to the HTTP specification.</p>
<p>This method provides means to send verbs other than the common ones provided via <a href="qnetworkaccessmanager.html#get">get</a>() or <a href="qnetworkaccessmanager.html#post">post</a>() etc., for instance sending an HTTP OPTIONS command.</p>
<p>If <i>data</i> is not empty, the contents of the <i>data</i> device will be uploaded to the server; in that case, data must be open for reading and must remain valid until the <a href="qnetworkaccessmanager.html#finished">finished</a>() signal is emitted for this reply.</p>
<p><b>Note:</b> This feature is currently available for HTTP(S) only.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get">get</a>(), <a href="qnetworkaccessmanager.html#post">post</a>(), <a href="qnetworkaccessmanager.html#put">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource">deleteResource</a>().</p>
<!-- @@@sendCustomRequest -->
<!-- $$$setCache[overload1]$$$setCacheQAbstractNetworkCache* -->
<h3 class="fn"><a name="setCache"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">setCache</span> ( <span class="type"><a href="qabstractnetworkcache.html">QAbstractNetworkCache</a></span> * <i>cache</i> )</h3>
<p>Sets the manager's network cache to be the <i>cache</i> specified. The cache is used for all requests dispatched by the manager.</p>
<p>Use this function to set the network cache object to a class that implements additional features, like saving the cookies to permanent storage.</p>
<p><b>Note:</b> <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> takes ownership of the <i>cache</i> object.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> by default does not have a set cache. Qt provides a simple disk cache, <a href="qnetworkdiskcache.html">QNetworkDiskCache</a>, which can be used.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#cache">cache</a>() and <a href="qnetworkrequest.html#CacheLoadControl-enum">QNetworkRequest::CacheLoadControl</a>.</p>
<!-- @@@setCache -->
<!-- $$$setConfiguration[overload1]$$$setConfigurationconstQNetworkConfiguration& -->
<h3 class="fn"><a name="setConfiguration"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">setConfiguration</span> ( const <span class="type"><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></span> &amp; <i>config</i> )</h3>
<p>Sets the network configuration that will be used when creating the <a href="qnetworksession.html">network session</a> to <i>config</i>.</p>
<p>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>() will be used.</p>
<p>To restore the default network configuration set the network configuration to the value returned from <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>().</p>
<pre class="cpp"> <span class="type"><a href="qnetworkconfigurationmanager.html">QNetworkConfigurationManager</a></span> manager;
 networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setConfiguration(manager<span class="operator">.</span>defaultConfiguration());</pre>
<p>If an invalid network configuration is set, a network session will not be created. In this case network requests will be processed regardless, but may fail. For example:</p>
<pre class="cpp"> networkAccessManager<span class="operator">-</span><span class="operator">&gt;</span>setConfiguration(<span class="type"><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></span>());</pre>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#configuration">configuration</a>() and <a href="qnetworksession.html">QNetworkSession</a>.</p>
<!-- @@@setConfiguration -->
<!-- $$$setCookieJar[overload1]$$$setCookieJarQNetworkCookieJar* -->
<h3 class="fn"><a name="setCookieJar"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">setCookieJar</span> ( <span class="type"><a href="qnetworkcookiejar.html">QNetworkCookieJar</a></span> * <i>cookieJar</i> )</h3>
<p>Sets the manager's cookie jar to be the <i>cookieJar</i> specified. The cookie jar is used by all requests dispatched by the manager.</p>
<p>Use this function to set the cookie jar object to a class that implements additional features, like saving the cookies to permanent storage.</p>
<p><b>Note:</b> <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> takes ownership of the <i>cookieJar</i> object.</p>
<p>If <i>cookieJar</i> is in the same thread as this <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, it will set the parent of the <i>cookieJar</i> so that the cookie jar is deleted when this object is deleted as well. If you want to share cookie jars between different <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> objects, you may want to set the cookie jar's parent to 0 after calling this function.</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> by default does not implement any cookie policy of its own: it accepts all cookies sent by the server, as long as they are well formed and meet the minimum security requirements (cookie domain matches the request's and cookie path matches the request's). In order to implement your own security policy, override the <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</a>() and <a href="qnetworkcookiejar.html#setCookiesFromUrl">QNetworkCookieJar::setCookiesFromUrl</a>() virtual functions. Those functions are called by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> when it detects a new cookie.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#cookieJar">cookieJar</a>(), <a href="qnetworkcookiejar.html#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</a>(), and <a href="qnetworkcookiejar.html#setCookiesFromUrl">QNetworkCookieJar::setCookiesFromUrl</a>().</p>
<!-- @@@setCookieJar -->
<!-- $$$setProxy[overload1]$$$setProxyconstQNetworkProxy& -->
<h3 class="fn"><a name="setProxy"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">setProxy</span> ( const <span class="type"><a href="qnetworkproxy.html">QNetworkProxy</a></span> &amp; <i>proxy</i> )</h3>
<p>Sets the proxy to be used in future requests to be <i>proxy</i>. This does not affect requests that have already been sent. The <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>() signal will be emitted if the proxy requests authentication.</p>
<p>A proxy set with this function will be used for all requests issued by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. In some cases, it might be necessary to select different proxies depending on the type of request being sent or the destination host. If that's the case, you should consider using <a href="qnetworkaccessmanager.html#setProxyFactory">setProxyFactory</a>().</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxy">proxy</a>() and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a>().</p>
<!-- @@@setProxy -->
<!-- $$$setProxyFactory[overload1]$$$setProxyFactoryQNetworkProxyFactory* -->
<h3 class="fn"><a name="setProxyFactory"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">setProxyFactory</span> ( <span class="type"><a href="qnetworkproxyfactory.html">QNetworkProxyFactory</a></span> * <i>factory</i> )</h3>
<p>Sets the proxy factory for this class to be <i>factory</i>. A proxy factory is used to determine a more specific list of proxies to be used for a given request, instead of trying to use the same proxy value for all requests.</p>
<p>All queries sent by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> will have type <a href="qnetworkproxyquery.html#QueryType-enum">QNetworkProxyQuery::UrlRequest</a>.</p>
<p>For example, a proxy factory could apply the following rules:</p>
<ul>
<li>if the target address is in the local network (for example, if the hostname contains no dots or if it's an IP address in the organization's range), return <a href="qnetworkproxy.html#ProxyType-enum">QNetworkProxy::NoProxy</a></li>
<li>if the request is FTP, return an FTP proxy</li>
<li>if the request is HTTP or HTTPS, then return an HTTP proxy</li>
<li>otherwise, return a SOCKSv5 proxy server</li>
</ul>
<p>The lifetime of the object <i>factory</i> will be managed by <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. It will delete the object when necessary.</p>
<p><b>Note:</b> If a specific proxy is set with <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), the factory will not be used.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxyFactory">proxyFactory</a>(), <a href="qnetworkaccessmanager.html#setProxy">setProxy</a>(), and <a href="qnetworkproxyquery.html">QNetworkProxyQuery</a>.</p>
<!-- @@@setProxyFactory -->
<!-- $$$sslErrors[overload1]$$$sslErrorsQNetworkReply*constQList<QSslError>& -->
<h3 class="fn"><a name="sslErrors"></a><span class="type">void</span> QNetworkAccessManager::<span class="name">sslErrors</span> ( <span class="type"><a href="qnetworkreply.html">QNetworkReply</a></span> * <i>reply</i>, const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; &amp; <i>errors</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The <i>errors</i> parameter contains the list of errors and <i>reply</i> is the <a href="qnetworkreply.html">QNetworkReply</a> that is encountering these errors.</p>
<p>To indicate that the errors are not fatal and that the connection should proceed, the <a href="qnetworkreply.html#ignoreSslErrors">QNetworkReply::ignoreSslErrors</a>() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</p>
<p>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</p>
<p><b>See also </b><a href="qsslsocket.html#sslErrors">QSslSocket::sslErrors</a>(), <a href="qnetworkreply.html#sslErrors">QNetworkReply::sslErrors</a>(), <a href="qnetworkreply.html#sslConfiguration">QNetworkReply::sslConfiguration</a>(), and <a href="qnetworkreply.html#ignoreSslErrors">QNetworkReply::ignoreSslErrors</a>().</p>
<!-- @@@sslErrors -->
</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2015 The Qt Company Ltd.
      Documentation contributions included herein are the copyrights of
      their respective owners.</p>
    <br />
    <p>
      The documentation provided herein is licensed under the terms of the
      <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation
      License version 1.3</a> as published by the Free Software Foundation.</p>
    <p>
      Documentation sources may be obtained from <a href="http://www.qt-project.org">
      www.qt-project.org</a>.</p>
    <br />
    <p>
      Qt and respective logos are trademarks of The Qt Company Ltd 
      in Finland and/or other countries worldwide. All other trademarks are property
      of their respective owners. <a title="Privacy Policy"
      href="http://en.gitorious.org/privacy_policy/">Privacy Policy</a></p>
  </div>

  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
